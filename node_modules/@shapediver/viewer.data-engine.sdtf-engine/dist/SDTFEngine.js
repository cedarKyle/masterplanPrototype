"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDTFEngine = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const sdk_sdtf_v1_1 = require("@shapediver/sdk.sdtf-v1");
const sdk_sdtf_primitives_1 = require("@shapediver/sdk.sdtf-primitives");
let SDTFEngine = class SDTFEngine {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor() {
        // #region Properties (2)
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    /**
     * Load the sdtf content into a scene graph node.
     *
     * @param content the geometry content
     * @returns the scene graph node
     */
    loadContent(content, jwtToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = new viewer_shared_node_tree_1.TreeNode('sdtf');
            // We have to be safe and check if the content is a valid SDTF file
            if (!content || (content && !content.href)) {
                const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDTFEngine.loadContent: Invalid content was provided to geometry engine.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `SDTFEngine.loadContent`, error);
            }
            // create the sdtf sdk
            const sdk = jwtToken ? yield (0, sdk_sdtf_v1_1.create)({ authToken: jwtToken }) : yield (0, sdk_sdtf_v1_1.create)();
            // crete the sdtf parser
            const parser = sdk.createParser();
            // parse the file
            this._parsedFile = yield parser.readFromUrl(content.href);
            try {
                // crete the overview and save it in the node data
                node.data.push(yield this.createSDTFOverview());
                // add the loaded chunks to the node
                for (let i = 0; i < this._parsedFile.chunks.length; i++)
                    node.children.push(yield this.loadChunk(this._parsedFile.chunks[i], i));
                return node;
            }
            catch (e) {
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `SDTFEngine.load`, e);
            }
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (5)
    /**
     * Create an overview of the SDTF file.
     * This overview is used for the data visualization.
     * It is structured as a dictionary with the name as the key and an array of Objects as the value.
     * The array of objects contains the different types that can be found in the SDTF file under the same name.
     *
     * Example:
     * {
     *     "color": [
     *         {
     *             typeHint: 'string',
     *             count: 2,
     *             values: ["red", "blue"]
     *         },
     *         {
     *             typeHint: 'numberArray',
     *             count: 2,
     *             values: [[1,0,0,1], [0,0,1,1]]
     *         },
     *     ]
     * }
     *
     * The overview contains the following information:
     * - name of the attribute + type of the attribute
     * - the count
     * - for numerical attributes, the min and max values
     * - for string attributes, the unique values
     *
     * @returns
     */
    createSDTFOverview() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const overview = {};
            // go through all attributes
            for (let i = 0; i < this._parsedFile.attributes.length; i++) {
                const attributes = this._parsedFile.attributes[i];
                // go through all entries
                for (let key in attributes.entries) {
                    const dataToCopy = attributes.entries[key];
                    const value = yield dataToCopy.getContent();
                    // create the type hint to use
                    const dataTypehint = dataToCopy.typeHint === undefined ? 'undefined' : dataToCopy.typeHint.name;
                    // check if the attribute is already in the overview
                    const existingEntries = overview[key] ? overview[key].filter(o => o.typeHint === dataTypehint) : [];
                    if (overview[key] && existingEntries.length > 0) {
                        // update the existing entry
                        const entry = existingEntries[0];
                        // update the count
                        entry.count++;
                        // update the values
                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {
                            if (!((_a = entry.values) === null || _a === void 0 ? void 0 : _a.includes(value)))
                                (_b = entry.values) === null || _b === void 0 ? void 0 : _b.push(value);
                        }
                        // update the min and max
                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {
                            entry.min = Math.min(value, entry.min);
                            entry.max = Math.max(value, entry.max);
                        }
                    }
                    else {
                        // create a new entry, if the name already exists, but the type does not
                        if (overview[key]) {
                            overview[key].push({
                                typeHint: dataTypehint,
                                count: 1,
                            });
                        }
                        // create completely new entry
                        else {
                            overview[key] = [{
                                    typeHint: dataTypehint,
                                    count: 1,
                                }];
                        }
                        // update the values
                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {
                            overview[key][overview[key].length - 1].values = [value];
                        }
                        // update the min and max
                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {
                            overview[key][overview[key].length - 1].min = value;
                            overview[key][overview[key].length - 1].max = value;
                        }
                    }
                }
            }
            return new viewer_shared_types_1.SDTFOverviewData(overview);
        });
    }
    /**
     * Load the attributes into a SDTFAttributesData data item.
     *
     * @param attributes
     * @returns
     */
    loadAttributes(attributes) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const data = new viewer_shared_types_1.SDTFAttributesData();
            // go through all attributes entries and save them in data items
            for (let key in attributes.entries) {
                if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType((_a = attributes.entries[key].typeHint) === null || _a === void 0 ? void 0 : _a.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType((_b = attributes.entries[key].typeHint) === null || _b === void 0 ? void 0 : _b.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType((_c = attributes.entries[key].typeHint) === null || _c === void 0 ? void 0 : _c.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType((_d = attributes.entries[key].typeHint) === null || _d === void 0 ? void 0 : _d.name)) {
                    // create the data item and save it in the dictionary
                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;
                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, yield attributes.entries[key].getContent());
                }
                else {
                    // async data
                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;
                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, () => __awaiter(this, void 0, void 0, function* () {
                        return yield attributes.entries[key].getContent();
                    }));
                }
            }
            return data;
        });
    }
    /**
     * Load the chunk into a scene graph node.
     *
     * @param chunk
     * @param chunkId
     * @returns
     */
    loadChunk(chunk, chunkId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkDef = new viewer_shared_node_tree_1.TreeNode(chunk.name || 'chunk_' + chunkId);
            // if there are attributes, add them to the chunk as data
            if (chunk.attributes !== undefined) {
                chunkDef.data.push(yield this.loadAttributes(chunk.attributes));
            }
            // if there are items, add them to the chunk as children
            if (chunk.items !== undefined && chunk.items.length > 0) {
                for (let i = 0, len = chunk.items.length; i < len; i++) {
                    // got through all items
                    chunkDef.addChild(yield this.loadItem(chunk.items[i], i));
                }
            }
            // if there are nodes, add them to the chunk as children
            if (chunk.nodes !== undefined && chunk.nodes.length > 0) {
                for (let i = 0, len = chunk.nodes.length; i < len; i++) {
                    // got through all children
                    chunkDef.addChild(yield this.loadNode(chunk.nodes[i], i));
                }
            }
            return chunkDef;
        });
    }
    /**
     * Load the item into a scene graph node.
     *
     * @param item
     * @param itemId
     * @returns
     */
    loadItem(item, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            const itemDef = new viewer_shared_node_tree_1.TreeNode(itemId + '');
            // if there are attributes, add them to the item
            let attributes;
            if (item.attributes !== undefined)
                attributes = yield this.loadAttributes(item.attributes);
            // create the typehint
            const typeHint = item.typeHint === undefined ? 'undefined' : item.typeHint.name;
            let itemData;
            // create the data and save it in the item node
            if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(typeHint)) {
                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, yield item.getContent(), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);
            }
            else {
                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, () => __awaiter(this, void 0, void 0, function* () {
                    return yield item.getContent();
                }), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);
            }
            itemDef.data.push(itemData);
            return itemDef;
        });
    }
    /**
     * Load the node into a scene graph node.
     *
     * @param node
     * @param nodeId
     * @returns
     */
    loadNode(node, nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);
            // if there are attributes, add them to the node as data
            if (node.attributes !== undefined) {
                nodeDef.data.push(yield this.loadAttributes(node.attributes));
            }
            // if there are items, add them to the node as children
            if (node.items !== undefined && node.items.length > 0) {
                for (let i = 0, len = node.items.length; i < len; i++) {
                    // got through all items
                    nodeDef.addChild(yield this.loadItem(node.items[i], i));
                }
            }
            // if there are nodes, add them to the node as children
            if (node.nodes !== undefined && node.nodes.length > 0) {
                for (let i = 0, len = node.nodes.length; i < len; i++) {
                    // got through all children
                    nodeDef.addChild(yield this.loadNode(node.nodes[i], i));
                }
            }
            return nodeDef;
        });
    }
};
SDTFEngine = __decorate([
    (0, tsyringe_1.singleton)(),
    __metadata("design:paramtypes", [])
], SDTFEngine);
exports.SDTFEngine = SDTFEngine;
//# sourceMappingURL=SDTFEngine.js.map