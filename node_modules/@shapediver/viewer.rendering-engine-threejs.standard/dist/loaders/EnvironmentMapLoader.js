"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvironmentMapLoader = exports.ENVIRONMENT_MAP_TYPE = exports.ENVIRONMENT_MAP = exports.ENVIRONMENT_MAP_CUBE = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const RGBELoader_1 = require("../three/loaders/RGBELoader");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
var ENVIRONMENT_MAP_CUBE;
(function (ENVIRONMENT_MAP_CUBE) {
    ENVIRONMENT_MAP_CUBE["DEFAULT"] = "default";
    ENVIRONMENT_MAP_CUBE["DEFAULT_BW"] = "default_bw";
    ENVIRONMENT_MAP_CUBE["BLURRED_LIGHTS"] = "blurred_lights";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR"] = "georgentor";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BLUR"] = "georgentor_blur";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BLUE_BLUR"] = "georgentor_blue_blur";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BW_BLUR"] = "georgentor_bw_blur";
    ENVIRONMENT_MAP_CUBE["LEVELSETS"] = "levelsets";
    ENVIRONMENT_MAP_CUBE["LYTHWOOD_FIELD"] = "lythwood_field";
    ENVIRONMENT_MAP_CUBE["MOUNTAINS"] = "mountains";
    ENVIRONMENT_MAP_CUBE["OCEAN"] = "ocean";
    ENVIRONMENT_MAP_CUBE["PIAZZA_SAN_MARCO"] = "piazza_san_marco";
    ENVIRONMENT_MAP_CUBE["RESIDENTIAL_GARDEN"] = "residential_garden";
    ENVIRONMENT_MAP_CUBE["ROOM_ABSTRACT_1"] = "room_abstract_1";
    ENVIRONMENT_MAP_CUBE["SKY"] = "sky";
    ENVIRONMENT_MAP_CUBE["STORAGE_ROOM"] = "storage_room";
    ENVIRONMENT_MAP_CUBE["STORM"] = "storm";
    ENVIRONMENT_MAP_CUBE["SUBWAY_ENTRANCE"] = "subway_entrance";
    ENVIRONMENT_MAP_CUBE["SUBWAY_ENTRANCE_BW_BLUR"] = "subway_entrance_bw_blur";
    ENVIRONMENT_MAP_CUBE["WHITE"] = "white";
    ENVIRONMENT_MAP_CUBE["YOKOHAMA"] = "yokohama";
})(ENVIRONMENT_MAP_CUBE = exports.ENVIRONMENT_MAP_CUBE || (exports.ENVIRONMENT_MAP_CUBE = {}));
var ENVIRONMENT_MAP;
(function (ENVIRONMENT_MAP) {
    ENVIRONMENT_MAP["ANNIVERSARY_LOUNGE"] = "anniversary_lounge";
    ENVIRONMENT_MAP["BALLROOM"] = "ballroom";
    ENVIRONMENT_MAP["CANNON_EXTERIOR"] = "cannon_exterior";
    ENVIRONMENT_MAP["CAPE_HILL"] = "cape_hill";
    ENVIRONMENT_MAP["CHRISTMAS_PHOTO_STUDIO"] = "christmas_photo_studio";
    ENVIRONMENT_MAP["CIRCUS_MAXIMUS"] = "circus_maximus";
    ENVIRONMENT_MAP["COLORFUL_STUDIO"] = "colorful_studio";
    ENVIRONMENT_MAP["COMBINATION_ROOM"] = "combination_room";
    ENVIRONMENT_MAP["GREEN_POINT_PARK"] = "green_point_park";
    ENVIRONMENT_MAP["HILLTOP_CONSTRUCTION"] = "hilltop_construction";
    ENVIRONMENT_MAP["LARGE_CORRIDOR"] = "large_corridor";
    ENVIRONMENT_MAP["LYTHWOOD_LOUNGE"] = "lythwood_lounge";
    ENVIRONMENT_MAP["NEUTRAL"] = "neutral";
    ENVIRONMENT_MAP["OBERER_KUHBERG"] = "oberer_kuhberg";
    ENVIRONMENT_MAP["OLD_HALL"] = "old_hall";
    ENVIRONMENT_MAP["PAUL_LOBE_HAUS"] = "paul_lobe_haus";
    ENVIRONMENT_MAP["PHOTO_STUDIO"] = "photo_studio";
    ENVIRONMENT_MAP["PHOTO_STUDIO_BROADWAY_HALL"] = "photo_studio_broadway_hall";
    ENVIRONMENT_MAP["SNOWY_FIELD"] = "snowy_field";
    ENVIRONMENT_MAP["STUDIO_SMALL"] = "studio_small";
    ENVIRONMENT_MAP["SUNFLOWERS"] = "sunflowers";
    ENVIRONMENT_MAP["TABLE_MOUNTAIN"] = "table_mountain";
    ENVIRONMENT_MAP["VENICE_SUNSET"] = "venice_sunset";
    ENVIRONMENT_MAP["WIDE_STREET"] = "wide_street";
})(ENVIRONMENT_MAP = exports.ENVIRONMENT_MAP || (exports.ENVIRONMENT_MAP = {}));
var ENVIRONMENT_MAP_TYPE;
(function (ENVIRONMENT_MAP_TYPE) {
    ENVIRONMENT_MAP_TYPE["LDR"] = "ldr";
    ENVIRONMENT_MAP_TYPE["HDR"] = "hdr";
    ENVIRONMENT_MAP_TYPE["NONE"] = "none";
})(ENVIRONMENT_MAP_TYPE = exports.ENVIRONMENT_MAP_TYPE || (exports.ENVIRONMENT_MAP_TYPE = {}));
class EnvironmentMapLoader {
    // #endregion Properties (8)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (8)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._environmentMapFilenames = ['px', 'nx', 'pz', 'nz', 'py', 'ny'];
        this._environmentMapHDR = [];
        this._environmentMapNamesHDR = Object.values(ENVIRONMENT_MAP).filter(value => typeof value === 'string');
        this._environmentMapNamesHDRKhronos = ['cannon_exterior', 'colorful_studio', 'neutral', 'wide_street'];
        this._environmentMapNamesJPG = ['default', 'default_bw', 'blurred_lights', 'georgentor', 'georgentor_blur', 'georgentor_blue_blur', 'georgentor_bw_blur', 'levelsets', 'lythwood_field', 'mountains', 'ocean', 'piazza_san_marco', 'residential_garden', 'room_abstract_1', 'sky', 'storage_room', 'storm', 'subway_entrance', 'subway_entrance_bw_blur', 'white', 'yokohama'];
        this._environmentMaps = {};
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._environmentMapName = 'none';
        this._environmentMapNameInternal = 'none';
        this._isHDRMap = false;
        this._textureEncoding = THREE.sRGBEncoding;
        this._type = ENVIRONMENT_MAP_TYPE.NONE;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (1)
    get environmentMap() {
        return this._environmentMaps[this._environmentMapName];
    }
    get isHDRMap() {
        return this._isHDRMap;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (2)
    init() {
        this._environmentMaps['none'] = null;
        this._pmremGenerator = new THREE.PMREMGenerator(this._renderingEngine.renderer);
        this._pmremGenerator.compileEquirectangularShader();
    }
    notify(eventId, failed = false) {
        let event;
        if (failed) {
            event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, progress: 1, status: `Loading of EnvironmentMap failed` };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, event);
        }
        else {
            event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, progress: 1, status: `Loaded EnvironmentMap` };
            this._stateEngine.renderingEngines[this._renderingEngine.id].environmentMapLoaded.resolve(true);
            this._stateEngine.renderingEngines[this._renderingEngine.id].environmentMapLoaded = new viewer_shared_services_1.StatePromise();
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, event);
        }
    }
    loadEnvMap(name, eId) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = eId || this._uuidGenerator.create();
            const event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, data: { input: name }, progress: 0, status: `Loading EnvironmentMap` };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, event);
            const name_original = name;
            if (name === 'none') {
                this._environmentMapNameInternal = name;
                return {
                    name: name,
                    map: this._environmentMaps[name],
                    type: ENVIRONMENT_MAP_TYPE.NONE
                };
            }
            ;
            let name_internal, name_caching, url;
            // check if name is a JSON.stringified version of an array of urls
            if (!Array.isArray(name) && (name.startsWith('["https') && name.endsWith('"]')))
                try {
                    name = JSON.parse(name);
                }
                catch (e) {
                    this.notify(eventId, true);
                    const error = new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map.', name);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `EnvironmentMapLoader.load`, error);
                }
            // deal with string or array, define names for loading and caching
            if (!Array.isArray(name)) {
                name_internal = name.toLowerCase().replace(/ /g, '_');
                name_caching = name_internal + this._renderingEngine.environmentMapResolution;
            }
            else {
                if (name.length !== 6) {
                    this.notify(eventId, true);
                    const error = new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map, exactly 6 files are needed in the array.', name);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `EnvironmentMapLoader.load`, error);
                }
                name_internal = JSON.stringify(name, null, 0);
                name_caching = name_internal;
            }
            this._environmentMapNameInternal = name_internal;
            // check if environment map is already cached
            for (let environmentMap in this._environmentMaps)
                if (environmentMap === name_caching) {
                    return {
                        name: environmentMap,
                        map: this._environmentMaps[environmentMap],
                        type: this._environmentMaps[environmentMap] instanceof THREE.CubeTexture ? ENVIRONMENT_MAP_TYPE.LDR : ENVIRONMENT_MAP_TYPE.HDR
                    };
                }
            try {
                // define urls for 6 cube images ourselves
                if (!Array.isArray(name)) {
                    url = [];
                    let i;
                    if (this._environmentMapNamesHDR.indexOf(name_internal) >= 0) {
                        let url_hdr = 'https://viewer.shapediver.com/v3/envmaps/1k/' + name_internal + '_1k.hdr';
                        if (this._environmentMapNamesHDRKhronos.indexOf(name_internal) >= 0)
                            url_hdr = 'https://viewer.shapediver.com/v3/envmaps/khronos/' + name_internal + '.hdr';
                        this._environmentMapHDR.push(url_hdr);
                        yield this.loadEnvironmentMap(url_hdr, [], eventId);
                        return {
                            name: url_hdr,
                            map: this._environmentMaps[url_hdr],
                            type: this._environmentMaps[url_hdr] instanceof THREE.CubeTexture ? ENVIRONMENT_MAP_TYPE.LDR : ENVIRONMENT_MAP_TYPE.HDR
                        };
                    }
                    else if (this._environmentMapNamesJPG.indexOf(name_internal) >= 0) {
                        // found in list of available environment maps with file type jpg
                        for (i = 0; i < this._environmentMapFilenames.length; i++)
                            url.push('https://viewer.shapediver.com/v2/envmaps/' + this._renderingEngine.environmentMapResolution + '/' + name_internal + '/' + this._environmentMapFilenames[i] + '.jpg');
                    }
                    else if (name.startsWith('https://') || name.startsWith('http://')) {
                        if (name.endsWith('.hdr')) {
                            this._environmentMapHDR.push(name);
                            yield this.loadEnvironmentMap(name, [], eventId);
                            return {
                                name: name,
                                map: this._environmentMaps[name],
                                type: this._environmentMaps[name] instanceof THREE.CubeTexture ? ENVIRONMENT_MAP_TYPE.LDR : ENVIRONMENT_MAP_TYPE.HDR
                            };
                        }
                        else {
                            if (!name.endsWith('/'))
                                name += '/';
                            for (i = 0; i < this._environmentMapFilenames.length; i++)
                                url.push(name + this._environmentMapFilenames[i] + '.jpg');
                        }
                    }
                    else {
                        this.notify(eventId, true);
                        const error = new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map, format not supported.', name);
                        throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `EnvironmentMapLoader.load`, error);
                    }
                }
                else {
                    url = name;
                }
                yield this.loadEnvironmentMap(name_caching, url, eventId);
                return {
                    name: name_caching,
                    map: this._environmentMaps[name_caching],
                    type: this._environmentMaps[name_caching] instanceof THREE.CubeTexture ? ENVIRONMENT_MAP_TYPE.LDR : ENVIRONMENT_MAP_TYPE.HDR
                };
            }
            catch (e) {
                this.notify(eventId, true);
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `EnvironmentMapLoader.load`, e);
            }
        });
    }
    load(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const res = yield this.loadEnvMap(name, eventId);
            this.assignEnvironmentMap(res.name, res.type, eventId);
            return Promise.resolve(true);
        });
    }
    getEnvironmentMapImageUrl(name) {
        if (Array.isArray(name))
            return '';
        if (this._environmentMapNamesHDR.indexOf(name) >= 0) {
            let url_hdr = 'https://viewer.shapediver.com/v3/envmaps/1k/' + name + '_1k.hdr';
            if (this._environmentMapNamesHDRKhronos.indexOf(name) >= 0)
                url_hdr = 'https://viewer.shapediver.com/v3/envmaps/khronos/' + name + '.hdr';
            return url_hdr;
        }
        else if (name.startsWith('https://') || name.startsWith('http://')) {
            if (name.endsWith('.hdr') || name.endsWith('.jpg') || name.endsWith('.png')) {
                return name;
            }
        }
        return '';
    }
    // #endregion Public Methods (2)
    // #region Private Methods (2)
    assignEnvironmentMap(name, type, eventId) {
        if (name in this._environmentMaps === false)
            return;
        this._type = type;
        this._environmentMapName = name;
        this._renderingEngine.materialLoader.assignEnvironmentMap(this._environmentMaps[name], type);
        this.notify(eventId);
    }
    assignTextureEncoding() {
        var _a;
        for (let e in this._environmentMaps) {
            if (this._environmentMaps[e] && !this._environmentMapHDR.includes(e)) {
                (_a = this._environmentMaps[e]) === null || _a === void 0 ? void 0 : _a.dispose();
                this._environmentMaps[e].encoding = this._textureEncoding;
                this._environmentMaps[e].needsUpdate = true;
            }
        }
    }
    loadEnvironmentMap(name, url, eventId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (name.endsWith('.hdr')) {
                    const response = yield this._httpClient.loadTexture(name);
                    const arrayBufferView = new Uint8Array(response.data);
                    const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });
                    new RGBELoader_1.RGBELoader().load(URL.createObjectURL(blob), (texture) => {
                        const map = this._pmremGenerator.fromEquirectangular(texture).texture;
                        this._pmremGenerator.dispose();
                        this._environmentMaps[name] = map;
                        resolve();
                    }, () => { }, (error) => reject(error));
                }
                else {
                    const promises = [];
                    url.forEach(u => promises.push(this._httpClient.loadTexture(u)));
                    const responses = yield Promise.all(promises);
                    const urls = responses.map(response => {
                        const arrayBufferView = new Uint8Array(response.data);
                        const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });
                        return URL.createObjectURL(blob);
                    });
                    new THREE.CubeTextureLoader().load(urls, (map) => {
                        map.encoding = THREE.sRGBEncoding;
                        map.format = THREE.RGBAFormat;
                        map.mapping = THREE.CubeReflectionMapping;
                        this._environmentMaps[name] = map;
                        resolve();
                    }, () => { }, (error) => reject(error));
                }
            }));
        });
    }
    get textureEncoding() {
        return this._textureEncoding;
    }
    set textureEncoding(value) {
        this._textureEncoding = value;
        this.assignTextureEncoding();
    }
}
exports.EnvironmentMapLoader = EnvironmentMapLoader;
//# sourceMappingURL=EnvironmentMapLoader.js.map