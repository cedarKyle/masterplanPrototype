"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTreeManager = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const gl_matrix_1 = require("gl-matrix");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const ThreejsData_1 = require("../types/ThreejsData");
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const SDData_1 = require("../objects/SDData");
const SDObject_1 = require("../objects/SDObject");
const SDBone_1 = require("../objects/SDBone");
class SceneTreeManager {
    // #endregion Properties (10)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (10)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._inputValidator = tsyringe_1.container.resolve(viewer_shared_services_1.InputValidator);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._scene = new THREE.Scene();
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._boundingBox = new viewer_shared_math_1.Box();
        this._boundingBoxSensitiveData = [];
        this._scene.background = new THREE.Color('#ffffff');
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get boundingBox() {
        return this._boundingBox;
    }
    get scene() {
        return this._scene;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (6)
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 && this._boundingBox.min[1] === 0 && this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 && this._boundingBox.max[1] === 0 && this._boundingBox.max[2] === 0) || this._boundingBox.isEmpty());
    }
    getBone(node) {
        let bone;
        this._mainNode.traverse((o) => {
            if (o.SDid === node.id)
                bone = o;
        });
        return bone;
    }
    /**
     * Convert the data of the scene graph node into the format of the implementation.
     *
     * @param data the data element
     * @param obj the corresponding type node
     */
    updateData(node, obj, data) {
        let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
        if (!dataChild)
            dataChild = new SDData_1.SDData(data.id, data.version);
        obj.add(dataChild);
        if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES)
            this.injectAttributeData(node, data);
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.GEOMETRY;
                const geometryData = data;
                let skeleton;
                if (geometryData.skinNode) {
                    const bones = [];
                    for (let i = 0; i < geometryData.skinNode.bones.length; i++)
                        bones.push(this.getBone(geometryData.skinNode.bones[i]));
                    const boneInverses = [];
                    for (let i = 0; i < geometryData.skinNode.boneInverses.length; i++)
                        boneInverses.push(new THREE.Matrix4().fromArray(geometryData.skinNode.boneInverses[i]));
                    skeleton = new THREE.Skeleton(bones, boneInverses);
                }
                const bb = this._renderingEngine.geometryLoader.load(data, dataChild, skeleton);
                // adjust the general BB
                node.boundingBox.union(bb);
                // create the specific BB if it doesn't exist yet
                if (!node.boundingBoxViewport[this._renderingEngine.id])
                    node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                // adjust the specific BB
                node.boundingBoxViewport[this._renderingEngine.id].union(bb);
                break;
            case data instanceof ThreejsData_1.ThreejsData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.THREEJS;
                dataChild.add(data.obj);
                const bbThree = new THREE.Box3().setFromObject(data.obj);
                // adjust the general BB
                node.boundingBox.union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                // create the specific BB if it doesn't exist yet
                if (!node.boundingBoxViewport[this._renderingEngine.id])
                    node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                // adjust the specific BB
                node.boundingBoxViewport[this._renderingEngine.id].union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                break;
            case data instanceof viewer_shared_types_1.AbstractMaterialData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.MATERIAL;
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.LIGHT;
                this._renderingEngine.lightLoader.load(data, dataChild);
                if (data instanceof viewer_rendering_engine_light_engine_1.DirectionalLight && data.useNodeData === false)
                    this._boundingBoxSensitiveData.push({ data: data, dataChild });
                break;
            case data instanceof viewer_rendering_engine_camera_engine_1.AbstractCamera:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.CAMERA;
                this._renderingEngine.cameraManager.load(data, dataChild);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR;
                this._renderingEngine.htmlElementAnchorLoader.load(node, data);
                break;
            case data instanceof viewer_shared_types_1.AnimationData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.ANIMATION;
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
    updateNodeTransformations(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        obj.visible = node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id));
        obj.applyTransformation(node.nodeMatrix);
        // add new children and update the ones that have a different version
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (objChild)
                this.updateNodeTransformations(nodeChild, objChild);
        }
    }
    updateMorphWeights(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        for (let i = 0, len = node.data.length; i < len; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                const data = node.data[i];
                let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
                if (dataChild)
                    dataChild.traverse(o => {
                        if (o instanceof THREE.Points ||
                            o instanceof THREE.LineSegments ||
                            o instanceof THREE.LineLoop ||
                            o instanceof THREE.Line ||
                            o instanceof THREE.Mesh)
                            o.morphTargetInfluences = data.morphWeights;
                    });
            }
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (objChild)
                this.updateMorphWeights(nodeChild, objChild);
        }
    }
    /**
     * Update the current node via the scene graph node.
     * Convert the data if needed.
     *
     * @param node the scene graph node
     * @param obj the current type object
     */
    updateNode(node, obj) {
        const convertedObject = obj;
        // reset the general bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBox.reset();
        // create the specific BB if it doesn't exist yet
        if (!node.boundingBoxViewport[this._renderingEngine.id])
            node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
        // reset the specific bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBoxViewport[this._renderingEngine.id].reset();
        // remove all data items that do not exist anymore
        const dataIds = node.data.map(d => d.id);
        const dataToRemove = convertedObject.children.filter(oc => oc instanceof SDData_1.SDData ? !(dataIds.includes(oc.SDid)) : false);
        dataToRemove.forEach(dTR => {
            this.removeData(dTR);
            convertedObject.remove(dTR);
        });
        // remove all child nodes in the transformed object that do not exist anymore
        // the filter goes also through the data items as they were already added
        const nodeIds = node.children.filter(d => !d.excludeViewports.includes(this._renderingEngine.id)).map(d => d.id);
        const childrenToRemove = convertedObject.children.filter(oc => oc instanceof SDObject_1.SDObject ? !nodeIds.includes(oc.SDid) : false);
        childrenToRemove.forEach(cTR => {
            cTR.traverse((o) => {
                if (o instanceof SDData_1.SDData)
                    this.removeData(o);
            });
            convertedObject.remove(cTR);
        });
        // convert all data items of the current node
        // old versions will be replaced by new ones
        for (let i = 0, len = node.data.length; i < len; i++)
            this.updateData(node, convertedObject, node.data[i]);
        // add new children and update the ones that have a different version
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            const objChild = convertedObject.children.find(oc => oc.SDid === nodeChild.id);
            if (!objChild) {
                const newChild = node.data.find(d => d instanceof viewer_shared_types_1.BoneData) ? new SDBone_1.SDBone(nodeChild.id, nodeChild.version) : new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                const oldChild = nodeChild.threeJsObject[this._renderingEngine.id];
                nodeChild.threeJsObject[this._renderingEngine.id] = newChild;
                if (nodeChild.updateCallbackThreeJsObject)
                    nodeChild.updateCallbackThreeJsObject(newChild, oldChild, this._renderingEngine.id);
                convertedObject.add(newChild);
                this.updateNode(nodeChild, newChild);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                // if the version is different, update the child
                this.updateNode(nodeChild, objChild);
                objChild.SDversion = nodeChild.version;
            }
            else {
                this.updateNode(nodeChild, objChild);
            }
            // adjust the general BB
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
            // adjust the specific BB
            if (nodeChild.boundingBoxViewport[this._renderingEngine.id] && !nodeChild.boundingBoxViewport[this._renderingEngine.id].isEmpty()) {
                // only do this if the node is
                // 1. visible
                // 2. no included in the "excludeViewports"
                // 3. if there are "restrictViewports", it needs to be in them
                if (node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id))) {
                    node.boundingBoxViewport[this._renderingEngine.id].union(nodeChild.boundingBoxViewport[this._renderingEngine.id]);
                }
            }
        }
        convertedObject.visible = node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id));
        convertedObject.applyTransformation(node.nodeMatrix);
        // apply matrix to general BB
        if (!node.boundingBox.isEmpty())
            node.boundingBox.applyMatrix(node.nodeMatrix);
        // apply matrix to specific BB
        if (!node.boundingBoxViewport[this._renderingEngine.id].isEmpty())
            node.boundingBoxViewport[this._renderingEngine.id].applyMatrix(node.nodeMatrix);
    }
    updateSceneTree(root, lightEngine) {
        if (this._renderingEngine.closed)
            return;
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            const oldObj = root.threeJsObject[this._renderingEngine.id];
            root.threeJsObject[this._renderingEngine.id] = this._mainNode;
            if (root.updateCallbackThreeJsObject)
                root.updateCallbackThreeJsObject(this._mainNode, oldObj, this._renderingEngine.id);
            this._scene.add(this._mainNode);
        }
        this._boundingBoxSensitiveData = [];
        this._currentSDTFOverview = this.createSDTFOverview();
        this.updateNode(root, this._mainNode);
        this._boundingBox = root.boundingBoxViewport[this._renderingEngine.id].clone();
        for (let i = 0; i < this._boundingBoxSensitiveData.length; i++)
            this._renderingEngine.lightLoader.adjustToBoundingBox(this._boundingBoxSensitiveData[i].data, this._boundingBoxSensitiveData[i].dataChild, this._boundingBox);
        if (!this._boundingBox.isEmpty())
            this._boundingBox.applyMatrix(root.nodeMatrix);
        if (!(this._boundingBox.min[0] === oldBB.min[0] && this._boundingBox.min[1] === oldBB.min[1] && this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] && this._boundingBox.max[1] === oldBB.max[1] && this._boundingBox.max[2] === oldBB.max[2])) {
            if (!this._stateEngine.renderingEngines[this._renderingEngine.id].boundingBoxCreated.resolved && !this._boundingBox.isEmpty())
                this._stateEngine.renderingEngines[this._renderingEngine.id].boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, {
                viewportId: this._renderingEngine.id, boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                }
            });
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount + this._renderingEngine.materialLoader.maxMapCount);
    }
    // #endregion Public Methods (6)
    // #region Private Methods (4)
    collectSDTFItemData(node) {
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFItemData)
                return node.data[i];
        if (!node.parent)
            return;
        return this.collectSDTFItemData(node.parent);
    }
    createSDTFOverview(node = this._tree.root) {
        const out = new viewer_shared_types_1.SDTFOverviewData({});
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFOverviewData)
                out.merge(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out.merge(new viewer_shared_types_1.SDTFOverviewData(this.createSDTFOverview(node.children[i])));
        return out.overview;
    }
    injectAttributeData(node, data) {
        const itemData = this.collectSDTFItemData(node);
        let visData = {
            material: new viewer_shared_types_1.MaterialStandardData({ color: '#00fff7', opacity: 1 }),
            matrix: gl_matrix_1.mat4.create()
        };
        if (this._renderingEngine.visualizeAttributes) {
            const userVisData = this._renderingEngine.visualizeAttributes(this._currentSDTFOverview, itemData);
            try {
                this._inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `Viewer.visualizeAttributes`, userVisData, 'object', true);
                this._inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `Viewer.visualizeAttributes`, userVisData.matrix, 'mat4', true);
                visData.material = userVisData.material;
                visData.matrix = visData.matrix;
            }
            catch (e) {
                if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof viewer_shared_services_1.ShapeDiverBackendError)
                    throw e;
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `Viewer.visualizeAttributes: Encountered an error while parsing the visualization data.`, e);
            }
        }
        node.addTransformation({
            id: 'sdtf',
            matrix: visData.matrix
        });
        if (data instanceof viewer_shared_types_1.GeometryData)
            data.primitive.attributeMaterial = visData.material;
    }
    removeData(dataObject) {
        switch (true) {
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.GEOMETRY:
                dataObject.traverse((o) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                    if (o instanceof SDData_1.SDData) {
                        if (o instanceof THREE.Mesh) {
                            this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid + '_' + o.geometry.userData.SDversion);
                            this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid + '_' + o.material.userData.SDversion);
                            for (const key in o.geometry.attributes)
                                o.geometry.deleteAttribute(key);
                            o.geometry.setIndex(null);
                            o.geometry.dispose();
                            if (o.material.alphaMap)
                                (_a = o.material.alphaMap) === null || _a === void 0 ? void 0 : _a.dispose();
                            if (o.material.aoMap)
                                (_b = o.material.aoMap) === null || _b === void 0 ? void 0 : _b.dispose();
                            if (o.material.bumpMap)
                                (_c = o.material.bumpMap) === null || _c === void 0 ? void 0 : _c.dispose();
                            if (o.material.map)
                                (_d = o.material.map) === null || _d === void 0 ? void 0 : _d.dispose();
                            if (o.material.emissiveMap)
                                (_e = o.material.emissiveMap) === null || _e === void 0 ? void 0 : _e.dispose();
                            if (o.material.metalnessMap)
                                (_f = o.material.metalnessMap) === null || _f === void 0 ? void 0 : _f.dispose();
                            if (o.material.roughnessMap)
                                (_g = o.material.roughnessMap) === null || _g === void 0 ? void 0 : _g.dispose();
                            if (o.material.normalMap)
                                (_h = o.material.normalMap) === null || _h === void 0 ? void 0 : _h.dispose();
                            if (o.material.specularMap)
                                (_j = o.material.specularMap) === null || _j === void 0 ? void 0 : _j.dispose();
                            if (o.material.glossinessMap)
                                (_k = o.material.glossinessMap) === null || _k === void 0 ? void 0 : _k.dispose();
                            o.material.dispose();
                        }
                    }
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.THREEJS:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.MATERIAL:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.LIGHT:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR:
                this._renderingEngine.htmlElementAnchorLoader.removeData(dataObject.SDid, dataObject.SDversion);
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.ANIMATION:
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
}
exports.SceneTreeManager = SceneTreeManager;
//# sourceMappingURL=SceneTreeManager.js.map