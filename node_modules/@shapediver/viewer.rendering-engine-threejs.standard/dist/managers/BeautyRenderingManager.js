"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeautyRenderingManager = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const EffectComposer_1 = require("../three/postprocessing/EffectComposer");
const RenderPass_1 = require("../three/postprocessing/RenderPass");
const SSAARenderPass_1 = require("../three/postprocessing/SSAARenderPass");
const ShaderPass_1 = require("../three/postprocessing/ShaderPass");
const GammaCorrectionShader_1 = require("../three/shaders/GammaCorrectionShader");
const SAOPass_1 = require("../three/postprocessing/SAOPass");
class BeautyRenderingManager {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (12)
        this._systemInfo = tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo);
        this._beautyRenderingActive = false;
        this._beautyRenderingDurationActive = 0;
        this._beautyRenderingTimeout = null;
        this._lastTime = 0;
        this._lightSizeUVEnd = 0.15;
        this._lightSizeUVStart = 0.025;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (6)
    get beautyRenderingActive() {
        return this._beautyRenderingActive;
    }
    set beautyRenderingActive(value) {
        this._beautyRenderingActive = value;
    }
    get beautyRenderingDurationActive() {
        return this._beautyRenderingDurationActive;
    }
    set beautyRenderingDurationActive(value) {
        this._beautyRenderingDurationActive = value;
    }
    get beautyRenderingTimeout() {
        return this._beautyRenderingTimeout;
    }
    set beautyRenderingTimeout(value) {
        this._beautyRenderingTimeout = value;
    }
    // #endregion Public Accessors (6)
    // #region Public Methods (7)
    activateBeautyRenderShaders() {
        this._renderingEngine.renderer.shadowMap.type = THREE.PCFShadowMap;
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        this._renderingEngine.materialLoader.updateMaterials();
    }
    assignOutputEncoding(encoding) {
        if (encoding === 3001) {
            if (!this._effectComposer.passes.includes(this._gammaCorrectionPass))
                this._effectComposer.addPass(this._gammaCorrectionPass);
        }
        else {
            if (this._effectComposer.passes.includes(this._gammaCorrectionPass))
                this._effectComposer.removePass(this._gammaCorrectionPass);
        }
    }
    deactivateBeautyRenderShaders() {
        this._beautyRenderingTimeout = null;
        this._beautyRenderingActive = false;
        this._beautyRenderingDurationActive = 0;
        this._renderingEngine.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart, 0.1);
        this._renderingEngine.materialLoader.updateMaterials();
    }
    init() {
        const tempCamera = new THREE.PerspectiveCamera();
        var size = this._renderingEngine.renderer.getSize(new THREE.Vector2());
        const renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: false,
            type: THREE.FloatType
        });
        renderTarget.texture.name = 'EffectComposer.rt1';
        this._effectComposer = new EffectComposer_1.EffectComposer(this._renderingEngine.renderer, renderTarget);
        this._renderPass = new RenderPass_1.RenderPass(this._renderingEngine.scene, tempCamera);
        //this._effectComposer.addPass(this._renderPass);
        this._ssaaPass = new SSAARenderPass_1.SSAARenderPass(this._renderingEngine.scene, tempCamera, this._renderingEngine.renderer.getClearColor(new THREE.Color()), this._renderingEngine.renderer.getClearAlpha());
        this._ssaaPass.sampleLevel = 2;
        this._effectComposer.addPass(this._ssaaPass);
        this._saoPass = new SAOPass_1.SAOPass(this._renderingEngine.scene, tempCamera, true, true);
        const saoRenderFunction = this._saoPass.render.bind(this._saoPass);
        this._saoPass.render = (renderer, writeBuffer, readBuffer, deltaTime, maskActive) => {
            const materialsNotRenderer = [];
            this._renderingEngine.scene.traverse(function (object) {
                if (object.visible === true) {
                    if (object instanceof THREE.Mesh && object.material) {
                        if (object.material instanceof THREE.MeshPhysicalMaterial && object.material.transparent) {
                            materialsNotRenderer.push(object);
                            object.visible = false;
                        }
                    }
                    if (object instanceof THREE.Line || object instanceof THREE.LineLoop || object instanceof THREE.LineSegments) {
                        materialsNotRenderer.push(object);
                        object.visible = false;
                    }
                    if (object.userData.ambientOcclusion === false) {
                        materialsNotRenderer.push(object);
                        object.visible = false;
                    }
                }
            });
            saoRenderFunction(renderer, writeBuffer, readBuffer, deltaTime, maskActive);
            for (let i = 0; i < materialsNotRenderer.length; i++)
                materialsNotRenderer[i].visible = true;
        };
        this._effectComposer.addPass(this._saoPass);
        this._saoPass.params.output = 0;
        this._saoPass.params.saoBias = 0.5;
        this._saoPass.params.saoIntensity = this._renderingEngine.ambientOcclusionIntensity * 0.01;
        this._saoPass.params.saoScale = 1;
        this._saoPass.params.saoKernelRadius = 100;
        this._saoPass.params.saoMinResolution = 0;
        this._saoPass.params.saoBlur = true;
        this._saoPass.params.saoBlurRadius = 8;
        this._saoPass.params.saoBlurStdDev = 4;
        this._saoPass.params.saoBlurDepthCutoff = 0.001;
        this._gammaCorrectionPass = new ShaderPass_1.ShaderPass(GammaCorrectionShader_1.GammaCorrectionShader);
        this._effectComposer.addPass(this._gammaCorrectionPass);
        this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVEnd, 1.0);
        this._renderingEngine.renderer.shadowMap.type = THREE.PCFShadowMap;
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        this._renderingEngine.materialLoader.updateMaterials();
    }
    render(time, camera, width, height) {
        const percentage = this.setShaderProperties();
        if (((this._renderingEngine.ambientOcclusion && this._renderingEngine.ambientOcclusionIntensity > 0.0) && !((this._systemInfo.isMacOS && this._systemInfo.isChrome) || this._systemInfo.isIOS || this._systemInfo.isMobile || this._systemInfo.isSafari))) {
            this._ssaaPass.clearColor = this._renderingEngine.renderer.getClearColor(new THREE.Color());
            this._ssaaPass.clearAlpha = this._renderingEngine.renderer.getClearAlpha();
            this._saoPass.params.saoIntensity = this._renderingEngine.ambientOcclusionIntensity;
            const saoIntensity = this._saoPass.params.saoIntensity * 0.0025;
            this._saoPass.params.saoIntensity = percentage * saoIntensity;
            // if passes changed, adapt https://shapediver.atlassian.net/browse/SS-2954
            this._renderPass.camera = camera;
            this._saoPass.camera = camera;
            this._ssaaPass.camera = camera;
            this._gammaCorrectionPass.setSize(width, height);
            this._saoPass.setSize(width, height);
            this._ssaaPass.setSize(width, height);
            this._effectComposer.setSize(width, height);
            this._effectComposer.render(time);
            this._saoPass.params.saoIntensity = saoIntensity;
        }
        else {
            this._renderingEngine.renderer.render(this._renderingEngine.scene, camera);
        }
    }
    startBeautyRenderCountdown() {
        this._beautyRenderingTimeout = setTimeout(() => {
            this._beautyRenderingActive = true;
            this._beautyRenderingDurationActive = 0;
            this.activateBeautyRenderShaders();
        }, this._renderingEngine.beautyRenderDelay);
    }
    stopBeautyRenderCountdown() {
        if (this.beautyRenderingTimeout)
            clearTimeout(this.beautyRenderingTimeout);
        this.deactivateBeautyRenderShaders();
    }
    // #endregion Public Methods (7)
    // #region Private Methods (1)
    setShaderProperties() {
        const deltaTime = Math.min(this._beautyRenderingDurationActive, this._renderingEngine.beautyRenderBlendingDuration);
        const percentage = deltaTime / this._renderingEngine.beautyRenderBlendingDuration;
        if (percentage < 0.25) {
            const percentageMapped = percentage / 0.25;
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart, percentageMapped);
        }
        else {
            const percentageMapped = (percentage - 0.25) / (1 - 0.25);
            // this._lightSizeUVStart -> this._lightSizeUVEnd
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart + (this._lightSizeUVEnd - this._lightSizeUVStart) * percentageMapped, 1.0);
        }
        return percentage;
    }
}
exports.BeautyRenderingManager = BeautyRenderingManager;
//# sourceMappingURL=BeautyRenderingManager.js.map