"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTracingManager = void 0;
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
class SceneTracingManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (2)
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    convert3Dto2D(p) {
        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(), width = this._renderingEngine.canvas.width, height = this._renderingEngine.canvas.height;
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'SceneTracingManager.convert3Dto2D', error);
        }
        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, camera.position));
        const tracing = this.trace(camera.position, direction);
        const pos = camera.project(gl_matrix_1.vec3.clone(p));
        pos[0] = (pos[0] * (width / 2)) + (width / 2);
        pos[1] = -(pos[1] * (height / 2)) + (height / 2);
        // take care of correction by device pixel ratio
        pos[0] = pos[0] / devicePixelRatio;
        pos[1] = pos[1] / devicePixelRatio;
        return {
            hidden: tracing.length > 1 && tracing[0].distance > 0 && tracing[0].distance < Infinity && tracing[0].distance < gl_matrix_1.vec3.distance(camera.position, p),
            container: gl_matrix_1.vec2.clone(pos),
            client: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),
            page: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset)
        };
    }
    init() { }
    trace(origin, direction, root = this._tree.root) {
        const tracingData = [];
        const trace = (node) => {
            if (node.excludeViewports.includes(this._renderingEngine.id))
                return;
            if (node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id))
                return;
            for (let i = 0; i < node.data.length; i++)
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const dist = node.data[i].intersect(origin, direction);
                    if (dist)
                        tracingData.push({ distance: dist, node, data: node.data[i] });
                }
            for (let i = 0; i < node.children.length; i++)
                trace(node.children[i]);
        };
        trace(root);
        tracingData.sort((a, b) => {
            return a.distance - b.distance;
        });
        return tracingData;
    }
    /**
     * Calculate the ray that is created by the mouse event and the camera.
     *
     * @param event
     * @returns
     */
    mouseEventToRay(event) {
        const rect = this._renderingEngine.canvas.getBoundingClientRect();
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.mouseEventToRay: No camera is defined for this viewer.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `SceneTracingManager.mouseEventToRay`, error);
        }
        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        let _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        let origin = gl_matrix_1.vec3.clone(camera.position);
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));
            }
        }
        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));
        return { origin, direction };
    }
    /**
     * Create the ray that is created by the touch event and the camera.
     *
     * @param event
     * @returns
     */
    touchEventToRay(event) {
        if (event.touches.length > 1) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No touches in this event.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `SceneTracingManager.touchEventToRay`, error);
        }
        const touch = event.changedTouches[0];
        const rect = this._renderingEngine.canvas.getBoundingClientRect();
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No camera is defined for this viewer.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `SceneTracingManager.touchEventToRay`, error);
        }
        let _mouse_x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        let _mouse_y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        let origin = gl_matrix_1.vec3.clone(camera.position);
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));
            }
        }
        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));
        return { origin, direction };
    }
    /**
     * Create the ray that is created by the touch event and the camera.
     *
     * @param event
     * @returns
     */
    touchToRay(event) {
        const rect = this._renderingEngine.canvas.getBoundingClientRect();
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchToRay: No camera is defined for this viewer.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `SceneTracingManager.touchToRay`, error);
        }
        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        let _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        let origin = gl_matrix_1.vec3.clone(camera.position);
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));
            }
        }
        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));
        return { origin, direction };
    }
}
exports.SceneTracingManager = SceneTracingManager;
//# sourceMappingURL=SceneTracingManager.js.map