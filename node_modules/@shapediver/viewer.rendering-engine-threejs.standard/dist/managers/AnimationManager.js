"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationManager = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
class AnimationManager {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (12)
        this._systemInfo = tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo);
    }
    // #endregion Constructors (1)
    init() { }
    update(deltaTime) {
        const animations = Object.values(this._renderingEngine.animations);
        let running = false;
        for (let i = 0; i < animations.length; i++) {
            const animation = animations[i];
            if (animation.animationTime === -1) {
                // if we just stopped we need to render one more time
                running = true;
                animation.animationTime = 0;
            }
            if (!animation.animate)
                continue;
            running = true;
            animation.animationTime += deltaTime;
            if (animation.animationTime / 1000.0 > animation.duration) {
                if (animation.repeat) {
                    animation.startAnimation();
                }
                else {
                    animation.stopAnimation();
                }
            }
            const animationDuration = animation.duration;
            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;
            for (let j = 0; j < animation.tracks.length; j++) {
                const track = animation.tracks[j];
                const id = animation.id + '_' + j;
                if (currentAnimationDeltaTime < track.times[0] || currentAnimationDeltaTime > track.times[track.times.length - 1])
                    continue;
                for (let k = 1; k < track.times.length; k++) {
                    if (currentAnimationDeltaTime < track.times[k] && currentAnimationDeltaTime > track.times[k - 1]) {
                        const prevAnimation = track.node.transformations.filter(t => t.id === id);
                        track.node.transformations = track.node.transformations.filter((el) => {
                            return !prevAnimation.includes(el);
                        });
                        const factor = (currentAnimationDeltaTime - track.times[k - 1]) / (track.times[k] - track.times[k - 1]);
                        let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                        if (!translationTransformation) {
                            translationTransformation = {
                                id: 'gltf_matrix_translation',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(translationTransformation);
                        }
                        let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                        if (!rotationTransformation) {
                            rotationTransformation = {
                                id: 'gltf_matrix_rotation',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(rotationTransformation);
                        }
                        let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                        if (!scaleTransformation) {
                            scaleTransformation = {
                                id: 'gltf_matrix_scale',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(scaleTransformation);
                        }
                        if (track.path === 'rotation') {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let quaternion;
                            if (track.interpolation === 'step') {
                                quaternion = gl_matrix_1.quat.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]);
                            }
                            else {
                                quaternion = gl_matrix_1.quat.slerp(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]), gl_matrix_1.vec4.fromValues(track.values[(k) * 4 + 0], track.values[(k) * 4 + 1], track.values[(k) * 4 + 2], track.values[(k) * 4 + 3]), factor);
                            }
                            const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);
                            if (pivotMatrix && pivotMatrixInverse) {
                                rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);
                            }
                            else {
                                rotationTransformation.matrix = rotationMatrix;
                            }
                        }
                        else if (track.path === 'translation') {
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);
                            }
                            translationTransformation.matrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);
                        }
                        else if (track.path === 'scale') {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);
                            }
                            const scalingMatrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);
                            if (pivotMatrix && pivotMatrixInverse) {
                                scaleTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, scalingMatrix), pivotMatrixInverse);
                            }
                            else {
                                scaleTransformation.matrix = scalingMatrix;
                            }
                        }
                        else if (track.path === 'weights') {
                            let weights = [];
                            const weightCount = track.values.length / track.times.length;
                            if (track.interpolation === 'step') {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l]);
                            }
                            else {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l] * (1.0 - factor) + (factor) * track.values[(k - 1) * weightCount + l]);
                            }
                            const applyWeights = (node) => {
                                for (let l = 0; l < node.data.length; l++)
                                    if (node.data[l] instanceof viewer_shared_types_1.GeometryData && node.data[l].morphWeights.length === weightCount)
                                        node.data[l].morphWeights = weights;
                                for (let l = 0; l < node.children.length; l++)
                                    applyWeights(node.children[l]);
                            };
                            applyWeights(track.node);
                        }
                        break;
                    }
                }
            }
        }
        return running;
    }
}
exports.AnimationManager = AnimationManager;
//# sourceMappingURL=AnimationManager.js.map