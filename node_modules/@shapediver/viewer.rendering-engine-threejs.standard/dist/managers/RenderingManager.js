"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderingManager = void 0;
const TWEEN = __importStar(require("@tweenjs/tween.js"));
const Stats = __importStar(require("stats.js"));
const THREE = __importStar(require("three"));
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
class RenderingManager {
    // #endregion Properties (20)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (20)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._systemInfo = tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._activeRendering = true;
        this._cameraChanged = false;
        this._continuousRendering = false;
        this._continuousShadowMapUpdate = false;
        this._height = 0;
        this._lastCameraMatrix = gl_matrix_1.mat4.create();
        this._lastRootVersion = '';
        this._lastSize = {
            adjustedWidth: 0,
            adjustedHeight: 0,
            width: 0,
            height: 0
        };
        this._lastTime = 0;
        this._maxTextureUnits = 0;
        this._minimalRendering = false;
        this._noWebGL = false;
        this._runningAnimation = false;
        this._sizeChanged = false;
        this._usingSwiftShader = false;
        this._width = 0;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (6)
    get continuousRendering() {
        return this._continuousRendering;
    }
    set continuousRendering(value) {
        this._continuousRendering = value;
    }
    get continuousShadowMapUpdate() {
        return this._continuousShadowMapUpdate;
    }
    set continuousShadowMapUpdate(value) {
        this._continuousShadowMapUpdate = value;
    }
    get lastRootVersion() {
        return this._lastRootVersion;
    }
    set lastRootVersion(value) {
        this._lastRootVersion = value;
    }
    get minimalRendering() {
        return this._minimalRendering;
    }
    get usingSwiftShader() {
        return this._usingSwiftShader;
    }
    // #endregion Public Accessors (6)
    // #region Public Methods (9)
    addLogo(canvas, branding) {
        var _a, _b;
        const logoDivElement = document.createElement('div');
        logoDivElement.style.backgroundColor = branding.backgroundColor;
        logoDivElement.style.position = 'relative';
        logoDivElement.style.height = '100%';
        logoDivElement.style.width = '100%';
        (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(logoDivElement, (_b = canvas.parentElement) === null || _b === void 0 ? void 0 : _b.firstChild);
        if (branding.logo) {
            const img = new Image();
            img.style.position = 'absolute';
            img.style.top = '50%';
            img.style.left = '50%';
            img.style.transform = 'translateX(-50%) translateY(-50%)';
            img.src = branding.logo;
            logoDivElement.appendChild(img);
        }
        return logoDivElement;
    }
    addSpinner(canvas, branding) {
        var _a, _b;
        const spinnerDivElement = document.createElement('div');
        spinnerDivElement.style.position = 'absolute';
        spinnerDivElement.style.userSelect = 'none';
        spinnerDivElement.style.cursor = 'default';
        spinnerDivElement.style.pointerEvents = 'none';
        if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.BOTTOM_RIGHT) {
            spinnerDivElement.style.right = '10px';
            spinnerDivElement.style.bottom = '10px';
        }
        else if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.BOTTOM_LEFT) {
            spinnerDivElement.style.left = '10px';
            spinnerDivElement.style.bottom = '10px';
        }
        else if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.TOP_RIGHT) {
            spinnerDivElement.style.right = '10px';
            spinnerDivElement.style.top = '10px';
        }
        else if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.TOP_LEFT) {
            spinnerDivElement.style.left = '10px';
            spinnerDivElement.style.top = '10px';
        }
        else {
            spinnerDivElement.style.height = '100%';
            spinnerDivElement.style.width = '100%';
        }
        spinnerDivElement.style.visibility = 'hidden';
        (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(spinnerDivElement, (_b = canvas.parentElement) === null || _b === void 0 ? void 0 : _b.firstChild);
        if (branding.busyModeSpinner) {
            const img = new Image();
            img.src = branding.busyModeSpinner;
            if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.CENTER) {
                img.style.position = 'absolute';
                img.style.top = '50%';
                img.style.left = '50%';
                img.style.transform = 'translateX(-50%) translateY(-50%)';
            }
            else {
                if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.BOTTOM_RIGHT || branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.TOP_RIGHT) {
                    img.style.float = 'right';
                }
                else if (branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.BOTTOM_LEFT || branding.spinnerPositioning === viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.TOP_LEFT) {
                    img.style.float = 'left';
                }
                img.style.width = 'calc(100% * 0.75)';
                img.style.height = 'calc(100% * 0.75)';
            }
            spinnerDivElement.appendChild(img);
        }
        return spinnerDivElement;
    }
    createRenderer(canvas) {
        const renderingProperties = {
            alpha: true,
            depth: true,
            antialias: true,
            preserveDrawingBuffer: true,
            canvas
        };
        const context = this.createWebGLContext(renderingProperties);
        const renderer = new THREE.WebGLRenderer(Object.assign({ context }, renderingProperties));
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.physicallyCorrectLights = false;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.needsUpdate = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = false;
        renderer.localClippingEnabled = true;
        renderer.setSize(canvas.width, canvas.height);
        renderer.setClearColor(new THREE.Color('#ffffff'), 1);
        this._maxTextureUnits = renderer.getContext().getParameter(renderer.getContext().MAX_TEXTURE_IMAGE_UNITS);
        return renderer;
    }
    evaluateTextureUnitCount(value) {
        if (value > this._maxTextureUnits) {
            this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `RenderingManager.evaluateTextureUnitCount: Maximum number of texture units exceeded. Disabling shadows.`);
            this._renderingEngine.lightLoader.forceDisabledShadows = true;
            this._renderingEngine.update('RenderingManager.evaluateTextureUnitCount');
        }
        else {
            this._renderingEngine.lightLoader.forceDisabledShadows = false;
        }
    }
    getScreenshot(type = 'image/png', encoderOptions = 1) {
        return this._renderingEngine.renderer.domElement.toDataURL(type, encoderOptions);
    }
    init() {
        try {
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id)
                    this.startRendering();
            });
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id)
                    this.stopRendering();
            });
            window.onresize = () => { this.render(); };
            this._renderingEngine.canvas.onresize = () => { this.render(); };
            this._renderingEngine.canvas.parentElement.onresize = () => { this.render(); };
            const stats1 = new Stats.default();
            stats1.showPanel(0); // Panel 0 = fps
            stats1.dom.style.cssText = 'position:absolute;top:0px;left:0px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats1.dom);
            const stats2 = new Stats.default();
            stats2.showPanel(1); // Panel 1 = ms
            stats2.dom.style.cssText = 'position:absolute;top:0px;left:80px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats2.dom);
            const stats3 = new Stats.default();
            stats3.showPanel(2); // Panel 2 = ms
            stats3.dom.style.cssText = 'position:absolute;top:0px;left:160px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats3.dom);
            this._stats = {
                stats: [stats1, stats2, stats3],
                begin: () => {
                    stats1.begin();
                    stats2.begin();
                    stats3.begin();
                },
                end: () => {
                    stats1.end();
                    stats2.end();
                    stats3.end();
                }
            };
        }
        catch (e) {
            this._noWebGL = true;
            throw e;
        }
    }
    render() {
        this.startAndStopRendering();
    }
    resize(width, height) {
        this._width = width, this._height = height;
    }
    start() {
        this.animate(0);
        this.startAndStopRendering();
    }
    updateShadowMap() {
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
    }
    // #endregion Public Methods (9)
    // #region Private Methods (10)
    animate(time) {
        // animation loop - part 1: initial discarding
        if (this._renderingEngine.closed || this._noWebGL)
            return;
        // animation loop - part 2: requesting and timings
        requestAnimationFrame((time) => this.animate(time));
        TWEEN.update(time);
        const deltaTime = time - this._lastTime < 0 ? 0 : time - this._lastTime;
        this._lastTime = time;
        this._renderingEngine.evaluateFlagState();
        // update if needed
        if (this._tree.root.version !== this._lastRootVersion) {
            this._renderingEngine.sceneTreeManager.updateSceneTree(this._tree.root, this._renderingEngine.lightEngine);
            this.updateShadowMap();
            this._renderingEngine.startGatherAnimations();
            this._lastRootVersion = this._tree.root.version;
            this.render();
        }
        const runningAnimation = this._renderingEngine.animationManager.update(deltaTime);
        if (runningAnimation !== this._runningAnimation)
            this.render();
        this._runningAnimation = runningAnimation;
        if (this._runningAnimation)
            this._renderingEngine.sceneTreeManager.updateNodeTransformations();
        if (this._runningAnimation)
            this._renderingEngine.sceneTreeManager.updateMorphWeights();
        // get the current size
        const { width, height, adjustedWidth, adjustedHeight } = this.calculateSize();
        const aspect = width / height;
        this._sizeChanged = this._lastSize.adjustedHeight !== adjustedHeight || this._lastSize.adjustedWidth !== adjustedWidth || this._lastSize.height !== height || this._lastSize.width !== width;
        this._lastSize = { width, height, adjustedWidth, adjustedHeight };
        // animation loop - part 3: update the camera, if there are new movements, they will start / continue the rendering
        this._cameraChanged = this._renderingEngine.cameraEngine.camera ? this._renderingEngine.cameraManager.updateCamera(deltaTime, aspect) : false;
        // animation loop - part 4: evaluating state
        const states = this.evaluateRenderingState();
        // animation loop - part 5: the scene is not even shown
        if (states.showScene === false) {
            // toggle on logo
            this.toggleLogo(true);
            this.toggleBusyMode(false);
            return;
        }
        else {
            this.toggleLogo(false);
        }
        // animation loop - part 6: the scene is shown, but there is no active rendering happening
        if (states.rendering === false)
            return;
        // animation loop - part 7: there is actual rendering happening
        // do the things that have to be done for standard and beauty rendering in the same way
        this._stats.begin();
        this.showStatistics();
        // toggle the blurring
        this.toggleBusyMode(states.busyMode);
        // animation loop - part 8: calculate the current size
        const currentSize = new THREE.Vector2();
        this._renderingEngine.renderer.getSize(currentSize);
        if (!currentSize.equals(new THREE.Vector2(adjustedWidth, adjustedHeight))) {
            this._renderingEngine.renderer.setSize(adjustedWidth, adjustedHeight);
            this._renderingEngine.renderer.domElement.style.width = width + 'px';
            this._renderingEngine.renderer.domElement.style.height = height + 'px';
            this._renderingEngine.materialLoader.assignPointSize(this._renderingEngine.pointSize);
        }
        // animation loop - part 9: adjust the camera (the rendering state would be false if we didn't have a camera)
        const camera = this._renderingEngine.cameraManager.adjustCamera(aspect);
        // animation loop - part 10: adjust the anchor elements
        this._renderingEngine.htmlElementAnchorLoader.adjustPositions(adjustedWidth / width, adjustedHeight / height);
        // animation loop - part 11: adjust some scene settings
        // enable / disable the shadow map
        const enabled = this._renderingEngine.renderer.shadowMap.enabled;
        this._renderingEngine.renderer.shadowMap.enabled = this._renderingEngine.usingSwiftShader || this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES ? false : this._renderingEngine.shadows;
        if (enabled !== this._renderingEngine.renderer.shadowMap.enabled)
            this._renderingEngine.materialLoader.updateMaterials();
        let threeJsLightObject, oldLightVisibility = true;
        // enable / disable lights
        if (this._renderingEngine.lights === false) {
            const ls = this._renderingEngine.lightEngine.lightScene;
            if (ls) {
                threeJsLightObject = ls.node.threeJsObject[this._renderingEngine.id];
                if (threeJsLightObject) {
                    oldLightVisibility = threeJsLightObject.visible;
                    threeJsLightObject.visible = false;
                }
            }
        }
        // update shadowMap if need
        if (states.updateShadowMap && this._renderingEngine.renderer.shadowMap.enabled)
            this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        // enable / disable the background
        this._renderingEngine.sceneTreeManager.scene.background = this._renderingEngine.environmentMapAsBackground ? this._renderingEngine.environmentMapLoader.environmentMap : null;
        // set the background color / alpha
        this._renderingEngine.renderer.setClearColor(new THREE.Color(this._converter.toThreeJsColorInput(this._renderingEngine.clearColor)), this._renderingEngine.clearAlpha);
        // animation loop - part 12: actual rendering separation
        if (states.beautyRendering === true) {
            this._renderingEngine.beautyRenderingManager.render(deltaTime, camera, width, height);
            // if the duration was long enough, disable the beauty rendering
            if (this._renderingEngine.beautyRenderingManager.beautyRenderingDurationActive >= this._renderingEngine.beautyRenderBlendingDuration) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.RENDERING.BEAUTY_RENDERING_FINISHED, { viewportId: this._renderingEngine.id });
                this._renderingEngine.beautyRenderingManager.deactivateBeautyRenderShaders();
                this._activeRendering = false;
            }
            else {
                this._renderingEngine.beautyRenderingManager.beautyRenderingDurationActive += deltaTime;
            }
        }
        else {
            this._renderingEngine.renderer.render(this._renderingEngine.sceneTreeManager.scene, camera);
            // if the beauty rendering was active, disable it
            if (this._renderingEngine.beautyRenderingManager.beautyRenderingActive) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.RENDERING.BEAUTY_RENDERING_FINISHED, { viewportId: this._renderingEngine.id });
                this._renderingEngine.beautyRenderingManager.deactivateBeautyRenderShaders();
                this._activeRendering = false;
            }
        }
        // reset the visibility of the threeJs light object
        if (threeJsLightObject)
            threeJsLightObject.visible = oldLightVisibility;
        this._stats.end();
    }
    calculateSize() {
        let width = this._width, height = this._height;
        if (this._renderingEngine.automaticResizing) {
            width = this._renderingEngine.canvas.parentNode.clientWidth;
            height = this._renderingEngine.canvas.parentNode.clientHeight;
        }
        const aspect = width / height;
        let adjustedWidth = width, adjustedHeight = height;
        if (width > 1920 || height > 1080) {
            if ((width - 1920) / aspect > (height - 1080)) {
                adjustedWidth = 1920;
                adjustedHeight = 1920 / aspect;
            }
            else {
                adjustedWidth = 1080 * aspect;
                adjustedHeight = 1080;
            }
        }
        return {
            width, adjustedWidth,
            height, adjustedHeight
        };
    }
    createWebGLContext(properties) {
        try {
            let canvas = properties.canvas;
            canvas.addEventListener('webglcontextlost', () => { }, false);
            canvas.addEventListener('webglcontextrestored', () => { }, false);
            const props = Object.assign({
                stencil: true,
                premultipliedAlpha: true,
                powerPreference: 'default'
            }, properties);
            let _gl = canvas.getContext('webgl2', props) || canvas.getContext('webgl', props) || canvas.getContext('experimental-webgl', props);
            // creation failed
            if (_gl === null) {
                // create without the attributes
                _gl = canvas.getContext('webgl2', props) || canvas.getContext('webgl', props) || canvas.getContext('experimental-webgl', props);
                if (_gl !== null) {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, 'RenderingLogic.createWebGLContext: We were unable to get a WebGL context using the requested attributes, falling back to default attributes.');
                }
                else {
                    const error = new viewer_shared_services_1.ShapeDiverViewerWebGLError('RenderingLogic.createWebGLContext: We were unable to get a WebGL context.');
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `RenderingLogic.createWebGLContext`, error, false);
                }
            }
            // Some experimental-webgl implementations do not have getShaderPrecisionFormat
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function () {
                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }
            const debugInfo = _gl.getExtension("WEBGL_debug_renderer_info");
            if (debugInfo) {
                const vendor = _gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                const renderer = _gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                if (renderer === "Google SwiftShader") {
                    this._usingSwiftShader = true;
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, 'RenderingLogic.createWebGLContext: The current device is using Google SwiftShader, a CPU-based renderer. To achieve better rendering results, please enable GPU-rendering in your settings.');
                }
            }
            if (!_gl.getExtension("EXT_shader_texture_lod"))
                this._minimalRendering = true;
            return _gl;
        }
        catch (e) {
            const error = new viewer_shared_services_1.ShapeDiverViewerWebGLError('RenderingLogic.createWebGLContext: We were unable to get a WebGL context.', e);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `RenderingLogic.createWebGLContext`, error, false);
        }
    }
    evaluateRenderingState() {
        // If there is a camera to show the scene and the setting for it is set to true, we show the scene
        let showScene = false;
        if (this._renderingEngine.cameraEngine.camera && this._renderingEngine.show === true)
            showScene = true;
        // If we should render at all
        let rendering = false;
        if (this._activeRendering === true || this._cameraChanged === true || this._sizeChanged === true || this._runningAnimation === true || this._continuousRendering === true)
            rendering = true;
        let updateShadowMap = false;
        if (this._runningAnimation === true || this._continuousShadowMapUpdate === true)
            updateShadowMap = true;
        // special case, autorotation
        if (this._renderingEngine.cameraEngine.camera) {
            const camera = this._renderingEngine.cameraEngine.camera;
            if (camera.type === viewer_rendering_engine_camera_engine_1.CAMERA_TYPE.PERSPECTIVE) {
                const controls = camera.controls;
                if (controls.enableAutoRotation === true && controls.autoRotationSpeed !== 0)
                    return { showScene, rendering: true, updateShadowMap, busyMode: this._renderingEngine.busy, beautyRendering: false };
            }
        }
        else {
            rendering = false;
        }
        // If the scene should be blurred
        let busyMode = false;
        if (this._renderingEngine.busy)
            busyMode = true;
        // If we should render in beauty mode
        let beautyRendering = false;
        if (this._renderingEngine.beautyRenderingManager.beautyRenderingActive === true && busyMode === false && this._continuousRendering === false &&
            (this._renderingEngine.shadows || ((this._renderingEngine.ambientOcclusion && this._renderingEngine.ambientOcclusionIntensity > 0.0) && !this._systemInfo.isIOS)) &&
            this._renderingEngine.usingSwiftShader === false && this._runningAnimation === false && this._renderingEngine.type !== viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES)
            beautyRendering = true;
        return { showScene, rendering, updateShadowMap, busyMode, beautyRendering };
    }
    showStatistics() {
        if (this._renderingEngine.showStatistics) {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = '';
        }
        else {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = 'none';
        }
    }
    startAndStopRendering() {
        this._activeRendering = true;
        this._renderingEngine.beautyRenderingManager.stopBeautyRenderCountdown();
        this._renderingEngine.beautyRenderingManager.startBeautyRenderCountdown();
    }
    startRendering() {
        this._activeRendering = true;
        this._renderingEngine.beautyRenderingManager.stopBeautyRenderCountdown();
    }
    stopRendering() {
        this._renderingEngine.beautyRenderingManager.startBeautyRenderCountdown();
    }
    toggleBusyMode(toggle) {
        if (this._renderingEngine.branding.busyModeDisplay === viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.BLUR) {
            this._renderingEngine.htmlElementAnchorLoader.toggleBusyMode(toggle);
            if (toggle) {
                if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && navigator.userAgent.toLowerCase().indexOf('android') > -1)
                    return;
                this._renderingEngine.renderer.domElement.style.filter = 'blur(3px)';
            }
            else {
                this._renderingEngine.renderer.domElement.style.filter = '';
            }
        }
        else if (this._renderingEngine.branding.busyModeDisplay === viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.SPINNER) {
            if (toggle) {
                this._renderingEngine.spinnerDivElement.style.visibility = 'visible';
            }
            else {
                this._renderingEngine.spinnerDivElement.style.visibility = 'hidden';
            }
        }
    }
    toggleLogo(toggle) {
        if (this._renderingEngine.logoDivElement)
            this._renderingEngine.logoDivElement.style.display = toggle ? 'inherit' : 'none';
        if (this._renderingEngine.canvas)
            this._renderingEngine.canvas.style.display = !toggle ? 'inherit' : 'none';
    }
}
exports.RenderingManager = RenderingManager;
//# sourceMappingURL=RenderingManager.js.map