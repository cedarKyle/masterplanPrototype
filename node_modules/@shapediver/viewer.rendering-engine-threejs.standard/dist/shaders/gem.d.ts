export declare const vert = "\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// CUSTOM START\nvarying vec3 frag_position;\nvarying vec3 frag_normal;\n// CUSTOM END\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n    #ifdef USE_TRANSMISSION\n        vWorldPosition = worldPosition.xyz;\n    #endif\n\n    // CUSTOM START\n    frag_position = position;\n    frag_normal = objectNormal;\n    // CUSTOM END\n}\n";
export declare const frag = "\n#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\n// CUSTOM START\n#ifdef USE_IMPURITYMAP\n\tuniform sampler2D impurityMap;\n#endif\n// CUSTOM END\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n\n\n// CUSTOM START\n\nvarying vec4 initialPosition;\nvarying vec3 initialNormal;\n\nvarying vec3 frag_position;\nvarying vec3 frag_normal;\n\nuniform vec3 center;\nuniform float radius;\nuniform samplerCube sphericalNormalMap;\nuniform mat3 normalMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 inverseModelMatrix;\nuniform mat3 inverseTransposeModelMatrix;\n\nuniform float impurityScale;\nuniform vec3 colorTransferBegin;\nuniform vec3 colorTransferEnd;\nuniform float refractionIndex;\nuniform float gamma;\nuniform float contrast;\nuniform float brightness;\nuniform float dispersion;\nuniform float tracingOpacity;\n\n\nvec3 getIBLRadianceVariation( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\treturn min(envMapColor.rgb * envMapIntensity, vec3(1.0));\n\t#else\n\t\treturn vec3( 0.0 );\n\t#endif\n}\n\nvec3 calculateReflectedLight(vec3 position, vec3 normal, vec3 viewDir, PhysicalMaterial material, int depth) {\n\t\n\tGeometricContext currentGeometry;\n\tcurrentGeometry.position = (modelMatrix * vec4(position, 1.0)).xyz;\n\tcurrentGeometry.normal = normalize(inverseTransposeModelMatrix * normal);\n\tcurrentGeometry.viewDir = normalize(inverseTransposeModelMatrix * -viewDir);\n\n\n    #ifdef USE_CLEARCOAT\n        currentGeometry.clearcoatNormal = clearcoatNormal;\n    #endif\n\n\tReflectedLight rLight;\n\tIncidentLight dLight;\n\n\tfloat temp = material.roughness;\n\tmaterial.roughness = 0.5;\n\n\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tPointLight pointLight;\n        #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n            PointLightShadow pointLightShadow;\n        #endif\n\n\t    #pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\t\tpointLight = pointLights[ i ];\n            getPointLightInfo( pointLight, currentGeometry, dLight );\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n                pointLightShadow = pointLightShadows[ i ];\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n            #endif\n\t\t    RE_Direct( dLight, currentGeometry, material, rLight );\n\t\t}\n        #pragma unroll_loop_end\n\t#endif\n\t#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n        SpotLight spotLight;\n        #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n            SpotLightShadow spotLightShadow;\n        #endif\n        #pragma unroll_loop_start\n        for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n            spotLight = spotLights[ i ];\n            getSpotLightInfo( spotLight, currentGeometry, dLight );\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n                spotLightShadow = spotLightShadows[ i ];\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n            #endif\n            RE_Direct( dLight, currentGeometry, material, rLight );\n        }\n        #pragma unroll_loop_end\n\t#endif\n\n    #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n        DirectionalLight directionalLight;\n        #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n            DirectionalLightShadow directionalLightShadow;\n        #endif\n        #pragma unroll_loop_start\n        for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n            directionalLight = directionalLights[ i ];\n            getDirectionalLightInfo( directionalLight, currentGeometry, dLight );\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n                directionalLightShadow = directionalLightShadows[ i ];\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n            #endif\n            RE_Direct( dLight, currentGeometry, material, rLight );\n        }\n        #pragma unroll_loop_end\n    #endif\n\tmaterial.roughness = temp;\n\t\n    #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n        RectAreaLight rectAreaLight;\n        #pragma unroll_loop_start\n        for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n            rectAreaLight = rectAreaLights[ i ];\n            RE_Direct_RectArea( rectAreaLight, currentGeometry, material, rLight );\n        }\n        #pragma unroll_loop_end\n    #endif\n    #if defined( RE_IndirectDiffuse )\n        vec3 iblIrradiance = vec3( 0.0 );\n        vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n        irradiance += getLightProbeIrradiance( lightProbe, currentGeometry.normal );\n        #if ( NUM_HEMI_LIGHTS > 0 )\n            #pragma unroll_loop_start\n            for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n                irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], currentGeometry.normal );\n            }\n            #pragma unroll_loop_end\n        #endif\n    #endif\n    #if defined( RE_IndirectSpecular )\n        vec3 radiance = vec3( 0.0 );\n        vec3 clearcoatRadiance = vec3( 0.0 );\n    #endif\n\n\n    #if defined( RE_IndirectDiffuse )\n        #ifdef USE_LIGHTMAP\n            vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n            vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n            irradiance += lightMapIrradiance;\n        #endif\n        #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n            iblIrradiance += getIBLIrradiance( currentGeometry.normal );\n        #endif\n    #endif\n    #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n        radiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.normal, material.roughness );\n        #ifdef USE_CLEARCOAT\n            clearcoatRadiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.clearcoatNormal, material.clearcoatRoughness );\n        #endif\n    #endif\n\n    #if defined( RE_IndirectDiffuse )\n        RE_IndirectDiffuse( irradiance, currentGeometry, material, rLight );\n    #endif\n    #if defined( RE_IndirectSpecular )\n        RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, currentGeometry, material, rLight );\n    #endif\n\n\tif(depth >= 0) {\n\t\tfloat frac = float(depth) / float(TRACING_DEPTH);\n\t\tvec3 colorTransfer = (1.0-frac) * colorTransferBegin + frac * colorTransferEnd;\n\t\trLight.indirectSpecular *= colorTransfer;\n\t\trLight.directSpecular *= colorTransfer;\n\t}\n\n\tvec3 color = rLight.indirectSpecular + rLight.directSpecular + rLight.indirectDiffuse + rLight.directDiffuse;\n\n\t// gamma\n\tcolor = pow(color, vec3(1.0/gamma)); \n\n\t// contrast\n\tcolor.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5; \n\n\t// brightness\n\tcolor.r = min(max(color.r + brightness, 0.0), 1.0);\n\tcolor.g = min(max(color.g + brightness, 0.0), 1.0);\n\tcolor.b = min(max(color.b + brightness, 0.0), 1.0);\n\n\treturn color;\n}\n\nvec3 normalLookUp(vec3 dir) {\n\tvec4 s = textureCube(sphericalNormalMap, dir);\n\tif(s.a < 1.0/256.0) {\n\t\treturn normalize(vec3(-s.x, -s.y, -s.z));\n\t} else if(s.a < 3.0/256.0) {\n\t\treturn normalize(vec3(-s.x, -s.y, s.z));\n\t} else if(s.a < 5.0/256.0) {\n\t\treturn normalize(vec3(-s.x, s.y, -s.z));\n\t} else if(s.a < 7.0/256.0) {\n\t\treturn normalize(vec3(s.x, -s.y, -s.z));\n\t} else if(s.a < 9.0/256.0) {\n\t\treturn normalize(vec3(-s.x, s.y, s.z));\n\t} else if(s.a < 11.0/256.0) {\n\t\treturn normalize(vec3(s.x, -s.y, s.z));\n\t} else if(s.a < 13.0/256.0) {\n\t\treturn normalize(vec3(s.x, s.y, -s.z));\n\t} else {\n\t\treturn normalize(s.xyz);\n\t}\n}\n\n#ifdef USE_IMPURITYMAP\n\tfloat impurityLookUp(vec3 dir) {\n\t\tvec3 c = textureCube(impurityMap, dir.xy).rgb;\n\t\treturn (c.x + c.y + c.z) / 3.0;\n\t}\n#endif\n\nvec3 raySphereIntersection(vec3 o, vec3 d) {\n\n\tvec3 oc = o - center;\n    float a = dot(d, d);\n    float b = 2.0 * dot(oc, d);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return vec3(0.0);\n    }\n    else{\n        return o +( (-b + sqrt(discriminant)) / (2.0*a)) * d;\n    }\n}\n\nvec3 hueToSaturatedColor(float hue) {\n    float r,g,b;\n    if (hue < 0.25){\n\t\tfloat t = 1.0 - (hue / 0.25);\n        r = 1.0;\n        g = 1.0;\n        b = t;    \n\t} else if (hue < 0.5){\n    \tfloat t = 1.0 - (hue - 0.25 / 0.25);\n\t\tr = 1.0;\n        g = t;\n        b = 0.0;\n\t} else if (hue < 0.75){\n    \tfloat t = 1.0 - (hue - 0.5 / 0.25);\n\t\tr = t;\n        g = 0.0;\n        b = 1.0 - t;\n    } else {\n    \tfloat t = hue - 0.75 / 0.25;\n        r = t;\n        g = t;\n        b = 1.0;\n    }\n    return vec3(r, g, b) / 0.5 + 0.5;\n}\n// CUSTOM END\n\nvoid main() {    \n    // CUSTOM START\n    vec3 frag_normal_normalized = frag_normal;\n    // CUSTOM END\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\n    // CUSTOM START\n    \n\tvec3 initialDirection = normalize( frag_position - (inverseModelMatrix*vec4(cameraPosition,1.0)).xyz );\n\n\tvec4 outgoingLight2;\n\tfloat r_0 = (1.0-refractionIndex)/(1.0+refractionIndex);\n\tr_0 = r_0*r_0;\n\n\tfloat cos_theta_0 = -dot(initialDirection, frag_normal_normalized);\n\tfloat r_0_outside = (refractionIndex-1.0)/(refractionIndex+1.0);\n\tr_0_outside = r_0_outside*r_0_outside;\n\tfloat initialProbability = r_0_outside + (1.0 - r_0_outside)*pow(1.0 - cos_theta_0, 5.0);\n\n\toutgoingLight2 = vec4(calculateReflectedLight(frag_position, frag_normal_normalized, initialDirection, material, -1), 1.0);\n\t// gl_FragColor = outgoingLight2;\n\t// return;\n\tif(TRACING_DEPTH > 0) \n\t\toutgoingLight2 *= initialProbability;\n\t\t\n\tvec3 tempColor;\n\n\t#ifdef DISPERSION\n\t\tconst int loop = 3;\n\t\tvec3 dispersionColor;\n\t#else\n\t\tconst int loop = 1;\n\t#endif\n\t\t#pragma unroll_loop_start\n\t\tfor(int j = 0; j < loop; j++){\n\t\t\tvec3 refractedDirection = refract(initialDirection, frag_normal_normalized, 1.0/refractionIndex + float(j)*dispersion * 0.025);\n\t\t\tvec3 newPosition = raySphereIntersection(frag_position, refractedDirection);\n\t\t\tvec3 lookUpVector = normalize(newPosition - center);\n\t\t\tvec3 newNormal = normalLookUp(lookUpVector);\n\t\t\tvec3 newDirection = reflect(refractedDirection, newNormal);\n\n\t\t\tfloat currentProbability = 1.0;\n\n\t\t\t#ifdef USE_IMPURITYMAP\n\t\t\t\tfloat impurityProbability = impurityLookUp(lookUpVector);\n\t\t\t\tcurrentProbability -= impurityProbability * impurityScale;\n\t\t\t\t// gl_FragColor = vec4(vec3(impurityProbability), 1.0);\n\t\t\t\t// return;\n\t\t\t#endif\n\t\t\t\n\t\t\t// if(0 == TRACING_DEPTH) {\n\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\n\t\t\t// \treturn;\n\t\t\t// }\n\n\t\t\ttempColor = vec3(0.0);\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor(int i = 0; i < TRACING_DEPTH; i++) {\n\t\t\t\t// small position correction to avoid artefacts\n\t\t\t\tnewPosition = newPosition - lookUpVector * 1e-6;\n\t\t\t\tnewPosition = raySphereIntersection(newPosition, newDirection);\n\t\t\t\tlookUpVector = normalize(newPosition - center);\n\t\t\t\tnewNormal = normalLookUp(lookUpVector);\n\t\t\t\n\t\t\t\tfloat cos_theta = dot(newDirection, newNormal);\n\t\t\t\tfloat ratio;\n\t\t\t\tif(cos_theta > 0.0) {\n\t\t\t\t\tratio = refractionIndex;\n\t\t\t\t} else {\n\t\t\t\t\tcos_theta = -cos_theta;\n\t\t\t\t\tratio = 1.0 / refractionIndex;\n\t\t\t\t}\n\t\t\t\tfloat cos_theta_2 = 1.0 - ratio*ratio * (1.0 - cos_theta*cos_theta);\n\t\t\t\tfloat probability = r_0 + (1.0 - r_0)*pow(1.0 - cos_theta, 5.0);\n\t\t\t\tif(cos_theta_2 < 0.0) probability = 0.0;\n\n\t\t\t\tvec3 refracted = refract(newDirection, newNormal*-1.0, 1.0/refractionIndex);\n\t\t\t\ttempColor += probability * currentProbability * calculateReflectedLight(newPosition, newNormal*-1.0, reflect(refracted, newNormal), material, i);\n\t\t\t\tif(i+1 == TRACING_DEPTH)\n\t\t\t\t\ttempColor += (1.0 - probability) * currentProbability * calculateReflectedLight(newPosition, newNormal, newDirection, material, i);\n\n\t\t\t\tnewDirection = reflect(newDirection, newNormal);\n\n\t\t\t\t// if(i+1 == TRACING_DEPTH) {\n\t\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\n\t\t\t\t// \treturn;\n\t\t\t\t// }\n\n\t\t\t\tcurrentProbability *= (1.0 - probability);\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\n\t\t\t#ifdef DISPERSION\n\t\t\t\tif(j == 0) {\n\t\t\t\t\tdispersionColor.r = tempColor.r;\t\n\t\t\t\t} else if(j == 1) {\n\t\t\t\t\tdispersionColor.g = tempColor.g;\t\n\t\t\t\t} else if(j == 2) {\n\t\t\t\t\tdispersionColor.b = tempColor.b;\t\n\t\t\t\t}\n\t\t\t\ttempColor = dispersionColor;\n\t\t\t#endif\n\t\t}\t\n\t\t#pragma unroll_loop_end\n\n\tif(TRACING_DEPTH > 0)\n\t\toutgoingLight2.rgb += (1.0 - initialProbability) * tempColor;\n\n\tfloat alpha = (1.0 - initialProbability) + initialProbability*tracingOpacity;\n\tgl_FragColor = vec4(outgoingLight2.rgb, alpha*diffuseColor.a);\n\n    // CUSTOM END\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n\n";
//# sourceMappingURL=gem.d.ts.map