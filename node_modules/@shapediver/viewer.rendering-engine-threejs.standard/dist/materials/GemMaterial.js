"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GemMaterial = void 0;
const THREE = __importStar(require("three"));
const gem_1 = require("../shaders/gem");
class GemMaterial extends THREE.MeshPhysicalMaterial {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(params) {
        super();
        this.refractionIndex = 2.4;
        this.impurityMap = null;
        this.impurityScale = 1.0;
        this.colorTransferBegin = new THREE.Color(0xffffff);
        this.colorTransferEnd = new THREE.Color(0xffffff);
        this.center = new THREE.Vector3(0, 0, 0);
        this.tracingDepth = 5;
        this.radius = 1.0;
        this.sphericalNormalMap = null;
        this.gamma = 1.0;
        this.contrast = 1.0;
        this.brightness = 0.0;
        this.dispersion = 0.0;
        this.tracingOpacity = 0.0;
        this.inverseModelMatrix = new THREE.Matrix4();
        this.inverseTransposeModelMatrix = new THREE.Matrix3();
        this.isGemMaterial = true;
        const uniforms = {
            refractionIndex: { value: 2.4 },
            impurityMap: { value: null },
            impurityScale: { value: 1.0 },
            colorTransferBegin: { value: new THREE.Color(0xffffff) },
            colorTransferEnd: { value: new THREE.Color(0xffffff) },
            center: { value: new THREE.Vector3(0, 0, 0) },
            tracingDepth: { value: 5 },
            radius: { value: 1.0 },
            sphericalNormalMap: { value: null },
            gamma: { value: 1.0 },
            contrast: { value: 1.0 },
            brightness: { value: 0.0 },
            dispersion: { value: 0.0 },
            tracingOpacity: { value: 0.0 },
            inverseModelMatrix: { value: new THREE.Matrix4() },
            inverseTransposeModelMatrix: { value: new THREE.Matrix3() },
        };
        this._extraUniforms = uniforms;
        this.onBeforeCompile = function (shader) {
            for (const uniformName in uniforms) {
                shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.vertexShader = gem_1.vert;
            shader.fragmentShader = gem_1.frag;
        };
        Object.defineProperties(this, {
            tracingDepth: {
                get: function () {
                    return uniforms.tracingDepth.value;
                },
                set: function (v) {
                    uniforms.tracingDepth.value = v;
                    if (v) {
                        this.defines.TRACING_DEPTH = Math.floor(v);
                    }
                    else {
                        delete this.defines.TRACING_DEPTH;
                    }
                }
            },
            refractionIndex: {
                get: function () {
                    return uniforms.refractionIndex.value;
                },
                set: function (v) {
                    uniforms.refractionIndex.value = v;
                }
            },
            impurityMap: {
                get: function () {
                    return uniforms.impurityMap.value;
                },
                set: function (v) {
                    uniforms.impurityMap.value = v;
                    if (v) {
                        this.defines.USE_IMPURITYMAP = '';
                        this.defines.USE_UV = '';
                    }
                    else {
                        delete this.defines.USE_IMPURITYMAP;
                        delete this.defines.USE_UV;
                    }
                }
            },
            impurityScale: {
                get: function () {
                    return uniforms.impurityScale.value;
                },
                set: function (v) {
                    uniforms.impurityScale.value = v;
                }
            },
            colorTransferBegin: {
                get: function () {
                    return uniforms.colorTransferBegin.value;
                },
                set: function (v) {
                    uniforms.colorTransferBegin.value = v;
                }
            },
            colorTransferEnd: {
                get: function () {
                    return uniforms.colorTransferEnd.value;
                },
                set: function (v) {
                    uniforms.colorTransferEnd.value = v;
                }
            },
            center: {
                get: function () {
                    return uniforms.center.value;
                },
                set: function (v) {
                    uniforms.center.value = v;
                }
            },
            radius: {
                get: function () {
                    return uniforms.radius.value;
                },
                set: function (v) {
                    uniforms.radius.value = v;
                }
            },
            sphericalNormalMap: {
                get: function () {
                    return uniforms.sphericalNormalMap.value;
                },
                set: function (v) {
                    uniforms.sphericalNormalMap.value = v;
                    if (v) {
                        this.defines.USE_UV = '';
                    }
                    else {
                        delete this.defines.USE_UV;
                    }
                }
            },
            gamma: {
                get: function () {
                    return uniforms.gamma.value;
                },
                set: function (v) {
                    uniforms.gamma.value = v;
                }
            },
            contrast: {
                get: function () {
                    return uniforms.contrast.value;
                },
                set: function (v) {
                    uniforms.contrast.value = v;
                }
            },
            brightness: {
                get: function () {
                    return uniforms.brightness.value;
                },
                set: function (v) {
                    uniforms.brightness.value = v;
                }
            },
            dispersion: {
                get: function () {
                    return uniforms.dispersion.value;
                },
                set: function (v) {
                    uniforms.dispersion.value = v;
                    if (v !== 0) {
                        this.defines.DISPERSION = '';
                    }
                    else {
                        delete this.defines.DISPERSION;
                    }
                }
            },
            tracingOpacity: {
                get: function () {
                    return uniforms.tracingOpacity.value;
                },
                set: function (v) {
                    uniforms.tracingOpacity.value = v;
                }
            },
            inverseModelMatrix: {
                get: function () {
                    return uniforms.inverseModelMatrix.value;
                },
                set: function (v) {
                    uniforms.inverseModelMatrix.value = v;
                }
            },
            inverseTransposeModelMatrix: {
                get: function () {
                    return uniforms.inverseTransposeModelMatrix.value;
                },
                set: function (v) {
                    uniforms.inverseTransposeModelMatrix.value = v;
                }
            }
        });
        this.refractionIndex = params.refractionIndex || 2.4;
        this.impurityMap = params.impurityMap || null;
        this.impurityScale = params.impurityScale || 1;
        this.colorTransferBegin.copy(params.colorTransferBegin || new THREE.Color(0xffffff));
        this.colorTransferEnd.copy(params.colorTransferEnd || new THREE.Color(0xffffff));
        this.center.copy(params.center || new THREE.Vector3(0, 0, 0));
        this.tracingDepth = params.tracingDepth || 5;
        this.radius = params.radius || 1;
        this.sphericalNormalMap = params.sphericalNormalMap || null;
        this.gamma = params.gamma || 1;
        this.contrast = params.contrast || 1;
        this.brightness = params.brightness || 0;
        this.dispersion = params.dispersion || 0;
        this.tracingOpacity = params.tracingOpacity || 0;
        this.inverseModelMatrix = params.inverseModelMatrix || new THREE.Matrix4();
        this.inverseTransposeModelMatrix = params.inverseTransposeModelMatrix || new THREE.Matrix3();
        this.setValues(params);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    copy(source) {
        super.copy(source);
        this.refractionIndex = source.refractionIndex;
        this.impurityMap = source.impurityMap;
        this.impurityScale = source.impurityScale;
        this.colorTransferBegin.copy(source.colorTransferBegin);
        this.colorTransferEnd.copy(source.colorTransferEnd);
        this.center.copy(source.center);
        this.tracingDepth = source.tracingDepth;
        this.radius = source.radius;
        this.sphericalNormalMap = source.sphericalNormalMap;
        this.gamma = source.gamma;
        this.contrast = source.contrast;
        this.brightness = source.brightness;
        this.dispersion = source.dispersion;
        this.tracingOpacity = source.tracingOpacity;
        this.inverseModelMatrix = source.inverseModelMatrix;
        this.inverseTransposeModelMatrix = source.inverseTransposeModelMatrix;
        return this;
    }
}
exports.GemMaterial = GemMaterial;
//# sourceMappingURL=GemMaterial.js.map