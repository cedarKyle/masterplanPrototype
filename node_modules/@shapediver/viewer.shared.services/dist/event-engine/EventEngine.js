"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEngine = void 0;
const tsyringe_1 = require("tsyringe");
const EventTypes_1 = require("./EventTypes");
const UuidGenerator_1 = require("../uuid-generator/UuidGenerator");
const Logger_1 = require("../logger/Logger");
let EventEngine = class EventEngine {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor() {
        // #region Properties (2)
        this._uuidGenerator = tsyringe_1.container.resolve(UuidGenerator_1.UuidGenerator);
        this._logger = tsyringe_1.container.resolve(Logger_1.Logger);
        this._eventListeners = {};
        for (const type in EventTypes_1.EVENTTYPE) {
            const subEventType = EventTypes_1.EVENTTYPE[type];
            this._eventListeners[type.toLowerCase()] = [];
            for (const subtype in subEventType) {
                this._eventListeners[subEventType[subtype]] = [];
            }
        }
    }
    // #endregion Constructors (1)
    convertTypeToString(type) {
        let typeString = '';
        if (typeof type === 'string')
            typeString = type;
        for (const mainType in EventTypes_1.EVENTTYPE)
            if (type === EventTypes_1.EVENTTYPE[mainType])
                typeString = mainType.toLowerCase();
        if (!typeString || !this._eventListeners[typeString]) {
            this._logger.warn(Logger_1.LOGGING_TOPIC.GENERAL, 'EventEngine.convertTypeToString: No valid type provided.');
            return '';
        }
        return typeString;
    }
    // #region Public Methods (3)
    /**
     * Adds a listener that listenes to the provided type. If no valid type is specified, an error is thrown.
     *
     * @param type the type of the event
     * @param cb the callback that should be called
     * @returns an unique token to be able to remove the listener
     */
    addListener(type, cb) {
        var _a;
        const typeString = this.convertTypeToString(type);
        if (!typeString)
            return '';
        const token = this._uuidGenerator.create();
        (_a = this._eventListeners[typeString]) === null || _a === void 0 ? void 0 : _a.push({ token, cb });
        return token;
    }
    /**
     * Emits the event to all callbacks that listen to the type.
     *
     * @param type the type of the event
     * @param event the event to emit
     */
    emitEvent(type, event) {
        const typeString = this.convertTypeToString(type);
        if (this._eventListeners[typeString] && this._eventListeners[typeString].length !== 0)
            for (let i = 0; i < this._eventListeners[typeString].length; i++)
                this._eventListeners[typeString][i].cb(event);
        if (typeString.includes('.'))
            this.emitEvent(typeString.substr(0, typeString.indexOf('.')), event);
    }
    /**
     * Removes a listener with the specified token.
     *
     * @param token the token of the listener
     * @returns result of the targeted operation
     */
    removeListener(token) {
        for (const type in EventTypes_1.EVENTTYPE) {
            const subEventType = EventTypes_1.EVENTTYPE[type];
            const typeLowerCase = type.toLowerCase();
            for (let i = 0; i < this._eventListeners[typeLowerCase].length; i++) {
                if (this._eventListeners[typeLowerCase][i].token === token) {
                    this._eventListeners[typeLowerCase].splice(i, 1);
                    return true;
                }
            }
            for (const subtype in subEventType) {
                for (let i = 0; i < this._eventListeners[subEventType[subtype]].length; i++) {
                    if (this._eventListeners[subEventType[subtype]][i].token === token) {
                        this._eventListeners[subEventType[subtype]].splice(i, 1);
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
EventEngine = __decorate([
    (0, tsyringe_1.singleton)(),
    __metadata("design:paramtypes", [])
], EventEngine);
exports.EventEngine = EventEngine;
//# sourceMappingURL=EventEngine.js.map