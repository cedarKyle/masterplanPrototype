"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = void 0;
const gl_matrix_1 = require("gl-matrix");
const tinycolor_1 = require("@ctrl/tinycolor");
const tsyringe_1 = require("tsyringe");
const HttpClient_1 = require("../http-client/HttpClient");
let Converter = class Converter {
    constructor() {
        this._httpClient = tsyringe_1.container.resolve(HttpClient_1.HttpClient);
    }
    tinyColorToString(color) {
        return color.toHex8String();
    }
    /**
     * @param color
     * @param defColor
     */
    toHex8Color(color, defColorString = '#00fff7') {
        const c = this.toColor(color, defColorString);
        const tColor = new tinycolor_1.TinyColor(c);
        const cH8 = tColor.toHex8String();
        return cH8.replace('#', '0x');
    }
    toColorArray(color) {
        const tColor = new tinycolor_1.TinyColor(color);
        const rgb = tColor.toRgb();
        return [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];
    }
    toAlpha(color) {
        const c = this.toColor(color);
        if (c.length <= 8)
            return 1;
        return parseInt(c.slice(c.length - 2, c.length), 16) / 255;
    }
    toThreeJsColorInput(color) {
        const c = this.toColor(color);
        return c.slice(0, c.length - 2);
    }
    processSVG(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield new Promise((resolve, _) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
            data = data.replace('data:image/svg+xml;base64,', '');
            data = atob(data);
            let svgC = document.createElement('DIV');
            svgC.id = 'svgc';
            svgC.innerHTML = data;
            // now we can access the svg element as a DOM object
            let svgE = svgC.getElementsByTagName('svg');
            let childImageURIs = [];
            let styleURIs = [];
            // collect image urls
            for (let i = 0; i < svgE.length; ++i) {
                for (let j = 0; j < 2; ++j) {
                    let childImages = svgE[i].getElementsByTagName(['image', 'img'][j]);
                    for (let k = 0; k < childImages.length; ++k) {
                        if (childImages[k].href.baseVal.substring(0, 5) != 'data:') {
                            childImageURIs.push(childImages[k].href.baseVal);
                        }
                    }
                }
                // collect potential font definitions
                // we assume styles are imported using the following syntax:
                // @import url(CSS_URL);
                let styleElements = svgE[i].getElementsByTagName('style');
                for (let j = 0; j < styleElements.length; ++j) {
                    let regex = /@import\x20url\(\s*(.*?)\s*\);/g;
                    let m;
                    while ((m = regex.exec(styleElements[j].innerHTML)) !== null) {
                        styleURIs.push(m[1]);
                    }
                    // make unique
                    styleURIs = styleURIs.filter(function (value, index, self) {
                        return self.indexOf(value) === index;
                    });
                }
            }
            // creating a promise for each image which needs to be converted to a data URI
            let replacementPromises = [];
            let createImagePromise = (uri) => __awaiter(this, void 0, void 0, function* () {
                if (uri.length > 0) {
                    const response = yield this._httpClient.loadTexture(uri);
                    let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;
                    let biStr = []; //new Array(i);
                    while (i--)
                        biStr[i] = String.fromCharCode(uInt8Array[i]);
                    let base64Data = window.btoa(biStr.join(''));
                    let imgDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;
                    // replace url in SVG string
                    // CAUTION theoretically this could cause unwanted replacements
                    data = data.replace(uri, imgDataUrl);
                }
            });
            for (let i = 0; i < childImageURIs.length; ++i)
                replacementPromises.push(createImagePromise(childImageURIs[i]));
            // now we create promises for the google fonts to be imported
            let createStylePromise = (styleUrl) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this._httpClient.get(styleUrl, { responseType: 'text' });
                let cssString = response.data;
                // we assume that fonts are imported using the following syntax:
                // url(FONT_URI);
                let fontURLs = [];
                let regex = /url\(\s*(.*?)\s*\)/g;
                let m;
                while ((m = regex.exec(cssString)) !== null) {
                    fontURLs.push(m[1]);
                }
                let fontPromises = [];
                let createFontPromise = (fUrl) => __awaiter(this, void 0, void 0, function* () {
                    const response = yield this._httpClient.get(fUrl, { responseType: 'arraybuffer' });
                    let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;
                    let biStr = []; //new Array(i);
                    while (i--)
                        biStr[i] = String.fromCharCode(uInt8Array[i]);
                    let base64Data = window.btoa(biStr.join(''));
                    let fontDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;
                    if (fUrl.length > 0)
                        cssString = cssString.replace(fUrl, fontDataUrl);
                });
                for (let j = 0; j < fontURLs.length; ++j)
                    fontPromises.push(createFontPromise(fontURLs[j]));
                yield Promise.all(fontPromises);
                data = data.replace('@import url(' + styleUrl + ');', cssString);
            });
            for (let i = 0; i < styleURIs.length; ++i)
                replacementPromises.push(createStylePromise(styleURIs[i]));
            yield Promise.all(replacementPromises);
            let du = 'data:image/svg+xml,' + encodeURIComponent(data);
            let img = new Image(); // same as document.createElement('img')
            img.crossOrigin = 'Anonymous';
            const promise = new Promise(resolve => {
                img.onload = () => resolve();
            });
            img.src = du;
            yield promise;
            return img;
        });
    }
    /**
     * This color converter is mostly left 'as-is' from viewer v2.
     * I didn't want to break something that works.
     *
     * @param color
     * @param defColor
     */
    toColor(color, defColorString = '#00fff7') {
        if (!color || color === 'default')
            return defColorString;
        if (color.constructor === Float32Array)
            color = Array.from(color);
        const tColor = new tinycolor_1.TinyColor(color);
        if (color instanceof tinycolor_1.TinyColor)
            return this.tinyColorToString(tColor);
        // check if we got a number
        if (typeof color === 'number') {
            let cs = color.toString(16);
            let cl = cs.length;
            if (cl < 3)
                cs = cs.padStart(3, '0');
            else if (cl < 6)
                cs = cs.padStart(6, '0');
            else if (cl < 8)
                cs = cs.padEnd(8, '0');
            let tc = new tinycolor_1.TinyColor(cs);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check if the input is a THREE.Color
        if (color.isColor && typeof color.getHexString == 'function') {
            let tc = new tinycolor_1.TinyColor(color.getHexString());
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check for array of numbers
        if (Array.isArray(color) && (color.length == 3 || color.length == 4)) {
            let isRGBArray = true;
            for (let i = 0; i < 3; ++i) {
                color[i] = parseFloat(color[i]);
                if (isNaN(color[i])) {
                    isRGBArray = false;
                }
            }
            if (!isRGBArray)
                return defColorString;
            let tc = new tinycolor_1.TinyColor({
                r: Math.max(0, Math.min(color[0], 255)),
                g: Math.max(0, Math.min(color[1], 255)),
                b: Math.max(0, Math.min(color[2], 255))
            });
            if (color.length == 4) {
                let a = parseFloat(color[3]);
                if (!isNaN(a)) {
                    tc.setAlpha(Math.max(0, Math.min(a, 255)) / 255);
                }
            }
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // if we got something other than a string, check if
        // tinycolor can work with it
        if (typeof color !== 'string') {
            let tc = new tinycolor_1.TinyColor(color);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // tinycolor doesn't like 0x
        let tmpColor = color.replace('0x', '#');
        // if we got no alpha value, add full opacity
        if (tmpColor.match(/^#[a-f0-9]{6}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor + 'ff');
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // standard case
        if (tmpColor.match(/^#[a-f0-9]{8}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // correct number which have the alpha value defined as a single hex digit
        if (tmpColor.match(/^#[a-f0-9]{7}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor.slice(0, 7) + '0' + tmpColor.slice(-1));
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check if tinycolor understands the string
        let tc = new tinycolor_1.TinyColor(tmpColor);
        return tc.isValid ? this.tinyColorToString(tc) : defColorString;
    }
    toVec3(point) {
        if (Array.isArray(point) && point.length >= 3 && typeof point[0] === 'number' && typeof point[1] === 'number' && typeof point[2] === 'number')
            return gl_matrix_1.vec3.fromValues(point[0], point[1], point[2]);
        if (((point.x || point.x === 0) && typeof point.x === 'number') && ((point.y || point.y === 0) && typeof point.y === 'number') && ((point.z || point.z === 0) && typeof point.z === 'number'))
            return gl_matrix_1.vec3.fromValues(point.x, point.y, point.z);
        if (((point.X || point.X === 0) && typeof point.X === 'number') && ((point.Y || point.Y === 0) && typeof point.Y === 'number') && ((point.Z || point.Z === 0) && typeof point.Z === 'number'))
            return gl_matrix_1.vec3.fromValues(point.X, point.Y, point.Z);
        return gl_matrix_1.vec3.create();
    }
    responseToImage(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const arrayBufferView = new Uint8Array(response.data);
            const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });
            if (response.headers['content-type'] === 'image/svg+xml') {
                const img = yield this.processSVG(blob);
                return img;
            }
            else {
                const img = new Image();
                const promise = new Promise(resolve => {
                    img.onload = () => resolve();
                });
                img.crossOrigin = "anonymous";
                img.src = URL.createObjectURL(blob);
                yield promise;
                return img;
            }
        });
    }
};
Converter = __decorate([
    (0, tsyringe_1.singleton)()
], Converter);
exports.Converter = Converter;
//# sourceMappingURL=Converter.js.map