"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineTextures = void 0;
const THREE = __importStar(require("three"));
let mergeShader;
let quadCamera;
let quadScene;
let quad;
let renderer;
const createThreeJsUtils = () => {
    mergeShader = new THREE.ShaderMaterial({
        uniforms: {
            tRed: { value: null },
            activeRed: { value: false },
            defaultRed: { value: 1.0 },
            tGreen: { value: null },
            activeGreen: { value: false },
            defaultGreen: { value: 1.0 },
            tBlue: { value: null },
            activeBlue: { value: false },
            defaultBlue: { value: 1.0 },
        },
        vertexShader: `// @author Michael Oppitz 
    
        uniform sampler2D tRed;
        uniform bool activeRed;
        uniform float defaultRed;
        
        uniform sampler2D tGreen;		
        uniform bool activeGreen;
        uniform float defaultGreen;
        
        uniform sampler2D tBlue;		
        uniform bool activeBlue;
        uniform float defaultBlue;
    
        varying vec2 vUv;
        
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
        fragmentShader: `// @author Michael Oppitz 
    
        uniform sampler2D tRed;
        uniform bool activeRed;
        uniform float defaultRed;
        
        uniform sampler2D tGreen;		
        uniform bool activeGreen;
        uniform float defaultGreen;
        
        uniform sampler2D tBlue;		
        uniform bool activeBlue;
        uniform float defaultBlue;
        
        varying vec2 vUv;
        
        void main() {
            vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);
    
            if(activeRed == true) {
                outColor.r = texture2D(tRed, vUv).r;
            } else {
                outColor.r = defaultRed;
            }
        
            if(activeGreen == true) {
                outColor.g = texture2D(tGreen, vUv).g;
            } else {
                outColor.g = defaultGreen;
            }
        
            if(activeBlue == true) {
                outColor.b = texture2D(tBlue, vUv).b;
            } else {
                outColor.b = defaultBlue;
            }
        
            gl_FragColor = outColor;
        }`
    });
    quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    quadScene = new THREE.Scene();
    quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mergeShader);
    quadScene.add(quad);
    renderer = new THREE.WebGLRenderer();
};
const combineTextures = (red, green, blue) => __awaiter(void 0, void 0, void 0, function* () {
    if (!red && !green && !blue)
        throw new Error('No maps supplied.');
    if (!renderer)
        createThreeJsUtils();
    let width = 0, height = 0;
    const textures = [red, green, blue];
    for (let t of textures) {
        if (t) {
            if (width === 0 && height === 0) {
                width = t.width;
                height = t.height;
            }
            else if (t.width !== width && t.height !== height) {
                throw new Error('Maps have different sizes. Combining not supported.');
            }
        }
    }
    if (red) {
        const redTexture = new THREE.Texture(red);
        redTexture.needsUpdate = true;
        mergeShader.uniforms.tRed.value = redTexture;
        mergeShader.uniforms.activeRed.value = true;
    }
    else {
        mergeShader.uniforms.activeRed.value = false;
    }
    if (green) {
        const greenTexture = new THREE.Texture(green);
        greenTexture.needsUpdate = true;
        mergeShader.uniforms.tGreen.value = greenTexture;
        mergeShader.uniforms.activeGreen.value = true;
    }
    else {
        mergeShader.uniforms.activeGreen.value = false;
    }
    if (blue) {
        const blueTexture = new THREE.Texture(blue);
        blueTexture.needsUpdate = true;
        mergeShader.uniforms.tBlue.value = blueTexture;
        mergeShader.uniforms.activeBlue.value = true;
    }
    else {
        mergeShader.uniforms.activeBlue.value = false;
    }
    // The different render targets that are used by the passes
    const renderTarget = new THREE.WebGLRenderTarget(width, height, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    });
    renderTarget.texture.name = 'target.rt';
    renderer.setRenderTarget(renderTarget);
    renderer.render(quadScene, quadCamera);
    const buffer = new Uint8ClampedArray(4 * width * height);
    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);
    let imageData = new ImageData(buffer, width, height);
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    ctx.putImageData(imageData, 0, 0);
    const imageOut = new Image();
    const promise = new Promise(resolve => {
        imageOut.onload = () => resolve();
    });
    imageOut.crossOrigin = "anonymous";
    imageOut.src = canvas.toDataURL("image/jpeg", 1.0);
    yield promise;
    return imageOut;
});
exports.combineTextures = combineTextures;
//# sourceMappingURL=index.js.map