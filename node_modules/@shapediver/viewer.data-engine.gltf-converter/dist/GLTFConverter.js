"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLTFConverter = exports.GLTF_EXTENSIONS = void 0;
const viewer_shared_build_data_1 = require("@shapediver/viewer.shared.build-data");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_data_engine_shared_types_1 = require("@shapediver/viewer.data-engine.shared-types");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_utils_texture_unifier_1 = require("@shapediver/viewer.utils.texture-unifier");
var GLTF_EXTENSIONS;
(function (GLTF_EXTENSIONS) {
    GLTF_EXTENSIONS["KHR_BINARY_GLTF"] = "KHR_binary_glTF";
    GLTF_EXTENSIONS["KHR_MATERIALS_PBRSPECULARGLOSSINESS"] = "KHR_materials_pbrSpecularGlossiness";
    GLTF_EXTENSIONS["KHR_MATERIALS_UNLIT"] = "KHR_materials_unlit";
})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));
let GLTFConverter = class GLTFConverter {
    // #endregion Properties (17)
    // #region Constructors (1)
    constructor() {
        // #region Properties (17)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._globalTransformationInverse = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._animations = [];
        this._buffers = [];
        this._byteOffset = 0;
        this._content = {
            asset: {
                copyright: '2021 (c) ShapeDiver',
                generator: 'ShapeDiverViewer@' + viewer_shared_build_data_1.build_data.build_version,
                version: '2.0',
                extensions: {}
            },
        };
        this._convertForAR = false;
        this._extensionsRequired = [];
        this._extensionsUsed = [];
        this._imageCache = {};
        this._nodes = [];
        this._promises = [];
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    convert(node, convertForAR = false, viewport) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this._convertForAR = convertForAR;
            this._viewport = viewport;
            const originalParent = node.parent;
            const sceneNode = new viewer_shared_node_tree_1.TreeNode('ShapeDiverRootNode');
            sceneNode.addChild(node);
            const sceneDef = {
                name: sceneNode.name,
                nodes: []
            };
            const nodeMatrix = gl_matrix_1.mat4.clone(node.nodeMatrix);
            const globalTransformationInverseId = this._uuidGenerator.create();
            node.addTransformation({
                id: globalTransformationInverseId,
                matrix: this._globalTransformationInverse,
            });
            const translationMatrixId = this._uuidGenerator.create();
            if (convertForAR) {
                // add translation matrix to scene tree node
                const bb = node.boundingBox.clone().applyMatrix(gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), nodeMatrix));
                const center = bb.boundingSphere.center;
                let translationMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(center[0], center[1], center[2]), gl_matrix_1.vec3.fromValues(-1, -1, -1)));
                node.addTransformation({ id: translationMatrixId, matrix: translationMatrix });
            }
            if (this._viewport) {
                if (this._viewport && node.excludeViewports.includes(this._viewport) === false && (node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._viewport)) === false) {
                    (_a = sceneDef.nodes) === null || _a === void 0 ? void 0 : _a.push(this.convertNode(node));
                }
            }
            else {
                (_b = sceneDef.nodes) === null || _b === void 0 ? void 0 : _b.push(this.convertNode(node));
            }
            for (let i = 0; i < node.transformations.length; i++)
                if (node.transformations[i].id === globalTransformationInverseId)
                    node.removeTransformation(node.transformations[i]);
            if (convertForAR) {
                // remove translation the matrix
                for (let i = 0; i < node.transformations.length; i++)
                    if (node.transformations[i].id === translationMatrixId)
                        node.removeTransformation(node.transformations[i]);
            }
            this._content.scenes = [];
            this._content.scenes.push(sceneDef);
            this.convertAnimations();
            // Declare extensions.
            if (this._extensionsUsed.length > 0)
                this._content.extensionsUsed = this._extensionsUsed;
            if (this._extensionsRequired.length > 0)
                this._content.extensionsRequired = this._extensionsRequired;
            let promisesLength = 0;
            while (promisesLength !== this._promises.length) {
                promisesLength = this._promises.length;
                yield Promise.all(this._promises);
                yield new Promise(resolve => setTimeout(resolve, 0));
            }
            // Merge buffers.
            const blob = new Blob(this._buffers, { type: 'application/octet-stream' });
            if (originalParent)
                originalParent.addChild(node);
            // Update byte length of the single buffer.
            if (this._content.buffers && this._content.buffers.length > 0)
                this._content.buffers[0].byteLength = blob.size;
            return new Promise(resolve => {
                // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification
                const reader = new window.FileReader();
                reader.readAsArrayBuffer(blob);
                reader.onloadend = () => {
                    // Binary chunk.
                    const binaryChunk = this.getPaddedArrayBuffer(reader.result);
                    const binaryChunkPrefix = new DataView(new ArrayBuffer(8));
                    binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
                    binaryChunkPrefix.setUint32(4, 0x004E4942, true);
                    // JSON chunk.
                    const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(this._content)), 0x20);
                    const jsonChunkPrefix = new DataView(new ArrayBuffer(8));
                    jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
                    jsonChunkPrefix.setUint32(4, 0x4E4F534A, true);
                    // GLB header.
                    const header = new ArrayBuffer(12);
                    const headerView = new DataView(header);
                    headerView.setUint32(0, 0x46546C67, true);
                    headerView.setUint32(4, 2, true);
                    const totalByteLength = 12
                        + jsonChunkPrefix.byteLength + jsonChunk.byteLength
                        + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
                    headerView.setUint32(8, totalByteLength, true);
                    const glbBlob = new Blob([
                        header,
                        jsonChunkPrefix,
                        jsonChunk,
                        binaryChunkPrefix,
                        binaryChunk
                    ], { type: 'application/octet-stream' });
                    const glbReader = new window.FileReader();
                    glbReader.readAsArrayBuffer(glbBlob);
                    glbReader.onloadend = () => {
                        resolve(glbReader.result);
                    };
                };
            });
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (18)
    convertAccessor(data) {
        if (!this._content.accessors)
            this._content.accessors = [];
        const bufferView = this.convertBufferView(data);
        const minMax = this.getMinMax(data);
        const accessorDef = {
            bufferView: bufferView,
            byteOffset: 0,
            componentType: this.getComponentType(data.array),
            normalized: data.normalized,
            count: +data.count,
            max: minMax.max,
            min: minMax.min,
            type: this.getType(data.itemSize),
            // sparse: { // TODO
            //     count: number,
            //     indices: {
            //         bufferView: number,
            //         byteOffset?: number,
            //         componentType: number,
            //         extensions?: { [id: string]: any },
            //         extras?: any
            //     },
            //     values: {
            //         bufferView: number,
            //         byteOffset?: number,
            //         extensions?: { [id: string]: any },
            //         extras?: any
            //     },
            //     extensions?: { [id: string]: any },
            //     extras?: any
            // },
        };
        this._content.accessors.push(accessorDef);
        return this._content.accessors.length - 1;
    }
    convertAnimations() {
        var _a;
        if (!this._content.animations && this._animations.length > 0)
            this._content.animations = [];
        for (let i = 0; i < this._animations.length; i++) {
            const animation = this._animations[i];
            const animationDef = {
                name: animation.name || 'animation_' + i,
                channels: [],
                samplers: []
            };
            for (let j = 0; j < animation.tracks.length; j++) {
                const track = animation.tracks[j];
                const value = this._nodes.find(a => a.node === track.node);
                if (!value)
                    continue;
                const inputMin = Math.min(...track.times);
                const inputMax = Math.max(...track.times);
                const inputData = new viewer_shared_types_1.AttributeData(new Float32Array(track.times), 1, 4, 0, 4, false, track.times.length, [inputMin], [inputMax]);
                const outputMin = [];
                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 0)));
                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 1)));
                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 2)));
                if (track.path === 'rotation') {
                    outputMin.push(Math.min(...track.values.filter((s, i) => i % 4 === 3)));
                }
                const outputMax = [];
                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 0)));
                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 1)));
                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 2)));
                if (track.path === 'rotation') {
                    outputMax.push(Math.max(...track.values.filter((s, i) => i % 4 === 3)));
                }
                const outputData = new viewer_shared_types_1.AttributeData(new Float32Array(track.values), track.path === 'rotation' ? 4 : 3, //itemSize
                track.path === 'rotation' ? 16 : 12, //itemBytes
                0, 4, false, track.times.length, outputMin, outputMax, track.path === 'rotation' ? 16 : 12);
                const samplerDef = {
                    input: this.convertAccessor(inputData),
                    output: this.convertAccessor(outputData),
                    interpolation: track.interpolation.toUpperCase()
                };
                animationDef.samplers.push(samplerDef);
                const channelDef = {
                    sampler: animationDef.samplers.length - 1,
                    target: {
                        node: value.id,
                        path: track.path
                    }
                };
                animationDef.channels.push(channelDef);
            }
            (_a = this._content.animations) === null || _a === void 0 ? void 0 : _a.push(animationDef);
        }
    }
    convertBuffer(buffer) {
        if (!this._content.buffers)
            this._content.buffers = [];
        if (this._content.buffers.length === 0)
            this._content.buffers = [{ byteLength: 0 }];
        this._buffers.push(buffer);
        return 0;
    }
    convertBufferView(data) {
        if (!this._content.bufferViews)
            this._content.bufferViews = [];
        let componentTypeNumber = this.getComponentType(data.array);
        let componentSize = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTSIZE_V2[componentTypeNumber];
        const byteLength = Math.ceil(data.count * data.itemSize * componentSize / 4) * 4;
        const dataView = new DataView(new ArrayBuffer(byteLength));
        let offset = 0;
        for (let i = 0; i < data.count; i++) {
            for (let a = 0; a < data.itemSize; a++) {
                let value = 0;
                if (data.itemSize > 4) {
                    // no support for interleaved data for itemSize > 4
                    value = data.array[i * data.itemSize + a];
                }
                else {
                    if (a === 0)
                        value = data.array[i * data.itemSize];
                    else if (a === 1)
                        value = data.array[i * data.itemSize + 1];
                    else if (a === 2)
                        value = data.array[i * data.itemSize + 2];
                    else if (a === 3)
                        value = data.array[i * data.itemSize + 3];
                }
                if (data.array instanceof Float32Array) {
                    dataView.setFloat32(offset, value, true);
                }
                else if (data.array instanceof Uint32Array) {
                    dataView.setUint32(offset, value, true);
                }
                else if (data.array instanceof Uint16Array) {
                    dataView.setUint16(offset, value, true);
                }
                else if (data.array instanceof Int16Array) {
                    dataView.setInt16(offset, value, true);
                }
                else if (data.array instanceof Uint8Array) {
                    dataView.setUint8(offset, value);
                }
                else if (data.array instanceof Int8Array) {
                    dataView.setInt8(offset, value);
                }
                offset += componentSize;
            }
        }
        const bufferViewDef = {
            buffer: this.convertBuffer(dataView.buffer),
            byteOffset: this._byteOffset,
            byteLength: byteLength
        };
        this._byteOffset += byteLength;
        this._content.bufferViews.push(bufferViewDef);
        return this._content.bufferViews.length - 1;
    }
    convertBufferViewImage(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.bufferViews)
                this._content.bufferViews = [];
            return new Promise((resolve) => {
                const reader = new window.FileReader();
                reader.readAsArrayBuffer(blob);
                reader.onloadend = () => {
                    const buffer = this.getPaddedArrayBuffer(reader.result);
                    const bufferViewDef = {
                        buffer: this.convertBuffer(buffer),
                        byteOffset: this._byteOffset,
                        byteLength: buffer.byteLength
                    };
                    this._byteOffset += buffer.byteLength;
                    this._content.bufferViews.push(bufferViewDef);
                    resolve(this._content.bufferViews.length - 1);
                };
            });
        });
    }
    convertImage(data) {
        if (!this._content.images)
            this._content.images = [];
        if (this._imageCache[data.image.src])
            return this._imageCache[data.image.src];
        const imageDef = {};
        const canvas = document.createElement('canvas');
        canvas.width = data.image.width;
        canvas.height = data.image.height;
        const ctx = canvas.getContext('2d');
        if (data.flipY) {
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
        }
        let mimeType = 'image/png';
        if (data.image.src.endsWith('.jpg') || data.image.src.includes('image/jpeg'))
            mimeType = 'image/jpeg';
        imageDef.mimeType = mimeType;
        const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;
        if (DATA_URI_REGEX.test(data.image.src)) {
            const byteString = atob(data.image.src.split(',')[1]);
            const mimeType = data.image.src.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++)
                ia[i] = byteString.charCodeAt(i);
            const blob = new Blob([ab], { type: mimeType });
            this._promises.push(new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const bufferViewIndex = yield this.convertBufferViewImage(blob);
                imageDef.bufferView = bufferViewIndex;
                resolve();
            })));
        }
        else {
            ctx.drawImage(data.image, 0, 0, canvas.width, canvas.height);
            this._promises.push(new Promise((resolve) => {
                canvas.toBlob((blob) => __awaiter(this, void 0, void 0, function* () {
                    const bufferViewIndex = yield this.convertBufferViewImage(blob);
                    imageDef.bufferView = bufferViewIndex;
                    resolve();
                }), mimeType);
            }));
        }
        this._content.images.push(imageDef);
        this._imageCache[data.image.src] = this._content.images.length - 1;
        return this._content.images.length - 1;
    }
    convertMaterial(data, includeMaps = true) {
        if (!this._content.materials)
            this._content.materials = [];
        const materialDef = {
            name: data.id,
            pbrMetallicRoughness: {}
        };
        if (data instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {
            if (!this._extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness'))
                this._extensionsUsed.push('KHR_materials_pbrSpecularGlossiness');
            if (!this._extensionsRequired.includes('KHR_materials_pbrSpecularGlossiness'))
                this._extensionsRequired.push('KHR_materials_pbrSpecularGlossiness');
            const ext = {};
            ext.diffuseFactor = this._converter.toColorArray(data.color);
            ext.diffuseFactor[3] = data.opacity;
            if (data.map && includeMaps)
                ext.diffuseTexture = { index: this.convertTexture(data.map) };
            ext.specularFactor = this._converter.toColorArray(data.specular);
            ext.glossinessFactor = data.glossiness;
            if (data.specularGlossinessMap && includeMaps)
                ext.specularGlossinessTexture = { index: this.convertTexture(data.specularGlossinessMap) };
            materialDef.extensions = {
                KHR_materials_pbrSpecularGlossiness: ext
            };
        }
        else if (data instanceof viewer_shared_types_1.MaterialUnlitData) {
            if (!this._extensionsUsed.includes('KHR_materials_unlit'))
                this._extensionsUsed.push('KHR_materials_unlit');
            if (!this._extensionsRequired.includes('KHR_materials_unlit'))
                this._extensionsRequired.push('KHR_materials_unlit');
            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(data.color);
            materialDef.pbrMetallicRoughness.baseColorFactor[3] = data.opacity;
            if (data.map && includeMaps)
                materialDef.pbrMetallicRoughness.baseColorTexture = { index: this.convertTexture(data.map) };
            materialDef.extensions = {
                KHR_materials_unlit: {}
            };
        }
        else {
            const standardMaterialData = data;
            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(standardMaterialData.color);
            materialDef.pbrMetallicRoughness.baseColorFactor[3] = standardMaterialData.opacity;
            if (standardMaterialData.map && includeMaps)
                materialDef.pbrMetallicRoughness.baseColorTexture = { index: this.convertTexture(standardMaterialData.map) };
            materialDef.pbrMetallicRoughness.metallicFactor = standardMaterialData.metalnessMap ? 1 : standardMaterialData.metalness;
            materialDef.pbrMetallicRoughness.roughnessFactor = standardMaterialData.roughnessMap ? 1 : standardMaterialData.roughness;
            if (standardMaterialData.metalnessRoughnessMap && includeMaps) {
                materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: this.convertTexture(standardMaterialData.metalnessRoughnessMap) };
            }
            else if ((standardMaterialData.metalnessMap || standardMaterialData.roughnessMap) && includeMaps) {
                this._promises.push(new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    const imageData = yield (0, viewer_utils_texture_unifier_1.combineTextures)(undefined, standardMaterialData.roughnessMap ? standardMaterialData.roughnessMap.image : undefined, standardMaterialData.metalnessMap ? standardMaterialData.metalnessMap.image : undefined);
                    const m = (standardMaterialData.roughnessMap || standardMaterialData.metalnessMap);
                    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: this.convertTexture(new viewer_shared_types_1.MapData(imageData, m.wrapS, m.wrapT, m.minFilter, m.magFilter, m.center, m.color, m.offset, m.repeat, m.rotation, m.flipY)) };
                    resolve();
                })));
            }
        }
        if (data.normalMap && includeMaps)
            materialDef.normalTexture = { index: this.convertTexture(data.normalMap) };
        if (data.aoMap && includeMaps)
            materialDef.occlusionTexture = { index: this.convertTexture(data.aoMap) };
        if (data.emissiveMap && includeMaps)
            materialDef.emissiveTexture = { index: this.convertTexture(data.emissiveMap) };
        if (data.emissiveness)
            materialDef.emissiveFactor = this._converter.toColorArray(data.emissiveness);
        materialDef.alphaMode = data.alphaMode.toUpperCase();
        if (data.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.MASK)
            materialDef.alphaCutoff = data.alphaCutoff;
        materialDef.doubleSided = data.side === viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
        this._content.materials.push(materialDef);
        return this._content.materials.length - 1;
    }
    convertMesh(data) {
        var _a;
        if (!this._content.meshes)
            this._content.meshes = [];
        const meshDef = {
            primitives: [],
            name: data.id
        };
        (_a = meshDef.primitives) === null || _a === void 0 ? void 0 : _a.push(this.convertPrimitive(data.primitive));
        this._content.meshes.push(meshDef);
        return this._content.meshes.length - 1;
    }
    convertNode(node) {
        var _a;
        if (!this._content.nodes)
            this._content.nodes = [];
        const nodeDef = {
            name: this._convertForAR ? this._uuidGenerator.create() : node.name,
        };
        if (node.transformations.length > 0) {
            let matrix = node.nodeMatrix;
            if (node.nodeMatrix.filter(v => isNaN(v) || v === Infinity || v === -Infinity).length > 0)
                matrix = gl_matrix_1.mat4.create();
            nodeDef.matrix = [matrix[0], matrix[1], matrix[2], matrix[3],
                matrix[4], matrix[5], matrix[6], matrix[7],
                matrix[8], matrix[9], matrix[10], matrix[11],
                matrix[12], matrix[13], matrix[14], matrix[15]];
        }
        for (let i = 0; i < node.data.length; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                if (this._convertForAR) {
                    if (node.data[i].primitive.mode !== viewer_shared_types_1.PRIMITIVE_MODE.POINTS &&
                        node.data[i].primitive.mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINES &&
                        node.data[i].primitive.mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP &&
                        node.data[i].primitive.mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP)
                        nodeDef.mesh = this.convertMesh(node.data[i]);
                }
                else {
                    nodeDef.mesh = this.convertMesh(node.data[i]);
                }
            }
            if (node.data[i] instanceof viewer_shared_types_1.AnimationData)
                this._animations.push(node.data[i]);
        }
        if (node.children.length > 0)
            nodeDef.children = [];
        for (let i = 0; i < node.children.length; i++) {
            if (node.children[i].visible === true) {
                if (this._viewport) {
                    if (node.children[i].excludeViewports.includes(this._viewport))
                        continue;
                    if (node.children[i].restrictViewports.length > 0 && !node.children[i].restrictViewports.includes(this._viewport))
                        continue;
                }
                (_a = nodeDef.children) === null || _a === void 0 ? void 0 : _a.push(this.convertNode(node.children[i]));
            }
        }
        this._content.nodes.push(nodeDef);
        this._nodes.push({
            node,
            id: this._content.nodes.length - 1
        });
        return this._content.nodes.length - 1;
    }
    convertPrimitive(data) {
        const primitiveDef = {
            attributes: {},
            mode: data.mode
        };
        for (let a in data.attributes) {
            if (data.attributes[a].array.length > 0) {
                if (a.includes('COLOR')) {
                    if (data.attributes[a].itemSize % 4 === 0) {
                        primitiveDef.attributes[a] = this.convertAccessor(data.attributes[a]);
                    }
                    else if (data.attributes[a].itemSize % 3 === 0) {
                        const oldAttributeData = data.attributes[a];
                        const newArray = new Float32Array((oldAttributeData.array.length / 3) * 4);
                        let counter = 0;
                        for (let i = 0; i < newArray.length; i += 4) {
                            newArray[i] = oldAttributeData.array[counter] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);
                            newArray[i + 1] = oldAttributeData.array[counter + 1] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);
                            newArray[i + 2] = oldAttributeData.array[counter + 2] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);
                            newArray[i + 3] = 1.0;
                            counter += 3;
                        }
                        primitiveDef.attributes[a] = this.convertAccessor(new viewer_shared_types_1.AttributeData(newArray, 4, 4 * 4, oldAttributeData.byteOffset, 4, oldAttributeData.normalized, oldAttributeData.count, oldAttributeData.min, oldAttributeData.max, oldAttributeData.byteStride));
                    }
                }
                else {
                    primitiveDef.attributes[a] = this.convertAccessor(data.attributes[a]);
                }
            }
        }
        if (data.indices)
            primitiveDef.indices = this.convertAccessor(data.indices);
        if (data.material) {
            const k = Object.keys(primitiveDef.attributes).find(k => k.includes('TEXCOORD'));
            primitiveDef.material = this.convertMaterial(data.material, !!k);
        }
        return primitiveDef;
    }
    convertTexture(data) {
        if (!this._content.textures)
            this._content.textures = [];
        const textureDef = {
            source: this.convertImage(data)
        };
        // TODO samplers
        this._content.textures.push(textureDef);
        return this._content.textures.length - 1;
    }
    getComponentType(array) {
        switch (true) {
            case array instanceof Int8Array:
                return 5120;
            case array instanceof Uint8Array:
                return 5121;
            case array instanceof Int16Array:
                return 5122;
            case array instanceof Uint16Array:
                return 5123;
            case array instanceof Uint32Array:
                return 5125;
            default:
                return 5126;
        }
    }
    getMinMax(data) {
        const output = {
            min: new Array(data.itemSize).fill(Number.POSITIVE_INFINITY),
            max: new Array(data.itemSize).fill(Number.NEGATIVE_INFINITY)
        };
        for (let i = 0; i < data.count; i++) {
            for (let a = 0; a < data.itemSize; a++) {
                let value = 0;
                if (data.itemSize > 4) {
                    // no support for interleaved data for itemSize > 4
                    value = data.array[i * data.itemSize + a];
                }
                else {
                    if (a === 0)
                        value = data.array[i * data.itemSize];
                    else if (a === 1)
                        value = data.array[i * data.itemSize + 1];
                    else if (a === 2)
                        value = data.array[i * data.itemSize + 2];
                    else if (a === 3)
                        value = data.array[i * data.itemSize + 3];
                }
                output.min[a] = Math.min(output.min[a], value);
                output.max[a] = Math.max(output.max[a], value);
            }
        }
        return output;
    }
    getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
        const paddedLength = Math.ceil(arrayBuffer.byteLength / 4) * 4;
        if (paddedLength !== arrayBuffer.byteLength) {
            const array = new Uint8Array(paddedLength);
            array.set(new Uint8Array(arrayBuffer));
            if (paddingByte !== 0) {
                for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
                    array[i] = paddingByte;
                }
            }
            return array.buffer;
        }
        return arrayBuffer;
    }
    getType(itemSize) {
        switch (itemSize) {
            case 1:
                return 'SCALAR';
            case 2:
                return 'VEC2';
            case 3:
                return 'VEC3';
            case 4:
                return 'VEC4';
            case 9:
                return 'MAT3';
            case 18:
                return 'MAT4';
            default:
                return 'VEC3';
        }
    }
    reset() {
        this._animations = [];
        this._buffers = [];
        this._byteOffset = 0;
        this._content = {
            asset: {
                copyright: '2021 (c) ShapeDiver',
                generator: 'ShapeDiverViewer@' + viewer_shared_build_data_1.build_data.build_version,
                version: '2.0',
                extensions: {}
            },
        };
        this._extensionsRequired = [];
        this._extensionsUsed = [];
        this._imageCache = {};
        this._nodes = [];
        this._promises = [];
    }
    stringToArrayBuffer(text) {
        if (window.TextEncoder !== undefined) {
            return new TextEncoder().encode(text).buffer;
        }
        const array = new Uint8Array(new ArrayBuffer(text.length));
        for (let i = 0, il = text.length; i < il; i++) {
            const value = text.charCodeAt(i);
            // Replacing multi-byte character with space(0x20).
            array[i] = value > 0xFF ? 0x20 : value;
        }
        return array.buffer;
    }
};
GLTFConverter = __decorate([
    (0, tsyringe_1.singleton)(),
    __metadata("design:paramtypes", [])
], GLTFConverter);
exports.GLTFConverter = GLTFConverter;
//# sourceMappingURL=GLTFConverter.js.map