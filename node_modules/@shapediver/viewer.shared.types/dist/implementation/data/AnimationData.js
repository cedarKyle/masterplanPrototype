"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnimationData_animate, _AnimationData_animationTime, _AnimationData_duration, _AnimationData_name, _AnimationData_repeat, _AnimationData_start, _AnimationData_started, _AnimationData_tracks, _AnimationData_reset, _AnimationData_nodeIds;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationData = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const gl_matrix_1 = require("gl-matrix");
const GeometryData_1 = require("./GeometryData");
class AnimationData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (8)
    // #region Constructors (1)
    /**
     * Creates a custom data node.
     *
     * @param _data the data as key- value pairs
     * @param id the id
     */
    constructor(name, tracks, start, duration, id) {
        super(id);
        // #region Properties (8)
        _AnimationData_animate.set(this, false);
        _AnimationData_animationTime.set(this, 0);
        _AnimationData_duration.set(this, void 0);
        _AnimationData_name.set(this, void 0);
        _AnimationData_repeat.set(this, false);
        _AnimationData_start.set(this, void 0);
        _AnimationData_started.set(this, false);
        _AnimationData_tracks.set(this, void 0);
        _AnimationData_reset.set(this, true);
        _AnimationData_nodeIds.set(this, []);
        __classPrivateFieldSet(this, _AnimationData_name, name, "f");
        __classPrivateFieldSet(this, _AnimationData_tracks, tracks, "f");
        __classPrivateFieldSet(this, _AnimationData_start, start, "f");
        __classPrivateFieldSet(this, _AnimationData_duration, duration, "f");
    }
    // #endregion Constructors (1)
    // #region Public Accessors (9)
    get animate() {
        return __classPrivateFieldGet(this, _AnimationData_animate, "f");
    }
    get animationTime() {
        return __classPrivateFieldGet(this, _AnimationData_animationTime, "f");
    }
    set animationTime(value) {
        __classPrivateFieldSet(this, _AnimationData_animationTime, value, "f");
    }
    get duration() {
        return __classPrivateFieldGet(this, _AnimationData_duration, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _AnimationData_name, "f");
    }
    get repeat() {
        return __classPrivateFieldGet(this, _AnimationData_repeat, "f");
    }
    set repeat(value) {
        __classPrivateFieldSet(this, _AnimationData_repeat, value, "f");
    }
    get reset() {
        return __classPrivateFieldGet(this, _AnimationData_reset, "f");
    }
    set reset(value) {
        __classPrivateFieldSet(this, _AnimationData_reset, value, "f");
    }
    get start() {
        return __classPrivateFieldGet(this, _AnimationData_start, "f");
    }
    get tracks() {
        return __classPrivateFieldGet(this, _AnimationData_tracks, "f");
    }
    set tracks(value) {
        __classPrivateFieldSet(this, _AnimationData_tracks, value, "f");
    }
    // #endregion Public Accessors (9)
    // #region Public Methods (5)
    /**
     * Clones the scene graph data.
     */
    clone() {
        return new AnimationData(this.name, __classPrivateFieldGet(this, _AnimationData_tracks, "f"), this.start, this.duration, this.id);
    }
    continueAnimation() {
        if (__classPrivateFieldGet(this, _AnimationData_started, "f"))
            __classPrivateFieldSet(this, _AnimationData_animate, true, "f");
    }
    pauseAnimation() {
        if (__classPrivateFieldGet(this, _AnimationData_started, "f"))
            __classPrivateFieldSet(this, _AnimationData_animate, false, "f");
    }
    startAnimation() {
        __classPrivateFieldSet(this, _AnimationData_animationTime, 0, "f");
        __classPrivateFieldSet(this, _AnimationData_animate, true, "f");
        __classPrivateFieldSet(this, _AnimationData_started, true, "f");
        __classPrivateFieldSet(this, _AnimationData_nodeIds, [], "f");
        for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, "f").length; i++) {
            const track = __classPrivateFieldGet(this, _AnimationData_tracks, "f")[i];
            if (__classPrivateFieldGet(this, _AnimationData_nodeIds, "f").includes(track.node.id))
                continue;
            __classPrivateFieldGet(this, _AnimationData_nodeIds, "f").push(track.node.id);
            const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');
            if (idleTransformation) {
                track.previousMatrix = {
                    id: idleTransformation.id,
                    matrix: gl_matrix_1.mat4.clone(idleTransformation.matrix)
                };
                idleTransformation.matrix = gl_matrix_1.mat4.create();
                continue;
            }
            switch (track.path) {
                case 'scale':
                    const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                    if (idleTransformationScale) {
                        track.previousMatrix = {
                            id: idleTransformationScale.id,
                            matrix: gl_matrix_1.mat4.clone(idleTransformationScale.matrix)
                        };
                        continue;
                    }
                    break;
                case 'rotation':
                    const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                    if (idleTransformationRotation) {
                        track.previousMatrix = {
                            id: idleTransformationRotation.id,
                            matrix: gl_matrix_1.mat4.clone(idleTransformationRotation.matrix)
                        };
                        continue;
                    }
                    break;
                case 'translation':
                    const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                    if (idleTransformationTranslation) {
                        track.previousMatrix = {
                            id: idleTransformationTranslation.id,
                            matrix: gl_matrix_1.mat4.clone(idleTransformationTranslation.matrix)
                        };
                        continue;
                    }
                    break;
            }
        }
    }
    stopAnimation() {
        if (this.reset) {
            for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, "f").length; i++) {
                const track = __classPrivateFieldGet(this, _AnimationData_tracks, "f")[i];
                const id = this.id + '_' + i;
                const prevAnimation = track.node.transformations.filter(t => t.id === id);
                track.node.transformations = track.node.transformations.filter((el) => {
                    return !prevAnimation.includes(el);
                });
                if (track.previousMatrix) {
                    if (track.previousMatrix.id === 'gltf_matrix') {
                        const transformation = track.node.transformations.find(t => t.id === 'gltf_matrix');
                        transformation.matrix = track.previousMatrix.matrix;
                        const translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                        translationTransformation.matrix = gl_matrix_1.mat4.create();
                        const rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                        rotationTransformation.matrix = gl_matrix_1.mat4.create();
                        const scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                        scaleTransformation.matrix = gl_matrix_1.mat4.create();
                        continue;
                    }
                    else {
                        switch (track.path) {
                            case 'scale':
                                const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                                idleTransformationScale.matrix = track.previousMatrix.matrix;
                                continue;
                            case 'rotation':
                                const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                                idleTransformationRotation.matrix = track.previousMatrix.matrix;
                                continue;
                            case 'translation':
                                const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                                idleTransformationTranslation.matrix = track.previousMatrix.matrix;
                                continue;
                        }
                    }
                }
                else if (!__classPrivateFieldGet(this, _AnimationData_nodeIds, "f").includes(track.node.id)) {
                    const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');
                    if (idleTransformation) {
                        idleTransformation.matrix = gl_matrix_1.mat4.create();
                    }
                    else {
                        const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                        if (idleTransformationScale)
                            idleTransformationScale.matrix = gl_matrix_1.mat4.create();
                        const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                        if (idleTransformationRotation)
                            idleTransformationRotation.matrix = gl_matrix_1.mat4.create();
                        const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                        if (idleTransformationTranslation)
                            idleTransformationTranslation.matrix = gl_matrix_1.mat4.create();
                    }
                }
            }
        }
        else {
            for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, "f").length; i++) {
                const track = __classPrivateFieldGet(this, _AnimationData_tracks, "f")[i];
                const id = this.id + '_' + i;
                const prevAnimation = track.node.transformations.filter(t => t.id === id);
                track.node.transformations = track.node.transformations.filter((el) => {
                    return !prevAnimation.includes(el);
                });
                const j = track.times.length - 1;
                let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                if (!translationTransformation) {
                    translationTransformation = {
                        id: 'gltf_matrix_translation',
                        matrix: gl_matrix_1.mat4.create()
                    };
                    track.node.transformations.push(translationTransformation);
                }
                let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                if (!rotationTransformation) {
                    rotationTransformation = {
                        id: 'gltf_matrix_rotation',
                        matrix: gl_matrix_1.mat4.create()
                    };
                    track.node.transformations.push(rotationTransformation);
                }
                let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                if (!scaleTransformation) {
                    scaleTransformation = {
                        id: 'gltf_matrix_scale',
                        matrix: gl_matrix_1.mat4.create()
                    };
                    track.node.transformations.push(scaleTransformation);
                }
                if (track.path === 'rotation') {
                    let pivotMatrix, pivotMatrixInverse;
                    if (track.pivot) {
                        pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                        pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                    }
                    let quaternion = gl_matrix_1.quat.fromValues(track.values[j * 4 + 0], track.values[j * 4 + 1], track.values[j * 4 + 2], track.values[j * 4 + 3]);
                    const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);
                    if (pivotMatrix && pivotMatrixInverse) {
                        rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);
                    }
                    else {
                        rotationTransformation.matrix = rotationMatrix;
                    }
                }
                else if (track.path === 'translation') {
                    let vector = gl_matrix_1.vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);
                    translationTransformation.matrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);
                }
                else if (track.path === 'scale') {
                    let vector = gl_matrix_1.vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);
                    scaleTransformation.matrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);
                }
                else if (track.path === 'weights') {
                    let weights = [];
                    const weightCount = track.values.length / track.times.length;
                    for (let l = 0; l < weightCount; l++)
                        weights.push(track.values[j * weightCount + l]);
                    const applyWeights = (node) => {
                        for (let l = 0; l < node.data.length; l++)
                            if (node.data[l] instanceof GeometryData_1.GeometryData && node.data[l].morphWeights.length === weightCount)
                                node.data[l].morphWeights = weights;
                        for (let l = 0; l < node.children.length; l++)
                            applyWeights(node.children[l]);
                    };
                    applyWeights(track.node);
                }
            }
        }
        __classPrivateFieldSet(this, _AnimationData_animationTime, -1, "f");
        __classPrivateFieldSet(this, _AnimationData_started, false, "f");
        __classPrivateFieldSet(this, _AnimationData_animate, false, "f");
    }
}
exports.AnimationData = AnimationData;
_AnimationData_animate = new WeakMap(), _AnimationData_animationTime = new WeakMap(), _AnimationData_duration = new WeakMap(), _AnimationData_name = new WeakMap(), _AnimationData_repeat = new WeakMap(), _AnimationData_start = new WeakMap(), _AnimationData_started = new WeakMap(), _AnimationData_tracks = new WeakMap(), _AnimationData_reset = new WeakMap(), _AnimationData_nodeIds = new WeakMap();
//# sourceMappingURL=AnimationData.js.map