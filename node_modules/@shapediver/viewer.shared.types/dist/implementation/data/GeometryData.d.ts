import { mat4, vec3 } from 'gl-matrix';
import { AbstractTreeNodeData, ITreeNode } from '@shapediver/viewer.shared.node-tree';
import { IBox } from '@shapediver/viewer.shared.math';
import { IAttributeData, IGeometryData, IPrimitiveData, PRIMITIVE_MODE } from '../../interfaces/data/IGeometryData';
import { IMaterialAbstractData } from '../../interfaces/data/material/IMaterialAbstractData';
export declare class AttributeData extends AbstractTreeNodeData implements IAttributeData {
    #private;
    /**
     * Creates an attribute data object.
     *
     * @param _array the array of the data
     * @param _itemSize the size
     * @param _hasOffset notifier if there is an offset
     * @param _offset the offset
     * @param _stride the stride
     * @param _normalized boolean if the data is normalized
     */
    constructor(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, itemSize: number, itemBytes: number, byteOffset: number, elementBytes: number, normalized: boolean, count: number, min?: number[], max?: number[], byteStride?: number, sparse?: boolean, sparseIndices?: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, sparseValues?: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, morphAttributeData?: IAttributeData[]);
    get array(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array;
    get byteOffset(): number;
    get byteStride(): number | undefined;
    get count(): number;
    get elementBytes(): number;
    get itemBytes(): number;
    get itemSize(): number;
    get max(): number[];
    get min(): number[];
    get morphAttributeData(): IAttributeData[];
    get normalized(): boolean;
    get sparse(): boolean | undefined;
    get sparseIndices(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array | undefined;
    get sparseValues(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array | undefined;
    /**
     * Clones the attribute data.
     */
    clone(): IAttributeData;
}
export declare class PrimitiveData extends AbstractTreeNodeData implements IPrimitiveData {
    #private;
    /**
     * Creates a primitive data object.
     *
     * @param _attributes the attributes as key-value pairs
     * @param _indices the indices
     */
    constructor(attributes?: {
        [key: string]: IAttributeData;
    }, mode?: PRIMITIVE_MODE, indices?: IAttributeData | null, material?: IMaterialAbstractData | null, attributeMaterial?: IMaterialAbstractData | null);
    get attributes(): {
        [key: string]: IAttributeData;
    };
    get boundingBox(): IBox;
    get indices(): IAttributeData | null;
    set indices(value: IAttributeData | null);
    get standardMaterial(): IMaterialAbstractData | null;
    set standardMaterial(value: IMaterialAbstractData | null);
    get material(): IMaterialAbstractData | null;
    set material(value: IMaterialAbstractData | null);
    get effectMaterials(): {
        material: IMaterialAbstractData;
        token: string;
    }[];
    get materialVariants(): {
        material: IMaterialAbstractData;
        variant: number;
    }[];
    get attributeMaterial(): IMaterialAbstractData | null;
    set attributeMaterial(value: IMaterialAbstractData | null);
    get mode(): PRIMITIVE_MODE;
    get threeJsObject(): {
        [key: string]: THREE.BufferGeometry;
    };
    /**
     * Clones the primitive data.
     */
    clone(): IPrimitiveData;
}
export declare class GeometryData extends AbstractTreeNodeData implements IGeometryData {
    #private;
    /**
     * Creates a geometry data object.
     *
     * @param _primitive the primitive
     * @param _matrix the matrix to apply
     * @param id the id
     */
    constructor(primitive: IPrimitiveData, matrix?: mat4, id?: string, morphWeights?: number[]);
    get boundingBox(): IBox;
    get matrix(): mat4;
    get primitive(): IPrimitiveData;
    get renderOrder(): number;
    set renderOrder(value: number);
    get morphWeights(): number[];
    set morphWeights(value: number[]);
    get skinNode(): ITreeNode | undefined;
    set skinNode(value: ITreeNode | undefined);
    get threeJsObject(): {
        [key: string]: THREE.Mesh | THREE.Points | THREE.LineSegments | THREE.LineLoop | THREE.Line;
    };
    /**
     * Clones the scene graph data.
     */
    clone(): IGeometryData;
    intersect(origin: vec3, direction: vec3): number | null;
}
//# sourceMappingURL=GeometryData.d.ts.map