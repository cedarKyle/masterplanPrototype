import { Box } from '@shapediver/viewer.shared.math';
import { AbstractTreeNodeData } from '@shapediver/viewer.shared.node-tree';
import { vec2, vec3 } from 'gl-matrix';
import { IAnchorDataImage, IAnchorDataText, IHTMLElementAnchorData } from '../../interfaces/data/IHTMLElementAnchorData';
export declare abstract class HTMLElementAnchorData extends AbstractTreeNodeData implements IHTMLElementAnchorData {
    #private;
    protected internalHtmlElement: HTMLDivElement;
    /**
     * Creates a custom data node.
     *
     * @param _data the data as key- value pairs
     * @param id the id
     */
    constructor(properties: {
        location: vec3;
        data: IAnchorDataImage | IAnchorDataText | any;
        format: 'text' | 'image' | 'custom';
        hideable?: boolean;
        viewports?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    get data(): IAnchorDataImage | IAnchorDataText | any;
    set data(value: IAnchorDataImage | IAnchorDataText | any);
    get format(): 'text' | 'image' | 'custom';
    set format(value: 'text' | 'image' | 'custom');
    get hideable(): boolean;
    set hideable(value: boolean);
    get intersectionTarget(): Box | string | string[] | undefined;
    set intersectionTarget(value: Box | string | string[] | undefined);
    get location(): vec3;
    set location(value: vec3);
    get viewports(): string[];
    set viewports(value: string[]);
    createViewerHtmlElement(viewer: string): HTMLDivElement | null;
    getViewerHtmlElement(viewer: string): HTMLDivElement | null;
    abstract create(properties: {
        anchor: IHTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
    update(properties: {
        anchor: IHTMLElementAnchorData;
        htmlElement: HTMLDivElement;
        page: vec2;
        container: vec2;
        client: vec2;
        scale: vec2;
        hidden: boolean;
        visible: boolean;
    }): void;
    /**
     * Clones the scene graph data.
     */
    abstract clone(): IHTMLElementAnchorData;
}
export declare class HTMLElementAnchorTextData extends HTMLElementAnchorData {
    constructor(properties: {
        location: vec3;
        data: IAnchorDataText;
        hideable?: boolean;
        viewports?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    clone(): HTMLElementAnchorTextData;
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
}
export declare class HTMLElementAnchorImageData extends HTMLElementAnchorData {
    constructor(properties: {
        location: vec3;
        data: IAnchorDataImage;
        hideable?: boolean;
        viewports?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    clone(): HTMLElementAnchorImageData;
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
}
export declare class HTMLElementAnchorCustomData extends HTMLElementAnchorData {
    #private;
    constructor(properties: {
        location: vec3;
        data: any;
        hideable?: boolean;
        viewports?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
        create: (properties: {
            anchor: HTMLElementAnchorData;
            parent: HTMLDivElement;
        }) => void;
        update: (properties: {
            anchor: HTMLElementAnchorData;
            htmlElement: HTMLDivElement;
            page: vec2;
            container: vec2;
            client: vec2;
            scale: vec2;
            hidden: boolean;
            visible: boolean;
        }) => void;
    });
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
    update(properties: {
        anchor: HTMLElementAnchorData;
        htmlElement: HTMLDivElement;
        page: vec2;
        container: vec2;
        client: vec2;
        scale: vec2;
        hidden: boolean;
        visible: boolean;
    }): void;
    clone(): HTMLElementAnchorCustomData;
}
//# sourceMappingURL=HTMLElementAnchorData.d.ts.map