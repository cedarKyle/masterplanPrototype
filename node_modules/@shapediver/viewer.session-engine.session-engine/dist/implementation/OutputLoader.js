"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputLoader = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_data_engine_data_engine_1 = require("@shapediver/viewer.data-engine.data-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const OutputDelayException_1 = require("./OutputDelayException");
const SessionTreeNode_1 = require("./SessionTreeNode");
const SessionOutputData_1 = require("./SessionOutputData");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
class OutputLoader {
    // #endregion Properties (3)
    // #region Constructors (1)
    /**
     * The output loader takes care of loading the outputs of a session, storing them and returning stored or newly loaded nodes.
     *
     * @param _session the session for this output loader
     */
    constructor(_sessionEngine) {
        this._sessionEngine = _sessionEngine;
        // #region Properties (3)
        this._dataEngine = tsyringe_1.container.resolve(viewer_data_engine_data_engine_1.DataEngine);
        this._loadedOutputNodes = {};
        this._lastOutputNodes = {};
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, it throws an OutputDelayException.
     *
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(nodeName, outputs, outputsFreeze) {
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('outputLoading');
            const node = new SessionTreeNode_1.SessionTreeNode(nodeName);
            let currentNodes = {};
            let promises = [];
            let promisesNodes = [];
            let maxDelay = 0;
            for (let outputID in outputs) {
                currentNodes[outputID] = {};
                if (!this._loadedOutputNodes[outputID])
                    this._loadedOutputNodes[outputID] = {};
                if (outputsFreeze[outputID]) {
                    currentNodes[outputID][outputs[outputID].version] = this._lastOutputNodes[outputID];
                }
                else if (outputs[outputID].delay) {
                    maxDelay = Math.max(maxDelay, outputs[outputID].delay);
                }
                else if (!this._loadedOutputNodes[outputID][outputs[outputID].version]) {
                    currentNodes[outputID][outputs[outputID].version] = new SessionTreeNode_1.SessionTreeNode(outputID);
                    currentNodes[outputID][outputs[outputID].version].data.push(new SessionOutputData_1.SessionOutputData(outputs[outputID]));
                    if (outputs[outputID].content) {
                        for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                            promises.push(this._dataEngine.loadContent(outputs[outputID].content[i], this._sessionEngine.bearerToken));
                            promisesNodes.push(currentNodes[outputID][outputs[outputID].version]);
                        }
                    }
                }
                else {
                    currentNodes[outputID][outputs[outputID].version] = this._loadedOutputNodes[outputID][outputs[outputID].version];
                }
            }
            if (maxDelay)
                throw new OutputDelayException_1.OutputDelayException(maxDelay);
            yield Promise.all(promises);
            // all promises are resolved, await in the next lines is just for structural purposes
            for (let i = 0; i < promises.length; i++)
                promisesNodes[i].addChild(yield promises[i]);
            // here we assign all outputs just to the node and return it
            for (let outputID in outputs) {
                node.addChild(currentNodes[outputID][outputs[outputID].version]);
            }
            // save the nodes as the last available version
            for (let outputID in outputs) {
                this._loadedOutputNodes[outputID] = {};
                this._loadedOutputNodes[outputID][outputs[outputID].version] = currentNodes[outputID][outputs[outputID].version];
                this._lastOutputNodes[outputID] = currentNodes[outputID][outputs[outputID].version];
            }
            for (let outputID in outputs) {
                if (currentNodes[outputID][outputs[outputID].version].children.length > 1) {
                    for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                        if (outputs[outputID].content[i].format === 'sdtf') {
                            this.mergeContentNodes(currentNodes[outputID][outputs[outputID].version]);
                            break;
                        }
                    }
                }
            }
            this.assignMaterials(node);
            this._performanceEvaluator.endSection('outputLoading');
            return node;
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (2)
    assignMaterials(node) {
        const addMaterialToGeometry = (node, material) => {
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometry = node.data[i];
                    const currentMaterial = geometry.primitive.material;
                    if (currentMaterial === null || currentMaterial.materialOutput === true) {
                        geometry.primitive.material = material;
                    }
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (child)
                    addMaterialToGeometry(child, material);
            }
        };
        const getMaterialData = (node, materials = []) => {
            for (let k = 0; k < node.data.length; k++) {
                if (node.data[k] instanceof viewer_shared_types_1.AbstractMaterialData) {
                    const material = node.data[k];
                    material.materialOutput = true;
                    materials.push(material);
                }
            }
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                materials.push(...getMaterialData(child));
            }
            return materials;
        };
        const getGeometryData = (node, geometries = []) => {
            for (let k = 0; k < node.data.length; k++)
                if (node.data[k] instanceof viewer_shared_types_1.GeometryData)
                    geometries.push(node.data[k]);
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                geometries.push(...getGeometryData(child));
            }
            return geometries;
        };
        for (let m = 0; m < node.children.length; m++) {
            // per output node, we go through the material assignment process
            const outputNode = node.children[m];
            if (!outputNode)
                continue;
            // we go through all data properties, normally, there should ony one, but we just make sure
            for (let i = 0; i < outputNode.data.length; i++) {
                if (!(outputNode.data[i] instanceof SessionOutputData_1.SessionOutputData))
                    continue;
                // the session output data contains information about this Output
                // most importantly the SessionOutput property with the material and content in it
                const sessionOutputData = outputNode.data[i];
                // case 1: we have a specific material id defined, let's use that
                if (sessionOutputData.responseOutput.material) {
                    let materialNodes = [];
                    // now we have id
                    // get material with it    
                    for (let n = 0; n < node.children.length; n++) {
                        const materialNode = node.children[n];
                        if (!materialNode)
                            continue;
                        if (materialNode.name === sessionOutputData.responseOutput.material)
                            materialNodes = materialNode.children;
                    }
                    const geometryNodes = outputNode.children;
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
                // case 2: there is no specific material id defined, maybe in the content we can match geometries to ids
                else {
                    // now we hope that in our content, there are exactly the amount of geometries and material, this will be interesting :)
                    const sessionOutputContent = sessionOutputData.responseOutput.content;
                    if (sessionOutputContent === undefined)
                        continue;
                    const materialNodes = [];
                    const geometryNodes = [];
                    for (let i = 0; i < sessionOutputContent.length; i++) {
                        if (sessionOutputContent[i].format === 'material') {
                            materialNodes.push(outputNode.children[i]);
                        }
                        else {
                            geometryNodes.push(outputNode.children[i]);
                        }
                    }
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
            }
        }
    }
    mergeContentNodes(node) {
        if (!(node.children.length > 1))
            return;
        const children = [];
        while (node.children.length > 0) {
            children.push(...node.children[0].children);
            node.removeChild(node.children[0]);
        }
        const mergeNodes = (node1, node2) => {
            for (let i = 0; i < node1.data.length; i++)
                node2.data.push(node1.data[i]);
            for (let i = 0; i < node1.children.length; i++) {
                let childNode;
                for (let j = 0; j < node2.children.length; j++) {
                    if (node1.children[i].name === node2.children[j].name) {
                        childNode = node2.children[j];
                        break;
                    }
                }
                if (!childNode) {
                    childNode = new viewer_shared_node_tree_1.TreeNode(node1.children[i].name);
                    node2.addChild(childNode);
                }
                mergeNodes(node1.children[i], childNode);
            }
        };
        const newChild = new viewer_shared_node_tree_1.TreeNode('content_array');
        node.addChild(newChild);
        for (let i = 0; i < children.length; i++)
            mergeNodes(children[i], newChild);
    }
}
exports.OutputLoader = OutputLoader;
//# sourceMappingURL=OutputLoader.js.map