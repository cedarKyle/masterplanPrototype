"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SessionEngine_customizationProcess, _SessionEngine_parameterHistory, _SessionEngine_parameterHistoryCall, _SessionEngine_parameterHistoryForward;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionEngine = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const OutputDelayException_1 = require("./OutputDelayException");
const OutputLoader_1 = require("./OutputLoader");
const SessionTreeNode_1 = require("./SessionTreeNode");
const ISessionEngine_1 = require("../interfaces/ISessionEngine");
const SessionData_1 = require("./SessionData");
const sdk_geometry_api_sdk_v2_1 = require("@shapediver/sdk.geometry-api-sdk-v2");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const FileParameter_1 = require("./dto/FileParameter");
const Parameter_1 = require("./dto/Parameter");
const Export_1 = require("./dto/Export");
const Output_1 = require("./dto/Output");
const viewer_settings_1 = require("@shapediver/viewer.settings");
class SessionEngine {
    // #endregion Properties (40)
    // #region Constructors (1)
    /**
     * Can be use to initialize a session with the ticket and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties) {
        // #region Properties (40)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._exports = {};
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._outputs = {};
        this._outputsFreeze = {};
        this._parameterValues = {};
        this._parameters = {};
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
        this._sceneTree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._sessionEngineId = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator).create();
        this._settingsEngine = new viewer_shared_services_1.SettingsEngine();
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._automaticSceneUpdate = true;
        this._closeOnFailure = () => __awaiter(this, void 0, void 0, function* () { });
        this._closed = false;
        this._customizeOnParameterChange = false;
        this._dataCache = {};
        this._excludeViewports = [];
        this._headers = {
            "X-ShapeDiver-Origin": tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo).origin,
            "X-ShapeDiver-SessionEngineId": this._sessionEngineId,
            "X-ShapeDiver-BuildVersion": '',
            "X-ShapeDiver-BuildDate": ''
        };
        this._initialized = false;
        this._retryCounter = 0;
        this._updateCallback = null;
        _SessionEngine_customizationProcess.set(this, void 0);
        _SessionEngine_parameterHistory.set(this, []);
        _SessionEngine_parameterHistoryCall.set(this, false);
        _SessionEngine_parameterHistoryForward.set(this, []);
        this._id = properties.id;
        this._node = new viewer_shared_node_tree_1.TreeNode(properties.id);
        this._ticket = properties.ticket;
        this._modelViewUrl = properties.modelViewUrl;
        this._excludeViewports = properties.excludeViewports || [];
        this._bearerToken = properties.bearerToken;
        this._headers['X-ShapeDiver-BuildDate'] = properties.buildDate;
        this._headers['X-ShapeDiver-BuildVersion'] = properties.buildVersion;
        this._outputLoader = new OutputLoader_1.OutputLoader(this);
        this._sdk = (0, sdk_geometry_api_sdk_v2_1.create)(this._modelViewUrl, this._bearerToken);
        this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.REQUEST_HEADERS, this._headers);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (23)
    get automaticSceneUpdate() {
        return this._automaticSceneUpdate;
    }
    set automaticSceneUpdate(value) {
        this._automaticSceneUpdate = value;
        value ? this._sceneTree.addNode(this._node) : this._sceneTree.removeNode(this._node);
    }
    get bearerToken() {
        return this._bearerToken;
    }
    set bearerToken(value) {
        this._bearerToken = value;
        this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.JWT_TOKEN, value);
    }
    get canUploadGLTF() {
        try {
            this.checkAvailability('gltf-upload');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    get customizeOnParameterChange() {
        return this._customizeOnParameterChange;
    }
    set customizeOnParameterChange(value) {
        this._customizeOnParameterChange = value;
    }
    get excludeViewports() {
        return this._excludeViewports;
    }
    set excludeViewports(value) {
        this._excludeViewports = JSON.parse(JSON.stringify(value));
        this._node.excludeViewports = JSON.parse(JSON.stringify(value));
    }
    get exports() {
        return this._exports;
    }
    get id() {
        return this._id;
    }
    get initialized() {
        return this._initialized;
    }
    get modelViewUrl() {
        return this._modelViewUrl;
    }
    get node() {
        return this._node;
    }
    get outputs() {
        return this._outputs;
    }
    get outputsFreeze() {
        return this._outputsFreeze;
    }
    get parameterValues() {
        return this._parameterValues;
    }
    get parameters() {
        return this._parameters;
    }
    get refreshBearerToken() {
        return this._refreshBearerToken;
    }
    set refreshBearerToken(value) {
        this._refreshBearerToken = value;
    }
    get settingsEngine() {
        return this._settingsEngine;
    }
    get ticket() {
        return this._ticket;
    }
    get updateCallback() {
        return this._updateCallback;
    }
    set updateCallback(value) {
        this._updateCallback = value;
    }
    get viewerSettings() {
        return this._viewerSettings;
    }
    // #endregion Public Accessors (23)
    // #region Public Methods (22)
    applySettings(response, sections) {
        try {
            sections = sections || {};
            if (sections.session === undefined) {
                sections.session = {
                    parameter: { displayname: false, order: false, hidden: false },
                    export: { displayname: false, order: false, hidden: false }
                };
            }
            if (sections.session.parameter === undefined)
                sections.session.parameter = { displayname: false, order: false, hidden: false, value: false };
            if (sections.session.export === undefined)
                sections.session.export = { displayname: false, order: false, hidden: false };
            if (sections.viewport === undefined)
                sections.viewport = { ar: false, scene: false, camera: false, light: false, environment: false, general: false };
            let config;
            if (response.viewer !== undefined) {
                config = response.viewer.config;
            }
            else {
                const error = new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.applySettings: No config object available.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SETTINGS, 'Session.applySettings', error);
            }
            try {
                (0, viewer_settings_1.validate)(config);
            }
            catch (e) {
                const error = new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.applySettings: Was not able to validate config object.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SETTINGS, 'Session.applySettings', error);
            }
            const settings = (0, viewer_settings_1.convert)(config, '3.1');
            const exportMappingUid = {};
            if (sections.session.export.displayname || sections.session.export.order || sections.session.export.hidden)
                if (response.exports)
                    for (let exportId in response.exports)
                        if (response.exports[exportId].uid !== undefined)
                            exportMappingUid[response.exports[exportId].uid] = exportId;
            const currentSettings = this._settingsEngine.settings;
            // apply parameter settings
            if (sections.session.parameter.displayname || sections.session.parameter.order || sections.session.parameter.hidden || sections.session.parameter.value) {
                for (let p in this.parameters) {
                    if (settings.session[p]) {
                        if (sections.session.parameter.displayname)
                            this.parameters[p].displayname = settings.session[p].displayname;
                        if (sections.session.parameter.order)
                            this.parameters[p].order = settings.session[p].order;
                        if (sections.session.parameter.hidden)
                            this.parameters[p].hidden = settings.session[p].hidden || false;
                    }
                    if (response.parameters && response.parameters[p]) {
                        if (sections.session.parameter.value)
                            this.parameters[p].value = response.parameters[p].defval !== undefined ? response.parameters[p].defval : this.parameters[p].value;
                    }
                }
            }
            // apply export settings
            if (sections.session.export.displayname || sections.session.export.order || sections.session.export.hidden) {
                for (let p in this.exports) {
                    let idForSettings = '';
                    if (settings.session[p]) {
                        idForSettings = p;
                    }
                    else {
                        const uid = this.exports[p].uid;
                        if (!uid)
                            continue;
                        if (!exportMappingUid[uid])
                            continue;
                        idForSettings = exportMappingUid[uid];
                    }
                    if (settings.session[idForSettings]) {
                        if (sections.session.export.displayname)
                            this.exports[p].displayname = settings.session[idForSettings].displayname;
                        if (sections.session.export.order)
                            this.exports[p].order = settings.session[idForSettings].order;
                        if (sections.session.export.hidden)
                            this.exports[p].hidden = settings.session[idForSettings].hidden || false;
                    }
                }
            }
            // apply ar settings
            if (sections.viewport.ar) {
                currentSettings.ar = settings.ar;
                currentSettings.general.transformation = settings.general.transformation;
            }
            // apply camera settings
            if (sections.viewport.camera)
                currentSettings.camera = settings.camera;
            // apply light settings
            if (sections.viewport.light)
                currentSettings.light = settings.light;
            // apply scene settings
            if (sections.viewport.scene) {
                currentSettings.environmentGeometry.gridColor = settings.environmentGeometry.gridColor;
                currentSettings.environmentGeometry.gridVisibility = settings.environmentGeometry.gridVisibility;
                currentSettings.environmentGeometry.groundPlaneColor = settings.environmentGeometry.groundPlaneColor;
                currentSettings.environmentGeometry.groundPlaneVisibility = settings.environmentGeometry.groundPlaneVisibility;
                currentSettings.rendering.shadows = settings.rendering.shadows;
                currentSettings.rendering.ambientOcclusion = settings.rendering.ambientOcclusion;
                currentSettings.rendering.textureEncoding = settings.rendering.textureEncoding;
                currentSettings.rendering.outputEncoding = settings.rendering.outputEncoding;
                currentSettings.rendering.physicallyCorrectLights = settings.rendering.physicallyCorrectLights;
                currentSettings.rendering.toneMapping = settings.rendering.toneMapping;
                currentSettings.rendering.toneMappingExposure = settings.rendering.toneMappingExposure;
            }
            if (sections.viewport.general) {
                currentSettings.general.commitParameters = settings.general.commitParameters;
                currentSettings.general.pointSize = settings.general.pointSize;
            }
            // apply environment settings
            if (sections.viewport.environment) {
                currentSettings.environment.clearAlpha = settings.environment.clearAlpha;
                currentSettings.environment.clearColor = settings.environment.clearColor;
                currentSettings.environment.map = settings.environment.map;
                currentSettings.environment.mapAsBackground = settings.environment.mapAsBackground;
            }
        }
        catch (e) {
            if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                throw e;
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'Session.applySettings', e);
        }
    }
    canGoBack() {
        // the first entry is always the one from the init call
        // all additional entries can be undone
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length > 1;
    }
    canGoForward() {
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").length > 0;
    }
    close(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('close');
            try {
                this._httpClient.removeDataLoading(this._sessionId);
                yield this._sdk.session.close(this._sessionId);
                if (this._automaticSceneUpdate)
                    this._sceneTree.removeNode(this._node);
                this._closed = true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.close', e, retry);
                return yield this.close(true);
            }
        });
    }
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const customizationId = this._uuidGenerator.create();
            try {
                // we check if something changed
                if (force === false) {
                    let changes = false;
                    for (const parameterId in this.parameters)
                        if (this.parameters[parameterId].sessionValue !== this.parameters[parameterId].value)
                            changes = true;
                    if (changes === false)
                        return this.node;
                }
                const eventStart = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0, data: { sessionId: this.id }, status: 'Customizing session' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                const oldNode = this.node.cloneInstance();
                __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
                this._logger.debugLow(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Customizing session.`);
                for (let r in this._stateEngine.renderingEngines)
                    this._stateEngine.renderingEngines[r].busy.push(customizationId);
                const eventFileUpload = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.1, data: { sessionId: this.id }, status: 'Uploading file parameters' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventFileUpload);
                const fileParameterIds = {};
                // load file parameter first
                for (const parameterId in this.parameters) {
                    if (this.parameters[parameterId] instanceof FileParameter_1.FileParameter) {
                        fileParameterIds[parameterId] = yield this.parameters[parameterId].upload();
                        // OPTION TO SKIP - PART 1a
                        if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
                            for (let r in this._stateEngine.renderingEngines)
                                if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                                    this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                            this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Session customization was exceeded by other customization request.`);
                            const eventCancel1a = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customization was exceeded by other customization request' };
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel1a);
                            return new SessionTreeNode_1.SessionTreeNode();
                        }
                    }
                }
                // OPTION TO SKIP - PART 1b
                if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
                    for (let r in this._stateEngine.renderingEngines)
                        if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                            this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                    const eventCancel1b = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customization was exceeded by other customization request' };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel1b);
                    this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Session customization was exceeded by other customization request.`);
                    return new SessionTreeNode_1.SessionTreeNode();
                }
                // assign the uploaded parameters
                for (const parameterId in fileParameterIds)
                    this.parameters[parameterId].value = fileParameterIds[parameterId];
                const parameterSet = {};
                // create a set of the current validated parameter values
                for (const parameterId in this.parameters) {
                    parameterSet[parameterId] = {
                        value: this.parameters[parameterId].value,
                        valueString: this.parameters[parameterId].stringify()
                    };
                }
                // update the session engine parameter values if everything succeeded
                for (const parameterId in this.parameters)
                    this.parameterValues[parameterId] = parameterSet[parameterId].valueString;
                this._logger.info(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Customizing session with parameters ${JSON.stringify(this.parameterValues)}.`);
                const eventRequest = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.25, data: { sessionId: this.id }, status: 'Sending customization request' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
                const newNode = yield this.customizeInternal(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId);
                const eventSceneUpdate = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.75, data: { sessionId: this.id }, status: 'Updating scene' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
                // OPTION TO SKIP - PART 2
                if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
                    for (let r in this._stateEngine.renderingEngines)
                        if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                            this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                    const eventCancel2 = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customization was exceeded by other customization request' };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel2);
                    this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Session customization was exceeded by other customization request.`);
                    return newNode;
                }
                // if this is not a call by the goBack or goForward functions, add the parameter values to the history and delete the forward history
                if (!__classPrivateFieldGet(this, _SessionEngine_parameterHistoryCall, "f")) {
                    __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
                    __classPrivateFieldSet(this, _SessionEngine_parameterHistoryForward, [], "f");
                }
                if (this.automaticSceneUpdate)
                    this._sceneTree.removeNode(this.node);
                this._node = newNode;
                if (this.automaticSceneUpdate)
                    this._sceneTree.addNode(this.node);
                this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Customization request finished, updating geometry.`);
                // set the session values to the current ones in all parameters
                for (const parameterId in this.parameters)
                    this.parameters[parameterId].sessionValue = parameterSet[parameterId].value;
                if (this._updateCallback)
                    this._updateCallback(newNode, oldNode);
                // set the output content to what has been updated
                for (const outputId in this.outputs)
                    this.outputs[outputId].updateOutput(newNode.children.find(c => c.name === outputId), oldNode.children.find(c => c.name === outputId));
                // set the export definitions
                for (const exportId in this.exports)
                    this.exports[exportId].updateExport();
                this._warningCreator();
                this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                for (let r in this._stateEngine.renderingEngines)
                    if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                        this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize: Session customized.`);
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CUSTOMIZED, { sessionId: this.id });
                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customized' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                return this.node;
            }
            catch (e) {
                const eventCancel = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customization failed' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
                for (let r in this._stateEngine.renderingEngines)
                    if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                        this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                    throw e;
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize`, e);
            }
        });
    }
    customizeParallel(parameterValues) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const parameterSet = {};
                // create a set of the current validated parameter values
                for (const parameterId in this.parameters)
                    parameterSet[parameterId] = parameterValues[parameterId] !== undefined ? (' ' + parameterValues[parameterId]).slice(1) : this.parameters[parameterId].stringify();
                const newNode = yield this.customizeSession(parameterSet, () => false, true);
                newNode.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                return newNode;
            }
            catch (e) {
                if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                    throw e;
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).customize`, e);
            }
        });
    }
    goBack() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoBack()) {
                this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).goBack: Cannot go further back.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the current parameter set and store it in the forward history later on
            const currentParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").pop();
            // adjust the parameters according to the last parameter set
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f")[__classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length - 1];
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value = lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current (not anymore current) parameter set to the forward history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").push(currentParameterSet);
            return node;
        });
    }
    goForward() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoForward()) {
                this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).goForward: Cannot go further forward.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the last undone parameter set and apply the values to the parameters
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").pop();
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value = lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current parameter set to the history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(lastParameterSet);
            return node;
        });
    }
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues, retry = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized === true) {
                const error = new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Session already initialized.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.init', error);
            }
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                const parameterSet = {};
                for (const parameterId in parameterValues)
                    parameterSet[parameterId] = (' ' + parameterValues[parameterId]).slice(1);
                this._responseDto = yield this._sdk.session.init(this._ticket, parameterSet);
                this._performanceEvaluator.endSection('sessionResponse');
                this._viewerSettings = (_a = this._responseDto.viewer) === null || _a === void 0 ? void 0 : _a.config;
                this._settingsEngine.loadSettings(this._viewerSettings);
                this._sessionId = this._responseDto.sessionId;
                this._modelId = (_b = this._responseDto.model) === null || _b === void 0 ? void 0 : _b.id;
                this._httpClient.addDataLoading(this._sessionId, {
                    getAsset: this._sdk.asset.getAsset.bind(this._sdk.asset),
                    downloadTexture: this._sdk.asset.downloadImage.bind(this._sdk.asset),
                });
                if (!this._sessionId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.init: Initialization of session failed. ResponseDto did not have a sessionId.`);
                if (!this._modelId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.init: Initialization of session failed. ResponseDto did not have a model.id.`);
                this.updateResponseDto(this._responseDto, parameterSet);
                this._initialized = true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.init', e, retry);
                return yield this.init(parameterValues, true);
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputsParallel(responseDto, cancelRequest = () => false, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            let outputs = {};
            let outputsFreeze = {};
            for (let outputId in responseDto.outputs) {
                responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    outputsFreeze[outputId] = false;
                outputs[outputId] = new Output_1.Output(responseDto.outputs[outputId], this);
            }
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || 'model', outputs, outputsFreeze);
                node.data.push(new SessionData_1.SessionData(responseDto));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.loadOutputsParallel', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                let outputMapping = {};
                for (let output in outputs)
                    outputMapping[output] = outputs[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputsParallel(responseDto, cancelRequest);
                }
                catch (e) {
                    yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.loadOutputsParallel', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, true);
                }
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest = () => false, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const o = Object.assign({}, this._outputs);
            const of = Object.assign({}, this._outputsFreeze);
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || 'model', o, of);
                node.data.push(new SessionData_1.SessionData(this._responseDto));
                if (cancelRequest())
                    return node;
                if (this._automaticSceneUpdate)
                    this._sceneTree.removeNode(this._node);
                this._node = node;
                if (this._automaticSceneUpdate)
                    this._sceneTree.addNode(this._node);
                this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.loadOutputs', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                let outputMapping = {};
                for (let output in o)
                    outputMapping[output] = o[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputs(cancelRequest);
                }
                catch (e) {
                    yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.loadOutputs', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, true);
                }
            }
        });
    }
    requestExport(exportId, parameters, maxWaitTime, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export');
            try {
                const parameterSet = {};
                for (const parameterId in parameters)
                    parameterSet[parameterId] = (' ' + parameters[parameterId]).slice(1);
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, { exports: { id: exportId }, parameters: parameterSet }, maxWaitTime);
                this.updateResponseDto(responseDto);
                return this.exports[exportId];
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.requestExport', e, retry);
                return yield this.requestExport(exportId, parameters, maxWaitTime, true);
            }
        });
    }
    resetSettings(sections) {
        if (!this._responseDto) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.resetSettings: responseDto not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.resetSettings', error);
        }
        try {
            sections = sections || {};
            if (sections.session === undefined) {
                sections.session = {
                    parameter: { displayname: true, order: true, hidden: true },
                    export: { displayname: true, order: true, hidden: true }
                };
            }
            if (sections.session.parameter === undefined)
                sections.session.parameter = { displayname: true, order: true, hidden: true, value: true };
            if (sections.session.export === undefined)
                sections.session.export = { displayname: true, order: true, hidden: true };
            if (sections.viewport === undefined)
                sections.viewport = { ar: true, scene: true, camera: true, light: true, environment: true, general: true };
            return this.applySettings(this._responseDto, sections);
        }
        catch (e) {
            if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                throw e;
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'Session.resetSettings', e);
        }
    }
    saveDefaultParameterValues() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._logger.debugLow(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveDefaultParameters: Saving default parameters.`);
                const response = yield this.saveDefaultParameters();
                if (response) {
                    this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveDefaultParameters: Saved default parameters.`);
                }
                else {
                    const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session(${this.id}).saveDefaultParameters: Could not save default parameters.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveDefaultParameters`, error);
                }
                return response;
            }
            catch (e) {
                if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                    throw e;
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveDefaultParameters`, e);
            }
        });
    }
    saveDefaultParameters(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('defaultparam', true);
            try {
                yield this._sdk.model.setDefaultParams(this._modelId, this._parameterValues);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.saveDefaultParameters', e, retry);
                return yield this.saveDefaultParameters(true);
            }
        });
    }
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export-definition', true);
            try {
                yield this._sdk.export.updateDefinitions(this._modelId, exports);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.saveExportProperties', e, retry);
                return yield this.saveExportProperties(exports, true);
            }
        });
    }
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('output-definition', true);
            try {
                yield this._sdk.output.updateDefinitions(this._modelId, outputs);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.saveOutputProperties', e, retry);
                return yield this.saveOutputProperties(outputs, true);
            }
        });
    }
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('parameter-definition', true);
            try {
                yield this._sdk.model.updateParameterDefinitions(this._modelId, parameters);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.saveParameterProperties', e, retry);
                return yield this.saveParameterProperties(parameters, true);
            }
        });
    }
    saveSettings(json, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('configure', true);
            try {
                (0, viewer_settings_1.validate)(json, '3.1');
            }
            catch (e) {
                const error = new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.saveSettings: Settings could not be validated. ' + e.message, e);
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SETTINGS, 'Session.applySettings', error);
            }
            try {
                yield this._sdk.model.updateConfig(this._modelId, json);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.saveSettings', e, retry);
                return yield this.saveSettings(json, true);
            }
        });
    }
    saveUiProperties(saveInSettings = true) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._logger.debugLow(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveSessionProperties: Saving session properties.`);
                // settings saving 
                this._saveSessionSettings();
                let properties = {};
                for (let p in this.parameters) {
                    properties[p] = {
                        displayname: this.parameters[p].displayname !== undefined ? this.parameters[p].displayname : '',
                        hidden: this.parameters[p].hidden !== undefined ? this.parameters[p].hidden : false,
                        order: this.parameters[p].order !== undefined ? this.parameters[p].order : 0,
                        tooltip: this.parameters[p].tooltip !== undefined ? this.parameters[p].tooltip : '',
                    };
                }
                const responseP = Object.values(properties).length !== 0 ? yield this.saveParameterProperties(properties) : true;
                properties = {};
                for (let e in this.exports) {
                    properties[e] = {
                        displayname: this.exports[e].displayname !== undefined ? this.exports[e].displayname : '',
                        hidden: this.exports[e].hidden !== undefined ? this.exports[e].hidden : false,
                        order: this.exports[e].order !== undefined ? this.exports[e].order : 0,
                        tooltip: this.exports[e].tooltip !== undefined ? this.exports[e].tooltip : '',
                    };
                }
                const responseE = Object.values(properties).length !== 0 ? yield this.saveExportProperties(properties) : true;
                properties = {};
                for (let o in this.outputs) {
                    properties[o] = {
                        displayname: this.outputs[o].displayname !== undefined ? this.outputs[o].displayname : '',
                        hidden: this.outputs[o].hidden !== undefined ? this.outputs[o].hidden : false,
                        order: this.outputs[o].order !== undefined ? this.outputs[o].order : 0,
                        tooltip: this.outputs[o].tooltip !== undefined ? this.outputs[o].tooltip : '',
                    };
                }
                const responseO = Object.values(properties).length !== 0 ? yield this.saveOutputProperties(properties) : true;
                // save partial settings
                const response = saveInSettings ? yield this.saveSettings(this._settingsEngine.convertToTargetVersion()) : true;
                if (response && responseP && responseO && responseE) {
                    this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveSessionProperties: Saved session properties.`);
                }
                else {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveSessionProperties: Could not save session properties.`);
                }
                return response && responseP && responseO && responseE;
            }
            catch (e) {
                if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                    throw e;
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).saveSessionProperties`, e);
            }
        });
    }
    updateOutputs() {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const customizationId = this._uuidGenerator.create();
            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE, id: eventId, progress: 0, data: { sessionId: this.id }, status: 'Updating outputs' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
            const oldNode = this.node.cloneInstance();
            __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
            this._logger.debugLow(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).updateOutputs: Updating Outputs.`);
            for (let r in this._stateEngine.renderingEngines)
                this._stateEngine.renderingEngines[r].busy.push(customizationId);
            const eventRequest = { type: viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE, id: eventId, progress: 0.25, data: { sessionId: this.id }, status: 'Loading outputs' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
            const newNode = yield this.loadOutputs(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId);
            const eventSceneUpdate = { type: viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE, id: eventId, progress: 0.75, data: { sessionId: this.id }, status: 'Updating scene' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
            // OPTION TO SKIP - PART 1
            if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
                for (let r in this._stateEngine.renderingEngines)
                    if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                        this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
                const eventCancel1 = { type: viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Output updating was exceeded by other customization request' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel1);
                this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).updateOutputs: Output updating was exceeded by other request.`);
                return newNode;
            }
            if (this.automaticSceneUpdate)
                this._sceneTree.removeNode(this.node);
            this._node = newNode;
            if (this.automaticSceneUpdate)
                this._sceneTree.addNode(this.node);
            this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).updateOutputs: Updating outputs finished, updating geometry.`);
            if (this._updateCallback)
                this._updateCallback(newNode, oldNode);
            // set the output content to what has been updated
            for (const outputId in this.outputs) {
                this.outputs[outputId].updateOutput(newNode.children.find(c => c.name === outputId), oldNode.children.find(c => c.name === outputId));
            }
            // set the export definitions
            for (const exportId in this.exports)
                this.exports[exportId].updateExport();
            this._warningCreator();
            this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
            for (let r in this._stateEngine.renderingEngines)
                if (this._stateEngine.renderingEngines[r].busy.includes(customizationId))
                    this._stateEngine.renderingEngines[r].busy.splice(this._stateEngine.renderingEngines[r].busy.indexOf(customizationId), 1);
            this._logger.debug(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `Session(${this.id}).updateOutputs: Updated outputs.`);
            const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Outputs updated' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
            return this.node;
        });
    }
    uploadFile(parameterId, data, type, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('file-upload');
            try {
                const responseDto = yield this._sdk.file.requestUpload(this._sessionId, {
                    [parameterId]: { size: data.size, format: type }
                });
                if (responseDto && responseDto.asset && responseDto.asset.file && responseDto.asset.file[parameterId]) {
                    const fileAsset = responseDto.asset.file[parameterId];
                    yield this._sdk.utils.upload(fileAsset.href, yield data.arrayBuffer(), type);
                    return fileAsset.id;
                }
                else {
                    const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.uploadFile: Upload reply has not the required format.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.uploadFile', error);
                }
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.uploadFile', e, retry);
                return yield this.uploadFile(parameterId, data, type, true);
            }
        });
    }
    uploadGLTF(blob, conversion = sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.NONE, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('gltf-upload');
            try {
                const responseDto = yield this._sdk.gltf.upload(this._sessionId, yield blob.arrayBuffer(), 'model/gltf-binary', conversion);
                if (!responseDto || !responseDto.gltf || !responseDto.gltf.href) {
                    const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.uploadGLTF: Upload reply has not the required format.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.uploadGLTF', error);
                }
                return responseDto;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.uploadGLTF', e, retry);
                return yield this.uploadGLTF(blob, conversion, true);
            }
        });
    }
    // #endregion Public Methods (22)
    // #region Private Methods (8)
    _saveSessionSettings() {
        const parameters = this.parameters;
        const exports = this.exports;
        const sessionProperties = {};
        for (let p in parameters) {
            sessionProperties[p] = {
                order: parameters[p].order || 0,
                displayname: parameters[p].displayname || '',
                hidden: parameters[p].hidden
            };
        }
        for (let e in exports) {
            sessionProperties[e] = {
                order: exports[e].order || 0,
                displayname: exports[e].displayname || '',
                hidden: exports[e].hidden
            };
        }
        this._settingsEngine.session = sessionProperties;
        let orderedOutputs = [];
        for (let o in this.outputs)
            orderedOutputs.push(this.outputs[o]);
        orderedOutputs.sort((a, b) => ((a.order || Infinity) - (b.order || Infinity)));
        let zerosOutputs = orderedOutputs.filter(x => x.order === 0);
        orderedOutputs = orderedOutputs.filter((el) => { return !zerosOutputs.includes(el); });
        orderedOutputs = zerosOutputs.concat(orderedOutputs);
        const controlOrderOutputs = orderedOutputs.map((value) => { return value.id; });
        for (let i = 0; i < controlOrderOutputs.length; i++) {
            if (this.outputs[controlOrderOutputs[i]])
                if (this.outputs[controlOrderOutputs[i]].order !== i)
                    this.outputs[controlOrderOutputs[i]].order = i;
        }
    }
    _warningCreator() {
        // set the output content to what has been updated
        for (const outputId in this.outputs) {
            let warning = '';
            if (this.outputs[outputId].msg)
                warning += `\n\t- ${this.outputs[outputId].msg}`;
            if (this.outputs[outputId].status_collect && this.outputs[outputId].status_collect !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_collect is ${this.outputs[outputId].status_collect}`;
            if (this.outputs[outputId].status_computation && this.outputs[outputId].status_computation !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_computation is ${this.outputs[outputId].status_computation}`;
            if (warning)
                this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `\nOutput(${outputId}):${warning}`);
        }
        // set the export definitions
        for (const exportId in this.exports) {
            let warning = '';
            if (this.exports[exportId].msg)
                warning += `\n\t- ${this.exports[exportId].msg}`;
            if (this.exports[exportId].status_collect && this.exports[exportId].status_collect !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_collect is ${this.exports[exportId].status_collect}`;
            if (this.exports[exportId].status_computation && this.exports[exportId].status_computation !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_computation is ${this.exports[exportId].status_computation}`;
            if (warning)
                this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `\nExport(${exportId}):${warning}`);
        }
    }
    checkAvailability(action, checkForModelId = false) {
        var _a;
        if (!this._responseDto) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: responseDto not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (!this._sessionId) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: sessionId not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (checkForModelId && !this._modelId) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: modelId not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (action && !this._responseDto.actions) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: actions not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.checkAvailability', error);
        }
        const responseDtoAction = (_a = this._responseDto.actions) === null || _a === void 0 ? void 0 : _a.find(a => a.name === action);
        if (action && !responseDtoAction) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: action ${action} not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.checkAvailability', error);
        }
    }
    customizeInternal(cancelRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.customizeSession(this._parameterValues, cancelRequest);
        });
    }
    customizeSession(parameters, cancelRequest, parallel = false, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('customize');
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                const responseDto = yield this._sdk.utils.submitAndWaitForCustomization(this._sdk, this._sessionId, parameters);
                this._performanceEvaluator.endSection('sessionResponse');
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                if (parallel === false)
                    this.updateResponseDto(responseDto);
                return parallel === false ? this.loadOutputs(cancelRequest) : this.loadOutputsParallel(responseDto, cancelRequest);
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Session.customizeSession', e, retry);
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                return yield this.customizeSession(parameters, cancelRequest, parallel, true);
            }
        });
    }
    handleError(topic, scope, e, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverResponseError) {
                if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.SESSION_GONE_ERROR) {
                    // case 1: the session is no longer available
                    // we try to re-initialize the session 3 times, if that does not work, we close it
                    this._logger.warn(topic, `The session has been closed, trying to re-initialize.`);
                    if (this._retryCounter < 3) {
                        // we retry this 3 times, the `retry` option in the init function is set to true and passed on 
                        this._retryCounter = retry ? this._retryCounter + 1 : 1;
                        try {
                            this._initialized = false;
                            yield this.init(this.parameterValues, true);
                        }
                        catch (e) {
                            if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                                throw e;
                            throw this._logger.handleError(topic, scope, e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._logger.handleError(topic, scope, e);
                    }
                }
                else if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.JWT_VALIDATION_ERROR) {
                    // if any of the above errors occur, we try to get a new bearer token
                    // if we get a new one, we retry 3 times (by requiring new bearer tokens every time)
                    if (this._retryCounter < 3) {
                        if (this._refreshBearerToken) {
                            this.bearerToken = yield this._refreshBearerToken();
                            this._retryCounter = retry ? this._retryCounter + 1 : 1;
                            this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Re-trying with new bearer token.');
                        }
                        else {
                            // no bearer tokens are supplied, we close the session
                            this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'No retry possible, no new bearer token was supplied. Closing Session.');
                            try {
                                yield this._closeOnFailure();
                            }
                            catch (e) { }
                            throw this._logger.handleError(topic, scope, e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.SESSION, 'Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._logger.handleError(topic, scope, e);
                    }
                }
                else {
                    throw this._logger.handleError(topic, scope, e);
                }
            }
            else {
                throw this._logger.handleError(topic, scope, e);
            }
        });
    }
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    timeout(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => setTimeout(resolve, ms));
        });
    }
    updateResponseDto(responseDto, initialParameters) {
        if (!this._responseDto) {
            this._responseDto = responseDto;
            return;
        }
        // convert parameters
        if (responseDto.parameters) {
            for (let parameterId in responseDto.parameters) {
                this._responseDto.parameters = this._responseDto.parameters || {};
                this._responseDto.parameters[parameterId] = this._responseDto.parameters[parameterId] || responseDto.parameters[parameterId];
            }
        }
        // convert outputs
        if (responseDto.outputs) {
            for (let outputId in responseDto.outputs) {
                this._responseDto.outputs = this._responseDto.outputs || {};
                if ('version' in responseDto.outputs[outputId] || !(this._responseDto.outputs[outputId] && 'version' in this._responseDto.outputs[outputId]))
                    this._responseDto.outputs[outputId] = responseDto.outputs[outputId];
            }
        }
        // convert exports
        if (responseDto.exports) {
            for (let exportId in responseDto.exports) {
                this._responseDto.exports = this._responseDto.exports || {};
                if ('version' in responseDto.exports[exportId] || !(this._responseDto.exports[exportId] && 'version' in this._responseDto.exports[exportId]))
                    this._responseDto.exports[exportId] = responseDto.exports[exportId];
            }
        }
        const parameterSet = {};
        for (let parameterId in this._responseDto.parameters) {
            if (this.parameters[parameterId])
                continue;
            this._responseDto.parameters[parameterId].id = parameterId;
            switch (true) {
                case this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.BOOL:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.COLOR:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.FILE:
                    this.parameters[parameterId] = new FileParameter_1.FileParameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.EVEN || this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.FLOAT || this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.INT || this._responseDto.parameters[parameterId].type === ISessionEngine_1.PARAMETER_TYPE.ODD:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                default:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
            }
            if (initialParameters && initialParameters[parameterId] !== undefined)
                this.parameters[parameterId].value = initialParameters[parameterId];
            parameterSet[parameterId] = {
                value: this.parameters[parameterId].value,
                valueString: this.parameters[parameterId].stringify()
            };
            if (!this.initialized)
                this.parameterValues[parameterId] = parameterSet[parameterId].valueString;
        }
        // store the initialization as the first parameter set in the history
        if (!this.initialized)
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
        for (let exportId in this._responseDto.exports) {
            if (this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.EMAIL || this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.DOWNLOAD) {
                if (!this.exports[exportId]) {
                    this._responseDto.exports[exportId].id = exportId;
                    this.exports[exportId] = new Export_1.Export(this._responseDto.exports[exportId], this);
                }
                else {
                    this.exports[exportId].updateExportDefinition(this._responseDto.exports[exportId]);
                }
            }
        }
        for (let outputId in this._responseDto.outputs) {
            if (!this.outputs[outputId]) {
                this._responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    this.outputsFreeze[outputId] = false;
                this.outputs[outputId] = new Output_1.Output(this._responseDto.outputs[outputId], this);
            }
            else {
                this.outputs[outputId].updateOutputDefinition(this._responseDto.outputs[outputId]);
            }
        }
    }
}
exports.SessionEngine = SessionEngine;
_SessionEngine_customizationProcess = new WeakMap(), _SessionEngine_parameterHistory = new WeakMap(), _SessionEngine_parameterHistoryCall = new WeakMap(), _SessionEngine_parameterHistoryForward = new WeakMap();
//# sourceMappingURL=SessionEngine.js.map