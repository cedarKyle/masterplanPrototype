import { mat4 } from 'gl-matrix';
import { IBox } from '@shapediver/viewer.shared.math';
import { ITransformation, ITreeNode } from '../interfaces/ITreeNode';
import { ITreeNodeData } from '../interfaces/ITreeNodeData';
export declare abstract class AbstractTreeNode<T extends ITreeNode<any, ITreeNodeData<any>>, U extends ITreeNodeData<any>> implements ITreeNode<T, U> {
    #private;
    /**
     * Creation of a node that can be used in the node tree.
     *
     * @param name the name of the node
     * @param parent the parent of this node
     * @param data the array of data
     * @param transformations the array of transformations
     */
    constructor(name?: string, parent?: T, data?: U[], transformations?: ITransformation[]);
    get bones(): T[];
    set bones(value: T[]);
    get boneInverses(): mat4[];
    set boneInverses(value: mat4[]);
    get boundingBox(): IBox;
    get boundingBoxViewport(): {
        [key: string]: IBox;
    };
    get children(): T[];
    get originalId(): string;
    set originalId(value: string);
    get data(): U[];
    get excludeViewports(): string[];
    set excludeViewports(value: string[]);
    get id(): string;
    get name(): string;
    set name(value: string);
    get nodeMatrix(): mat4;
    get parent(): T | undefined;
    set parent(value: T | undefined);
    get restrictViewports(): string[];
    set restrictViewports(value: string[]);
    get skinNode(): boolean;
    set skinNode(value: boolean);
    get transformations(): ITransformation[];
    set transformations(value: ITransformation[]);
    get version(): string;
    set version(value: string);
    get visible(): boolean;
    set visible(value: boolean);
    get worldMatrix(): mat4;
    addChild(child: T): boolean;
    addData(data: U): boolean;
    addTransformation(transformation: ITransformation): boolean;
    clone(): T;
    cloneInstance(): T;
    getChild(id: string): T | undefined;
    getData(id: string): U | undefined;
    getPath(): string;
    getTransformation(id: string): ITransformation | undefined;
    hasChild(child: T): boolean;
    hasData(data: U): boolean;
    hasTransformation(transformation: ITransformation): boolean;
    removeChild(child: T): boolean;
    removeData(data: U): boolean;
    removeTransformation(transformation: ITransformation): boolean;
    traverse(callback: (node: T) => void): void;
    updateVersion(): void;
}
//# sourceMappingURL=AbstractTreeNode.d.ts.map