"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfBinaryBufferCache = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
class SdtfBinaryBufferCache {
    constructor() {
        this.cacheIdFullBuffer = "full";
        this.cache = {};
    }
    /**
     * Calculates the cache key by hashing the given buffer URI.
     * Simple, __insecure__ hashing function that's short, fast, and has no dependencies.
     * @protected
     */
    calcCacheKey(uri = "") {
        let hash = 0;
        for (let i = 0; i < uri.length; i++) {
            const char = uri.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash &= hash; // Convert to 32bit integer
        }
        return new Uint32Array([hash])[0].toString(36);
    }
    /**
     * Calculates the cache ID based on the given buffer range.
     * @protected
     */
    calcCacheId(offset, length) {
        return `${offset};${length}`;
    }
    /**
     * Returns the buffer with the given key and range from cache.
     * @protected
     */
    loadFromCache(key, offset, length) {
        const item = this.cache[key];
        if (!item) {
            // Buffer not found in cache
            return undefined;
        }
        const id = this.calcCacheId(offset, length);
        if (item[id]) {
            // Buffer found in cache for this range
            return item[id];
        }
        if (item[this.cacheIdFullBuffer]) {
            // Entire buffer object stored for this key - return range.
            const buffer = item[this.cacheIdFullBuffer];
            // However, the internally stored buffer might already contain a byte offset - take this into account!
            return new DataView(buffer.buffer, buffer.byteOffset + offset, length);
        }
    }
    /**
     * Stores the buffer with the given key and range in cache.
     * @protected
     */
    storeInCache(key, id, buffer) {
        var _a;
        const item = (_a = this.cache[key]) !== null && _a !== void 0 ? _a : {};
        item[id] = buffer;
        this.cache[key] = item;
    }
    setBinaryBody(binaryBody) {
        if (!binaryBody)
            return;
        this.cache[this.calcCacheKey()] = {
            [this.cacheIdFullBuffer]: binaryBody,
        };
    }
    getBuffer(uri, offset, length) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const cacheKey = this.calcCacheKey(uri);
            return (_a = this.loadFromCache(cacheKey, offset, length)) !== null && _a !== void 0 ? _a : yield this.acquireBuffer(uri, length, offset);
        });
    }
    /**
     * Resolves and loads external buffer files - this is not supported in this mode!
     * However, this can be overwritten by other buffer cache implementations.
     * @protected
     */
    acquireBuffer(uri, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new sdk_sdtf_core_1.SdtfError("Resolution of external buffers is not supported in this mode. " +
                "Please use 'ISdtfParser.readFromFile()' or 'ISdtfParser.readFromUrl()' to instantiate the sdTF asset and to enable this functionality.");
        });
    }
}
exports.SdtfBinaryBufferCache = SdtfBinaryBufferCache;
//# sourceMappingURL=SdtfBinaryBufferCache.js.map