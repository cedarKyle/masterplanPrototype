import { ISdtfBufferCache } from "./ISdtfBufferCache";
export declare class SdtfBinaryBufferCache implements ISdtfBufferCache {
    readonly cacheIdFullBuffer = "full";
    /**
     * Caching object used to store already fetched/loaded buffers.
     * The key is a hash of the buffer's URI.
     * The id encapsulates the offset and length of the buffer; or {@link cacheIdFullBuffer} for the entire buffer.
     * @private
     */
    readonly cache: {
        [key: string]: {
            [offset: string]: DataView;
        };
    };
    constructor();
    /**
     * Calculates the cache key by hashing the given buffer URI.
     * Simple, __insecure__ hashing function that's short, fast, and has no dependencies.
     * @protected
     */
    calcCacheKey(uri?: string): string;
    /**
     * Calculates the cache ID based on the given buffer range.
     * @protected
     */
    calcCacheId(offset: number, length: number): string;
    /**
     * Returns the buffer with the given key and range from cache.
     * @protected
     */
    loadFromCache(key: string, offset: number, length: number): DataView | undefined;
    /**
     * Stores the buffer with the given key and range in cache.
     * @protected
     */
    storeInCache(key: string, id: string, buffer: DataView): void;
    setBinaryBody(binaryBody?: DataView): void;
    getBuffer(uri: string | undefined, offset: number, length: number): Promise<DataView>;
    /**
     * Resolves and loads external buffer files - this is not supported in this mode!
     * However, this can be overwritten by other buffer cache implementations.
     * @protected
     */
    acquireBuffer(uri: string | undefined, offset: number, length: number): Promise<DataView>;
}
//# sourceMappingURL=SdtfBinaryBufferCache.d.ts.map