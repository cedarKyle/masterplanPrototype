import { ISdtfIntegration, ISdtfWriteableAsset, ISdtfWriteableAttribute, ISdtfWriteableBuffer, ISdtfWriteableDataItem, ISdtfWriteableTypeHint } from "@shapediver/sdk.sdtf-core";
import { ISdtfWriteableComponentList } from "./ISdtfWriteableComponentList";
import { ISdtfWriteableComponentPostProcessor } from "./ISdtfWriteableComponentPostProcessor";
export declare class SdtfWriteableComponentPostProcessor implements ISdtfWriteableComponentPostProcessor {
    private readonly integrations;
    private readonly factory;
    constructor(integrations: ISdtfIntegration[]);
    optimize(asset: ISdtfWriteableAsset): ISdtfWriteableComponentList;
    /**
     * Tries to find a suitable registered integration for each given component and runs the integration's writer for
     * each individual component.
     * @private
     */
    processDataComponents(components: (ISdtfWriteableAttribute | ISdtfWriteableDataItem)[]): void;
    /**
     * Tries to find a suitable registered integration for all given components and runs the integration's
     * post-processor for all supported component (grouped).
     * @private
     */
    postProcessDataComponents(components: (ISdtfWriteableAttribute | ISdtfWriteableDataItem)[]): void;
    /**
     * Bottom-up approach to complement a missing type hint in node and chunk components.
     * When all data items of a node are of a similar type hint, the respective type hint will be added to the node.
     * When all nodes of a chunk are of a similar type hint, the respective type hint will be added to the chunk.
     * @private
     */
    complementTypeHints(componentList: ISdtfWriteableComponentList): void;
    /**
     * Generates a list of unique type hints for all components in the list and resets the component references accordingly.
     * @private
     */
    removeDuplicatedTypeHints(componentList: ISdtfWriteableComponentList): void;
    /**
     * Helper function to compare the two given type hints.
     * Returns true, if both type hints have the same `name` property and share the same `additionalProperties`.
     * However, the order of additional properties is not considered.
     * @private
     */
    areTypeHintsSimilar(t1: ISdtfWriteableTypeHint, t2: ISdtfWriteableTypeHint): boolean;
    /**
     * Merges all individual buffers by their URI.
     * @private
     */
    resolveBuffers(componentList: ISdtfWriteableComponentList): void;
    /**
     * Creates a new writeable buffer that holds the data of all given buffers.
     * It returns the newly created buffer and a list of `byte offsets` corresponding to the given buffer.
     * This allows to track down the individual buffers in the merged one.
     * @private
     * @returns - [ merged buffer, byte offset for each buffer ]
     */
    mergeBuffers(uri: string, buffers: ISdtfWriteableBuffer[]): [ISdtfWriteableBuffer, number[]];
    /**
     * Creates a new writeable buffer that holds the data of all given buffers (hard copy!).
     * It returns the newly created buffer and each buffer's `byte offset`.
     * @private
     * @returns - [ merged buffer, byte offset for each buffer ]
     */
    mergeBufferData(buffers: ISdtfWriteableBuffer[]): [ArrayBuffer, number[]];
}
//# sourceMappingURL=SdtfWriteableComponentPostProcessor.d.ts.map