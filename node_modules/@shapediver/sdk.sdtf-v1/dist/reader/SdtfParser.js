"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfParser = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const browser_or_node_1 = require("browser-or-node");
const SdtfBinarySdtf_1 = require("../binary_sdtf/SdtfBinarySdtf");
const SdtfBinaryBufferCache_1 = require("../buffer_cache/SdtfBinaryBufferCache");
const SdtfFileBufferCache_1 = require("../buffer_cache/SdtfFileBufferCache");
const SdtfHttpBufferCache_1 = require("../buffer_cache/SdtfHttpBufferCache");
const SdtfHttpClient_1 = require("../http/SdtfHttpClient");
const SdtfComponentFactoryWrapper_1 = require("../structure/SdtfComponentFactoryWrapper");
const SdtfFileUtils_1 = require("../utils/SdtfFileUtils");
const SdtfReadableAsset_1 = require("./components/SdtfReadableAsset");
const SdtfDataParser_1 = require("./SdtfDataParser");
const SdtfReadableComponentFactory_1 = require("./SdtfReadableComponentFactory");
class SdtfParser {
    constructor(config) {
        this.config = config;
        this.binarySdtfParser = new SdtfBinarySdtf_1.SdtfBinarySdtf();
        this.componentFactory = new SdtfComponentFactoryWrapper_1.SdtfComponentFactoryWrapper();
        this.fileUtils = new SdtfFileUtils_1.SdtfFileUtils();
    }
    readFromFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // Quick check to make sure we are in NodeJs
            if (browser_or_node_1.isBrowser)
                throw new sdk_sdtf_core_1.SdtfError("Reading from file is only supported in Node.js.");
            let absolutePath, buffer;
            try {
                absolutePath = this.fileUtils.toAbsolutePath(path);
                buffer = yield this.fileUtils.readFile(absolutePath);
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(`Cannot read sdTF-file: ${e.message}`);
            }
            const [contentBuffer, binaryBuffer] = this.binarySdtfParser.parseBinarySdtf(buffer);
            const jsonContent = this.binarySdtfParser.readJsonContent(contentBuffer);
            const bufferCache = new SdtfFileBufferCache_1.SdtfFileBufferCache(absolutePath);
            bufferCache.setBinaryBody(binaryBuffer);
            return this.createSdtfAsset(jsonContent, bufferCache);
        });
    }
    readFromUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpClient = new SdtfHttpClient_1.SdtfHttpClient(url, this.config.authToken);
            const [contentBuffer, binaryBuffer] = yield httpClient.getJsonContent();
            const jsonContent = this.binarySdtfParser.readJsonContent(contentBuffer);
            const bufferCache = new SdtfHttpBufferCache_1.SdtfHttpBufferCache(httpClient);
            bufferCache.setBinaryBody(binaryBuffer);
            return this.createSdtfAsset(jsonContent, bufferCache);
        });
    }
    readFromBuffer(sdtf) {
        const [contentBuffer, binaryBuffer] = this.binarySdtfParser.parseBinarySdtf(sdtf);
        const jsonContent = this.binarySdtfParser.readJsonContent(contentBuffer);
        const bufferCache = new SdtfBinaryBufferCache_1.SdtfBinaryBufferCache();
        bufferCache.setBinaryBody(binaryBuffer);
        return this.createSdtfAsset(jsonContent, bufferCache);
    }
    /** Instantiates a sdTF asset that represents the given content. */
    createSdtfAsset(content, bufferCache) {
        const componentList = this.componentFactory.createFromJson(content);
        const readableComponentFactory = new SdtfReadableComponentFactory_1.SdtfReadableComponentFactory(bufferCache, new SdtfDataParser_1.SdtfDataParser(this.config.integrations));
        return this.buildReadableAsset(componentList, readableComponentFactory);
    }
    /**
     * Transforms the given component list into a readable sdTF asset.
     * @private
     */
    buildReadableAsset(componentList, factory) {
        const fileInfo = factory.createFileInfo(componentList.fileInfo);
        const asset = new SdtfReadableAsset_1.SdtfReadableAsset(fileInfo);
        asset.typeHints = componentList.typeHints.map(t => factory.createTypeHint(t));
        asset.buffers = componentList.buffers.map(b => factory.createBuffer(b));
        asset.bufferViews = componentList.bufferViews.map(b => factory.createBufferView(b, asset.buffers));
        asset.accessors = componentList.accessors.map(a => factory.createAccessor(a, asset.bufferViews));
        asset.attributes = componentList.attributes.map(a => factory.createAttributes(a, asset.accessors, asset.typeHints));
        asset.items = componentList.items.map(d => factory.createDataItem(d, asset.accessors, asset.attributes, asset.typeHints));
        asset.nodes = componentList.nodes.map(n => factory.createNode(n, asset.attributes, asset.items, asset.typeHints));
        asset.chunks = componentList.chunks.map(c => factory.createChunk(c, asset.attributes, asset.items, asset.typeHints));
        factory.setChunkReferences(asset.chunks, componentList.chunks, asset.nodes);
        factory.setNodeReferences(asset.nodes, componentList.nodes);
        return asset;
    }
}
exports.SdtfParser = SdtfParser;
//# sourceMappingURL=SdtfParser.js.map