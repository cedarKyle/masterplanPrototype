"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfReadableComponentFactory = void 0;
const SdtfReadableAccessor_1 = require("./components/SdtfReadableAccessor");
const SdtfReadableAttributes_1 = require("./components/SdtfReadableAttributes");
const SdtfReadableBuffer_1 = require("./components/SdtfReadableBuffer");
const SdtfReadableBufferView_1 = require("./components/SdtfReadableBufferView");
const SdtfReadableDataItem_1 = require("./components/SdtfReadableDataItem");
const SdtfReadableFileInfo_1 = require("./components/SdtfReadableFileInfo");
const SdtfReadableNode_1 = require("./components/SdtfReadableNode");
const SdtfReadableTypeHint_1 = require("./components/SdtfReadableTypeHint");
class SdtfReadableComponentFactory {
    constructor(bufferCache, dataParser) {
        this.bufferCache = bufferCache;
        this.dataParser = dataParser;
    }
    createAccessor(accessor, bufferViews) {
        // Instantiate object
        const readableAccessor = new SdtfReadableAccessor_1.SdtfReadableAccessor(bufferViews[accessor.bufferView]);
        readableAccessor.bufferView = bufferViews[accessor.bufferView];
        readableAccessor.id = accessor.id;
        readableAccessor.additionalProperties = accessor.additionalProperties;
        return readableAccessor;
    }
    createAttributes(attribute, accessors, typeHints) {
        const readableAttributes = new SdtfReadableAttributes_1.SdtfReadableAttributes();
        Object.entries(attribute.entries).forEach(([name, attribute]) => {
            const readableAttribute = new SdtfReadableAttributes_1.SdtfReadableAttribute(this.dataParser);
            if (attribute.accessor !== undefined)
                readableAttribute.accessor = accessors[attribute.accessor];
            if (attribute.typeHint !== undefined)
                readableAttribute.typeHint = typeHints[attribute.typeHint];
            readableAttribute.value = attribute.value;
            readableAttributes.entries[name] = readableAttribute;
        });
        return readableAttributes;
    }
    createBuffer(buffer) {
        const readableBuffer = new SdtfReadableBuffer_1.SdtfReadableBuffer(buffer.byteLength, this.bufferCache);
        readableBuffer.uri = buffer.uri;
        readableBuffer.additionalProperties = buffer.additionalProperties;
        return readableBuffer;
    }
    createBufferView(bufferView, buffers) {
        const readableBufferView = new SdtfReadableBufferView_1.SdtfReadableBufferView(buffers[bufferView.buffer], bufferView.byteLength, bufferView.byteOffset, bufferView.contentType);
        readableBufferView.contentEncoding = bufferView.contentEncoding;
        readableBufferView.name = bufferView.name;
        readableBufferView.additionalProperties = bufferView.additionalProperties;
        return readableBufferView;
    }
    createChunk(chunk, attributes, dataItems, typeHints) {
        return this.createNode(chunk, attributes, dataItems, typeHints);
    }
    createDataItem(dataItem, accessors, attributes, typeHints) {
        const readableDataItem = new SdtfReadableDataItem_1.SdtfReadableDataItem(this.dataParser);
        if (dataItem.accessor !== undefined)
            readableDataItem.accessor = accessors[dataItem.accessor];
        if (dataItem.attributes !== undefined)
            readableDataItem.attributes = attributes[dataItem.attributes];
        if (dataItem.typeHint !== undefined)
            readableDataItem.typeHint = typeHints[dataItem.typeHint];
        readableDataItem.value = dataItem.value;
        readableDataItem.additionalProperties = dataItem.additionalProperties;
        return readableDataItem;
    }
    createFileInfo(fileInfo) {
        const readableFileInfo = new SdtfReadableFileInfo_1.SdtfReadableFileInfo(fileInfo.version);
        readableFileInfo.copyright = fileInfo.copyright;
        readableFileInfo.generator = fileInfo.generator;
        readableFileInfo.version = fileInfo.version;
        readableFileInfo.additionalProperties = fileInfo.additionalProperties;
        return readableFileInfo;
    }
    createNode(node, attributes, dataItems, typeHints) {
        const readableNode = new SdtfReadableNode_1.SdtfReadableNode();
        // NOTE the node property is ignored on purpose and later linked via `setNodeReferences`
        if (node.attributes !== undefined)
            readableNode.attributes = attributes[node.attributes];
        readableNode.items = node.items.map(d => dataItems[d]);
        readableNode.name = node.name;
        if (node.typeHint !== undefined)
            readableNode.typeHint = typeHints[node.typeHint];
        readableNode.additionalProperties = node.additionalProperties;
        return readableNode;
    }
    createTypeHint(typeHint) {
        const readableTypeHint = new SdtfReadableTypeHint_1.SdtfReadableTypeHint(typeHint.name);
        readableTypeHint.additionalProperties = typeHint.additionalProperties;
        return readableTypeHint;
    }
    setChunkReferences(readableChunks, chunks, readableNodes) {
        chunks.forEach((chunk, index) => {
            const readableChunk = readableChunks[index];
            readableChunk.nodes = chunk.nodes.map(nodePos => readableNodes[nodePos]);
        });
    }
    setNodeReferences(readableNodes, nodes) {
        nodes.forEach((node, index) => {
            const readableNode = readableNodes[index];
            readableNode.nodes = node.nodes.map(nodePos => readableNodes[nodePos]);
        });
    }
}
exports.SdtfReadableComponentFactory = SdtfReadableComponentFactory;
//# sourceMappingURL=SdtfReadableComponentFactory.js.map