"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfComponentFactoryWrapper = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const SdtfComponentValidator_1 = require("../validation/SdtfComponentValidator");
const SdtfComponentFactory_1 = require("./SdtfComponentFactory");
class SdtfComponentFactoryWrapper {
    constructor() {
        this.factory = new SdtfComponentFactory_1.SdtfComponentFactory();
    }
    createFromJson(json) {
        const f = this.factory; // Alias to shorten lines
        return this.createComponentList({
            accessors: this.buildFromArray(json, f.propertyNameAccessors, f.createAccessor.bind(f)),
            asset: this.buildFromObject(json, "", f.createAsset.bind(f)),
            attributes: this.buildFromArray(json, f.propertyNameAttributes, f.createAttributes.bind(f)),
            buffers: this.buildFromArray(json, f.propertyNameBuffers, f.createBuffer.bind(f)),
            bufferViews: this.buildFromArray(json, f.propertyNameBufferViews, f.createBufferView.bind(f)),
            chunks: this.buildFromArray(json, f.propertyNameChunks, f.createChunk.bind(f)),
            items: this.buildFromArray(json, f.propertyNameDataItems, f.createDataItem.bind(f)),
            fileInfo: this.buildFromObject(json, f.propertyNameFileInfo, f.createFileInfo.bind(f)),
            nodes: this.buildFromArray(json, f.propertyNameNodes, f.createNode.bind(f)),
            typeHints: this.buildFromArray(json, f.propertyNameTypeHints, f.createTypeHint.bind(f)),
        });
    }
    createFromReadable(readableComponents) {
        const f = this.factory; // Alias to shorten lines
        const partialComponentList = {
            accessors: readableComponents.accessors.map(a => f.createAccessor(a.toDataObject())),
            asset: f.createAsset(readableComponents.asset.toDataObject()),
            attributes: readableComponents.attributes.map(a => f.createAttributes(a.toDataObject())),
            buffers: readableComponents.buffers.map(b => f.createBuffer(b.toDataObject())),
            bufferViews: readableComponents.bufferViews.map(b => f.createBufferView(b.toDataObject())),
            chunks: readableComponents.chunks.map(c => f.createChunk(c.toDataObject())),
            items: readableComponents.items.map(i => f.createDataItem(i.toDataObject())),
            fileInfo: f.createFileInfo(readableComponents.fileInfo.toDataObject()),
            nodes: readableComponents.nodes.map(n => f.createNode(n.toDataObject())),
            typeHints: readableComponents.typeHints.map(y => f.createTypeHint(y.toDataObject())),
        };
        this.mapHierarchyRepresentation(partialComponentList, readableComponents);
        return this.createComponentList(partialComponentList);
    }
    createFromWriteable(writeableComponents) {
        var _a;
        const f = this.factory; // Alias to shorten lines
        const partialComponentList = {
            accessors: writeableComponents.accessors.map(a => f.createAccessor(a.toDataObject())),
            asset: f.createAsset(writeableComponents.asset.toDataObject()),
            attributes: writeableComponents.attributes.map(a => f.createAttributes(a.toDataObject())),
            buffers: writeableComponents.buffers.map(b => f.createBuffer(b.toDataObject())),
            bufferViews: writeableComponents.bufferViews.map(b => f.createBufferView(b.toDataObject())),
            chunks: writeableComponents.chunks.map(c => f.createChunk(c.toDataObject())),
            items: writeableComponents.items.map(i => f.createDataItem(i.toDataObject())),
            fileInfo: f.createFileInfo(writeableComponents.fileInfo.toDataObject()),
            nodes: writeableComponents.nodes.map(n => f.createNode(n.toDataObject())),
            typeHints: writeableComponents.typeHints.map(t => f.createTypeHint(t.toDataObject())),
            // The writeable-optimizer merges all buffers, thus there is only a single binary buffer
            binaryBody: (_a = writeableComponents.buffers.find(buffer => !buffer.uri)) === null || _a === void 0 ? void 0 : _a.data,
        };
        this.mapHierarchyRepresentation(partialComponentList, writeableComponents);
        return this.createComponentList(partialComponentList);
    }
    /**
     * Validates every partial-component and returns a corresponding component list.
     * @private
     * @throws {@link SdtfError} when a partial-component is invalid.
     */
    createComponentList(partialComponents) {
        const validator = new SdtfComponentValidator_1.SdtfComponentValidator(partialComponents);
        // NOTE the validation order is important here!
        const asset = partialComponents.asset;
        validator.validateAsset(asset);
        const fileInfo = partialComponents.fileInfo;
        validator.validateFileInfo(fileInfo);
        const buffers = partialComponents.buffers.map(b => {
            validator.validateBuffer(b);
            return b;
        });
        const bufferViews = partialComponents.bufferViews.map(b => {
            validator.validateBufferView(b);
            return b;
        });
        const accessors = partialComponents.accessors.map(a => {
            validator.validateAccessor(a);
            return a;
        });
        const typeHints = partialComponents.typeHints.map(t => {
            validator.validateTypeHint(t);
            return t;
        });
        const attributes = partialComponents.attributes.map(a => {
            validator.validateAttributes(a);
            return a;
        });
        const chunks = partialComponents.chunks.map(c => {
            validator.validateChunk(c);
            return c;
        });
        const dataItems = partialComponents.items.map(d => {
            validator.validateDataItem(d);
            return d;
        });
        const nodes = partialComponents.nodes.map(n => {
            validator.validateNode(n);
            return n;
        });
        return {
            accessors,
            asset,
            attributes,
            buffers,
            bufferViews,
            chunks,
            items: dataItems,
            nodes,
            typeHints,
            fileInfo,
            binaryBody: partialComponents.binaryBody,
        };
    }
    /**
     * Validation wrapper around the given create function for a content object of the specified name.
     * @private
     * @throws {@link SdtfError} when something goes wrong.
     */
    buildFromObject(jsonObject, propertyName, createFn) {
        const componentDataObject = (propertyName) ? jsonObject[propertyName] : jsonObject;
        if (!(0, sdk_sdtf_core_1.isDataObject)(componentDataObject))
            throw new sdk_sdtf_core_1.SdtfError(`Invalid item at ${propertyName}: Item must be an object.`);
        return createFn(componentDataObject);
    }
    /**
     * Validation wrapper around the given create function for a content array of the specified name.
     * @private
     * @throws {@link SdtfError} when something goes wrong.
     */
    buildFromArray(jsonArray, propertyName, createFn) {
        const componentDataArray = jsonArray[propertyName];
        if (componentDataArray === undefined)
            return [];
        if (!Array.isArray(componentDataArray))
            throw new sdk_sdtf_core_1.SdtfError(`Invalid content property: '${propertyName}' must be an array.`);
        return componentDataArray.map((componentDataItem, i) => {
            if (!(0, sdk_sdtf_core_1.isDataObject)(componentDataItem))
                throw new sdk_sdtf_core_1.SdtfError(`Invalid item at ${propertyName}[${i}]: Item must be an object.`);
            return createFn(componentDataItem);
        });
    }
    /**
     * Readable and writeable components use object references to represent the hierarchy.
     * However, sdTF components use reference IDs for this.
     * This method maps the object representation into a reference ID representation.
     * @private
     */
    mapHierarchyRepresentation(target, src) {
        // Helper to find the element position in an array
        const getIndex = (list, componentId) => {
            if (!componentId)
                return -1;
            return list.findIndex((c) => c.componentId === componentId);
        };
        target.asset.fileInfo = 0;
        target.accessors.forEach((accessor, index) => {
            var _a;
            const srcComponent = src.accessors[index];
            accessor.bufferView = getIndex(src.bufferViews, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.bufferView) === null || _a === void 0 ? void 0 : _a.componentId);
        });
        target.attributes.forEach((attributes, index) => {
            if (!attributes.entries)
                return;
            Object.entries(attributes.entries).forEach(([name, attribute]) => {
                var _a, _b;
                const srcComponent = src.attributes[index].entries[name];
                if (srcComponent.accessor)
                    attribute.accessor = getIndex(src.accessors, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.accessor) === null || _a === void 0 ? void 0 : _a.componentId);
                if (srcComponent.typeHint)
                    attribute.typeHint = getIndex(src.typeHints, (_b = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.typeHint) === null || _b === void 0 ? void 0 : _b.componentId);
            });
        });
        target.bufferViews.forEach((bufferView, index) => {
            var _a;
            const srcComponent = src.bufferViews[index];
            bufferView.buffer = getIndex(src.buffers, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.buffer) === null || _a === void 0 ? void 0 : _a.componentId);
        });
        target.chunks.forEach((chunk, index) => {
            var _a, _b;
            const srcComponent = src.chunks[index];
            if (srcComponent.attributes)
                chunk.attributes = getIndex(src.attributes, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.attributes) === null || _a === void 0 ? void 0 : _a.componentId);
            chunk.items = srcComponent.items.map(item => getIndex(src.items, item === null || item === void 0 ? void 0 : item.componentId));
            chunk.nodes = srcComponent.nodes.map(node => getIndex(src.nodes, node === null || node === void 0 ? void 0 : node.componentId));
            if (srcComponent.typeHint)
                chunk.typeHint = getIndex(src.typeHints, (_b = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.typeHint) === null || _b === void 0 ? void 0 : _b.componentId);
        });
        target.items.forEach((dataItem, index) => {
            var _a, _b, _c;
            const srcComponent = src.items[index];
            if (srcComponent.accessor)
                dataItem.accessor = getIndex(src.accessors, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.accessor) === null || _a === void 0 ? void 0 : _a.componentId);
            if (srcComponent.attributes)
                dataItem.attributes = getIndex(src.attributes, (_b = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.attributes) === null || _b === void 0 ? void 0 : _b.componentId);
            if (srcComponent.typeHint)
                dataItem.typeHint = getIndex(src.typeHints, (_c = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.typeHint) === null || _c === void 0 ? void 0 : _c.componentId);
        });
        target.nodes.forEach((node, index) => {
            var _a, _b;
            const srcComponent = src.nodes[index];
            if (srcComponent.attributes)
                node.attributes = getIndex(src.attributes, (_a = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.attributes) === null || _a === void 0 ? void 0 : _a.componentId);
            node.items = srcComponent.items.map(item => getIndex(src.items, item === null || item === void 0 ? void 0 : item.componentId));
            node.nodes = srcComponent.nodes.map(node => getIndex(src.nodes, node === null || node === void 0 ? void 0 : node.componentId));
            if (srcComponent.typeHint)
                node.typeHint = getIndex(src.typeHints, (_b = srcComponent === null || srcComponent === void 0 ? void 0 : srcComponent.typeHint) === null || _b === void 0 ? void 0 : _b.componentId);
        });
    }
}
exports.SdtfComponentFactoryWrapper = SdtfComponentFactoryWrapper;
//# sourceMappingURL=SdtfComponentFactoryWrapper.js.map