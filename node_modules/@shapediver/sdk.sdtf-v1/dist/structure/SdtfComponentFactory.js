"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfComponentFactory = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const SdtfPartialAccessor_1 = require("./components/SdtfPartialAccessor");
const SdtfPartialAsset_1 = require("./components/SdtfPartialAsset");
const SdtfPartialAttributes_1 = require("./components/SdtfPartialAttributes");
const SdtfPartialBuffer_1 = require("./components/SdtfPartialBuffer");
const SdtfPartialBufferView_1 = require("./components/SdtfPartialBufferView");
const SdtfPartialDataItem_1 = require("./components/SdtfPartialDataItem");
const SdtfPartialFileInfo_1 = require("./components/SdtfPartialFileInfo");
const SdtfPartialNode_1 = require("./components/SdtfPartialNode");
const SdtfPartialTypeHint_1 = require("./components/SdtfPartialTypeHint");
class SdtfComponentFactory {
    constructor() {
        this.propertyNameAccessors = "accessors";
        this.propertyNameAttributes = "attributes";
        this.propertyNameBufferViews = "bufferViews";
        this.propertyNameBuffers = "buffers";
        this.propertyNameChunks = "chunks";
        this.propertyNameDataItems = "items";
        this.propertyNameFileInfo = "asset";
        this.propertyNameFileInfoAlternative = "fileInfo"; // We might read from readable object as well
        this.propertyNameNodes = "nodes";
        this.propertyNameTypeHints = "typeHints";
    }
    createAccessor(accessorData) {
        const accessor = new SdtfPartialAccessor_1.SdtfPartialAccessor();
        // Set properties of allowed types
        if ((0, sdk_sdtf_core_1.isNumber)(accessorData.bufferView))
            accessor.bufferView = accessorData.bufferView;
        if (typeof accessorData.id === "string")
            accessor.id = accessorData.id;
        // Add additional properties
        Object
            .entries(accessorData)
            .filter(([k, _]) => k !== "bufferView" && k !== "id")
            .forEach(([k, v]) => accessor.additionalProperties[k] = v);
        return accessor;
    }
    createAsset(assetData) {
        const asset = new SdtfPartialAsset_1.SdtfPartialAsset();
        // There can only be one file info object
        asset.fileInfo = 0;
        // Add additional properties
        Object
            .entries(assetData)
            .filter(([k, _]) => k !== this.propertyNameAccessors &&
            k !== this.propertyNameAttributes &&
            k !== this.propertyNameBufferViews &&
            k !== this.propertyNameBuffers &&
            k !== this.propertyNameChunks &&
            k !== this.propertyNameDataItems &&
            k !== this.propertyNameFileInfo &&
            k !== this.propertyNameFileInfoAlternative &&
            k !== this.propertyNameNodes &&
            k !== this.propertyNameTypeHints)
            .forEach(([k, v]) => asset.additionalProperties[k] = v);
        return asset;
    }
    createAttributes(attributesData) {
        const attributes = new SdtfPartialAttributes_1.SdtfPartialAttributes();
        // Instantiate individual attributes and set properties
        Object
            .entries(attributesData)
            .forEach(([name, data], i) => {
            if (!(0, sdk_sdtf_core_1.isDataObject)(data))
                throw new sdk_sdtf_core_1.SdtfError(`Invalid attribute data: Item [${i}] must be an object.`);
            const attribute = new SdtfPartialAttributes_1.SdtfAttribute();
            // Set properties of allowed types
            if (typeof data.accessor === "number")
                attribute.accessor = data.accessor;
            if (typeof data.typeHint === "number")
                attribute.typeHint = data.typeHint;
            attribute.value = data.value;
            attributes.entries[name] = attribute;
        });
        return attributes;
    }
    createBuffer(bufferData) {
        const buffer = new SdtfPartialBuffer_1.SdtfPartialBuffer();
        // Set properties of allowed types
        if ((0, sdk_sdtf_core_1.isNumber)(bufferData.byteLength))
            buffer.byteLength = bufferData.byteLength;
        if (typeof bufferData.uri === "string")
            buffer.uri = bufferData.uri;
        // Add additional properties
        Object
            .entries(bufferData)
            .filter(([k, _]) => k !== "byteLength" && k !== "uri")
            .forEach(([k, v]) => buffer.additionalProperties[k] = v);
        return buffer;
    }
    createBufferView(bufferViewData) {
        const bufferView = new SdtfPartialBufferView_1.SdtfPartialBufferView();
        // Set properties of allowed types
        if ((0, sdk_sdtf_core_1.isNumber)(bufferViewData.buffer))
            bufferView.buffer = bufferViewData.buffer;
        if ((0, sdk_sdtf_core_1.isNumber)(bufferViewData.byteLength))
            bufferView.byteLength = bufferViewData.byteLength;
        if ((0, sdk_sdtf_core_1.isNumber)(bufferViewData.byteOffset))
            bufferView.byteOffset = bufferViewData.byteOffset;
        if (typeof bufferViewData.contentEncoding === "string")
            bufferView.contentEncoding = bufferViewData.contentEncoding;
        if (typeof bufferViewData.contentType === "string")
            bufferView.contentType = bufferViewData.contentType;
        if (typeof bufferViewData.name === "string")
            bufferView.name = bufferViewData.name;
        // Add additional properties
        Object
            .entries(bufferViewData)
            .filter(([k, _]) => k !== "buffer" && k !== "byteLength" && k !== "byteOffset" && k !== "contentEncoding" && k !== "contentType" && k !== "name")
            .forEach(([k, v]) => bufferView.additionalProperties[k] = v);
        return bufferView;
    }
    createChunk(chunkData) {
        return this.createNode(chunkData);
    }
    createDataItem(dataItemData) {
        const dataItem = new SdtfPartialDataItem_1.SdtfPartialDataItem();
        // Set properties of allowed types
        if ((0, sdk_sdtf_core_1.isNumber)(dataItemData.accessor))
            dataItem.accessor = dataItemData.accessor;
        if ((0, sdk_sdtf_core_1.isNumber)(dataItemData.attributes))
            dataItem.attributes = dataItemData.attributes;
        if ((0, sdk_sdtf_core_1.isNumber)(dataItemData.typeHint))
            dataItem.typeHint = dataItemData.typeHint;
        dataItem.value = dataItemData.value;
        // Add additional properties
        Object
            .entries(dataItemData)
            .filter(([k, _]) => k !== "accessor" && k !== "attributes" && k !== "typeHint" && k !== "value")
            .forEach(([k, v]) => dataItem.additionalProperties[k] = v);
        return dataItem;
    }
    createFileInfo(fileInfoData) {
        const fileInfo = new SdtfPartialFileInfo_1.SdtfPartialFileInfo();
        // Set properties of allowed types
        if (typeof fileInfoData.copyright === "string")
            fileInfo.copyright = fileInfoData.copyright;
        if (typeof fileInfoData.generator === "string")
            fileInfo.generator = fileInfoData.generator;
        if (typeof fileInfoData.version === "string")
            fileInfo.version = fileInfoData.version;
        // Add additional properties
        Object
            .entries(fileInfoData)
            .filter(([k, _]) => k !== "copyright" && k !== "generator" && k !== "version")
            .forEach(([k, v]) => fileInfo.additionalProperties[k] = v);
        return fileInfo;
    }
    createNode(nodeData) {
        const node = new SdtfPartialNode_1.SdtfPartialNode();
        // Set properties of allowed types
        if ((0, sdk_sdtf_core_1.isNumber)(nodeData.attributes))
            node.attributes = nodeData.attributes;
        if ((0, sdk_sdtf_core_1.isNumberArray)(nodeData.items))
            node.items = nodeData.items;
        if (typeof nodeData.name === "string")
            node.name = nodeData.name;
        if ((0, sdk_sdtf_core_1.isNumberArray)(nodeData.nodes))
            node.nodes = nodeData.nodes;
        if ((0, sdk_sdtf_core_1.isNumber)(nodeData.typeHint))
            node.typeHint = nodeData.typeHint;
        // Add additional properties
        Object
            .entries(nodeData)
            .filter(([k, _]) => k !== "attributes" && k !== "items" && k !== "name" && k !== "nodes" && k !== "typeHint")
            .forEach(([k, v]) => node.additionalProperties[k] = v);
        return node;
    }
    createTypeHint(typeHintData) {
        const typeHint = new SdtfPartialTypeHint_1.SdtfPartialTypeHint();
        // Set properties of allowed types
        if (typeof typeHintData.name === "string")
            typeHint.name = typeHintData.name;
        // Add additional properties
        Object
            .entries(typeHintData)
            .filter(([k, _]) => k !== "name")
            .forEach(([k, v]) => typeHint.additionalProperties[k] = v);
        return typeHint;
    }
}
exports.SdtfComponentFactory = SdtfComponentFactory;
//# sourceMappingURL=SdtfComponentFactory.js.map