"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfHttpClient = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const axios_1 = __importDefault(require("axios"));
const SdtfBinarySdtf_1 = require("../binary_sdtf/SdtfBinarySdtf");
/** HTTP client of a single sdTF asset. */
class SdtfHttpClient {
    constructor(jsonContentUrl, authToken) {
        this.binarySdtfParser = new SdtfBinarySdtf_1.SdtfBinarySdtf();
        // This initializes this http client for the specified sdTF asset
        this.jsonContentUrl = jsonContentUrl;
        // Initialize tha basic HTTP header object
        this.basicHttpHeader = {};
        if (authToken)
            this.basicHttpHeader.authorization = "Bearer " + authToken;
    }
    /**
     * Constructs the URL of this sdTF asset for the given URI.
     * The URIs of all sdTF buffers of this sdTF asset are relative to the path of the JSON content file.
     * When no URI is specified, the URL of the JSON content is returned.
     * @private
     */
    calcUrl(uri) {
        if (!uri)
            return this.jsonContentUrl;
        const index = this.jsonContentUrl.lastIndexOf("/");
        return `${this.jsonContentUrl.substring(0, index)}/${uri}`;
    }
    getJsonContent() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data, partial, } = yield this.fetch(this.jsonContentUrl, 0, this.binarySdtfParser.binaryHeaderLength);
                if (partial) {
                    // Partial requests are supported by the server - fetch json content next
                    const [contentLength, _] = this.binarySdtfParser.readHeader(data);
                    const jsonContentBuffer = yield this.fetch(this.jsonContentUrl, 20, contentLength);
                    return [new DataView(jsonContentBuffer.data), undefined];
                }
                else {
                    // Entire sdTF has been returned - parse and return
                    return this.binarySdtfParser.parseBinarySdtf(data);
                }
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(`Could not fetch sdTF JSON content: ${e.message}`);
            }
        });
    }
    getBinaryBuffer(uri, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data, partial } = yield this.fetch(this.calcUrl(uri), offset, length);
                if (partial) {
                    // Partial requests are supported by the server - partial buffer was fetched
                    return [new DataView(data), undefined];
                }
                else {
                    // Partial requests are supported by the server - entire buffer was fetched
                    return [new DataView(data, offset, length), data];
                }
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(`Could not fetch sdTF binary buffer: ${e.message}`);
            }
        });
    }
    /**
     * Checks if the server supports HTTP range requests by sending a HEAD request and analyzing the response header.
     * When the server supports range requests, only the requested part is fetched.
     * Otherwise, the entire sdTF file is fetched.
     * @private
     * @param url
     * @param offset - Zero-based byte index at which to begin (inclusive).
     * @param length - Length of the buffer.
     * @throws {@link SdtfError} when the request was not successful.
     */
    fetch(url, offset, length) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                response = yield axios_1.default.head(url, { headers: this.basicHttpHeader });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            // Validate response status
            if (response.status > 299)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            // Check if the content has been encoded (no range request possible)
            const contentEncoding = !!((_a = response.headers["Content-Encoding"]) !== null && _a !== void 0 ? _a : response.headers["content-encoding"]);
            // Check if HTTP range requests are supported
            const acceptRanges = (_b = response.headers["Accept-Ranges"]) !== null && _b !== void 0 ? _b : response.headers["accept-ranges"];
            // When the data has not been encoded and range requests are supported -> fetch partially.
            // Otherwise -> fetch all.
            const rangeRequestsSupported = (!contentEncoding && acceptRanges === "bytes");
            // Fetch the actual data.
            const data = (rangeRequestsSupported) ?
                yield this.fetchPartially(url, offset, length) :
                yield this.fetchFully(url);
            // This is required to support Node.js as well as Browsers
            const buffer = (data instanceof ArrayBuffer) ? data : Uint8Array.from(data).buffer;
            return {
                data: buffer,
                partial: rangeRequestsSupported,
            };
        });
    }
    /**
     * Sends an HTTP range request to fetch only the requested part.
     * Assumes, that the server supports HTTP range requests and that the response is NOT compressed.
     * Otherwise, Axios throws an `ERR_CONTENT_DECODING_FAILED` error in the browser.
     * @private
     * @param url
     * @param offset - Zero-based byte index at which to begin (inclusive).
     * @param length - Length of the buffer.
     * @throws {@link SdtfError} when the request was not successful.
     */
    fetchPartially(url, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                response = yield axios_1.default.get(url, {
                    headers: Object.assign(Object.assign({}, this.basicHttpHeader), { range: `bytes=${offset}-${offset + length - 1}` }),
                    responseType: "arraybuffer",
                });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            // Validate response status
            if (response.status === 416)
                throw new sdk_sdtf_core_1.SdtfError("Invalid range requested.");
            if (response.status !== 206)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            return response.data;
        });
    }
    /**
     * Fetches the entire sdTF file (either a binary sdTF or just binary data).
     * Fallback when HTTP range requests are not supported by the server.
     * @private
     * @param url
     * @throws {@link SdtfError} when the request was not successful.
     */
    fetchFully(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                // NOTE: Axios automatically decodes the body (e.g. GZIP compression)
                response = yield axios_1.default.get(url, {
                    headers: this.basicHttpHeader,
                    responseType: "arraybuffer",
                });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            // Validate response status
            if (response.status !== 200)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            return response.data;
        });
    }
}
exports.SdtfHttpClient = SdtfHttpClient;
//# sourceMappingURL=SdtfHttpClient.js.map