"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plane = void 0;
const gl_matrix_1 = require("gl-matrix");
class Plane {
    // #region Constructors (1)
    constructor(_normal = gl_matrix_1.vec3.fromValues(1, 0, 0), _constant = 0) {
        this._normal = _normal;
        this._constant = _constant;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get constant() {
        return this._constant;
    }
    set constant(value) {
        this._constant = value;
    }
    get normal() {
        return this._normal;
    }
    set normal(value) {
        this._normal = value;
    }
    // #endregion Public Accessors (4)
    // #region Public Methods (7)
    applyMatrix(matrix) {
        const normalMatrix = gl_matrix_1.mat3.transpose(gl_matrix_1.mat3.create(), gl_matrix_1.mat3.invert(gl_matrix_1.mat3.create(), gl_matrix_1.mat3.fromMat4(gl_matrix_1.mat3.create(), matrix)));
        const p = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.clone(this.normal), gl_matrix_1.vec3.fromValues(this._constant, this._constant, this._constant)), matrix);
        this._normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformMat3(gl_matrix_1.vec3.create(), this._normal, normalMatrix));
        this.constant = -gl_matrix_1.vec3.dot(p, this._normal);
        return this;
    }
    clampPoint(point) {
        const d = -this.distanceToPoint(point);
        return gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this.normal, gl_matrix_1.vec3.fromValues(d, d, d)), point);
    }
    clone() {
        return new Plane(this._normal, this._constant);
    }
    containsPoint(point) {
        return this.distanceToPoint(point) === 0;
    }
    distanceToPoint(point) {
        return gl_matrix_1.vec3.dot(this.normal, point) + this.constant;
    }
    intersect(origin, direction) {
        const denominator = gl_matrix_1.vec3.dot(this.normal, direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(origin) === 0)
                return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(gl_matrix_1.vec3.dot(origin, this.normal) + this.constant) / denominator;
        if (t < 0)
            return null;
        return t; //vec3.add(vec3.create(), vec3.multiply(vec3.create(), direction, vec3.fromValues(t,t,t)), origin);
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        gl_matrix_1.vec3.copy(this.normal, normal);
        this.constant = -gl_matrix_1.vec3.dot(point, this.normal);
        return this;
    }
    reset() {
        this._normal = gl_matrix_1.vec3.fromValues(1, 0, 0);
        this._constant = 0;
    }
}
exports.Plane = Plane;
//# sourceMappingURL=Plane.js.map