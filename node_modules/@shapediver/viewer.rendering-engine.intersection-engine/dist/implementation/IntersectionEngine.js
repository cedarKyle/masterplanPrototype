"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntersectionEngine = void 0;
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
let IntersectionEngine = class IntersectionEngine {
    constructor() {
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
    }
    intersect(ray, filterCriteria = [], intersectionOptions = { opacity: 0, rendererType: viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.STANDARD }, root = this._tree.root, viewerID) {
        let intersections = [];
        const intersectNode = (node) => {
            if (node.visible === false)
                return;
            if (viewerID !== undefined) {
                if (node.excludeViewports.includes(viewerID))
                    return;
                if (node.restrictViewports.length > 0 && !node.restrictViewports.includes(viewerID))
                    return;
            }
            for (let i = 0; i < filterCriteria.length; i++) {
                if (filterCriteria[i](node)) {
                    const intersection = this.intersectNode(node, ray, intersectionOptions);
                    if (intersection) {
                        intersection.forEach(i => i.node = node);
                        intersections = intersections.concat(intersection);
                    }
                    break;
                }
            }
            for (let i = 0; i < node.children.length; i++)
                intersectNode(node.children[i]);
        };
        intersectNode(root);
        intersections.sort((a, b) => a.distance - b.distance);
        return intersections;
    }
    checkIntersection(node, material, ray, pA, pB, pC) {
        let point;
        if (material && material.side === viewer_shared_types_1.MATERIAL_SIDE.BACK) {
            const triangle = new viewer_shared_math_1.Triangle(pC, pB, pA);
            point = triangle.intersect(ray.origin, ray.direction);
        }
        else {
            const triangle = new viewer_shared_math_1.Triangle(pA, pB, pC);
            point = triangle.intersect(ray.origin, ray.direction);
        }
        if (point === null)
            return;
        const distance = gl_matrix_1.vec3.distance(ray.origin, point);
        return {
            distance: distance,
            point: gl_matrix_1.vec3.clone(point),
            node
        };
    }
    checkLineIntersection(node, ray, radius, pA, pB) {
        const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), pB, pA);
        const lineLength = gl_matrix_1.vec3.length(direction);
        const lineRay = {
            origin: pA,
            direction: gl_matrix_1.vec3.divide(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(lineLength, lineLength, lineLength))
        };
        const planeNormal = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, lineRay.direction);
        const Na = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, planeNormal));
        const Nb = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), lineRay.direction, planeNormal));
        const da = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), pA, ray.origin), Nb) / gl_matrix_1.vec3.dot(ray.direction, Nb);
        const db = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), ray.origin, pA), Na) / gl_matrix_1.vec3.dot(lineRay.direction, Na);
        let pointA = gl_matrix_1.vec3.create();
        if (da < 0) {
            gl_matrix_1.vec3.copy(pointA, ray.origin);
        }
        else {
            pointA = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(da, da, da)));
        }
        let pointB = gl_matrix_1.vec3.create();
        if (db < 0) {
            gl_matrix_1.vec3.copy(pointB, pA);
        }
        else if (db < lineLength) {
            pointB = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), pA, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), lineRay.direction, gl_matrix_1.vec3.fromValues(db, db, db)));
        }
        else {
            gl_matrix_1.vec3.copy(pointB, pB);
        }
        const distance = gl_matrix_1.vec3.distance(pointA, pointB);
        if (distance < radius) {
            return {
                distance: distance,
                point: gl_matrix_1.vec3.clone(pointB),
                node
            };
        }
        else {
            return;
        }
    }
    checkPointIntersection(node, ray, radius, p) {
        const closestPoint = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), p, ray.origin);
        const directionDistance = gl_matrix_1.vec3.dot(closestPoint, ray.direction);
        if (directionDistance < 0) {
            gl_matrix_1.vec3.copy(closestPoint, ray.origin);
        }
        else {
            gl_matrix_1.vec3.multiply(closestPoint, gl_matrix_1.vec3.copy(closestPoint, ray.direction), gl_matrix_1.vec3.fromValues(directionDistance, directionDistance, directionDistance));
            gl_matrix_1.vec3.add(closestPoint, closestPoint, ray.origin);
        }
        const distance = gl_matrix_1.vec3.distance(closestPoint, p);
        if (distance < radius) {
            return {
                distance: distance,
                point: gl_matrix_1.vec3.clone(closestPoint),
                node
            };
        }
        else {
            return;
        }
    }
    intersectNode(node, rayIn, intersectionOptions) {
        if (node.visible === false)
            return;
        const inverseMatrix = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), node.worldMatrix);
        const ray = {
            origin: gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), rayIn.origin, inverseMatrix),
            direction: gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(inverseMatrix[0] * rayIn.direction[0] + inverseMatrix[4] * rayIn.direction[1] + inverseMatrix[8] * rayIn.direction[2], inverseMatrix[1] * rayIn.direction[0] + inverseMatrix[5] * rayIn.direction[1] + inverseMatrix[9] * rayIn.direction[2], inverseMatrix[2] * rayIn.direction[0] + inverseMatrix[6] * rayIn.direction[1] + inverseMatrix[10] * rayIn.direction[2]))
        };
        let geometryData;
        for (let i = 0; i < node.data.length; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                geometryData = node.data[i];
                break;
            }
        }
        // quick out if the material does not fit the intersection options
        if (geometryData) {
            let materialData = null;
            if (geometryData.primitive.effectMaterials.length > 0) {
                materialData = geometryData.primitive.effectMaterials[geometryData.primitive.effectMaterials.length - 1].material;
            }
            else if (intersectionOptions.rendererType === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES) {
                materialData = geometryData.primitive.attributeMaterial;
            }
            else {
                materialData = geometryData.primitive.material;
            }
            // if opacity <= intersectionOptions.opacity
            if (materialData && materialData.opacity <= intersectionOptions.opacity)
                return;
        }
        if (!geometryData) {
            let intersections = [];
            for (let i = 0; i < node.children.length; i++) {
                let intersection = this.intersectNode(node.children[i], rayIn, intersectionOptions);
                if (intersection)
                    intersections = intersections.concat(intersection);
            }
            if (intersections.length > 0) {
                intersections.sort((a, b) => a.distance - b.distance);
                return intersections;
            }
            return;
        }
        else if (geometryData.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINES) {
            // if (node.boundingBox.boundingSphere.intersect(ray.origin, ray.direction) === null) return;
            if (node.boundingBox.clone().applyMatrix(node.worldMatrix).intersect(rayIn.origin, rayIn.direction) === null)
                return;
            const index = geometryData.primitive.indices;
            const position = geometryData.primitive.attributes['POSITION'];
            const radius = 0.1;
            let intersections = [];
            if (index !== null) {
                // indexed buffer geometry
                for (let i = 0, il = +index.count; i < il; i += 2) {
                    const a = index.array[(i) * index.itemSize];
                    const b = index.array[(i + 1) * index.itemSize];
                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            else if (position !== undefined) {
                // non-indexed buffer geometry
                for (let i = 0, il = +position.count; i < il; i += 2) {
                    const a = i;
                    const b = i + 1;
                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            intersections.sort((a, b) => a.distance - b.distance);
            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));
            return intersections;
        }
        else if (geometryData.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP || geometryData.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP) {
            // if (node.boundingBox.boundingSphere.intersect(ray.origin, ray.direction) === null) return;
            if (node.boundingBox.clone().applyMatrix(node.worldMatrix).intersect(rayIn.origin, rayIn.direction) === null)
                return;
            const index = geometryData.primitive.indices;
            const position = geometryData.primitive.attributes['POSITION'];
            const radius = 0.1;
            let intersections = [];
            if (index !== null) {
                // indexed buffer geometry
                for (let i = 0, il = +index.count - 1; i < il; i++) {
                    const a = index.array[(i) * index.itemSize];
                    const b = index.array[(i + 1) * index.itemSize];
                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            else if (position !== undefined) {
                // non-indexed buffer geometry
                for (let i = 0, il = +position.count; i < il; i += 2) {
                    const a = i;
                    const b = i + 1;
                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            intersections.sort((a, b) => a.distance - b.distance);
            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));
            return intersections;
        }
        else if (geometryData.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.POINTS) {
            const position = geometryData.primitive.attributes['POSITION'];
            const radius = 0.1;
            let intersections = [];
            if (position !== undefined) {
                // non-indexed buffer geometry
                for (let i = 0, il = +position.count; i < il; i++) {
                    let intersection = this.checkPointIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[i * position.itemSize], position.array[i * position.itemSize + 1], position.array[i * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            intersections.sort((a, b) => a.distance - b.distance);
            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));
            return intersections;
        }
        else {
            // if (node.boundingBox.boundingSphere.intersect(ray.origin, ray.direction) === null) return;
            if (node.boundingBox.clone().applyMatrix(node.worldMatrix).intersect(rayIn.origin, rayIn.direction) === null)
                return;
            const material = geometryData.primitive.material;
            const index = geometryData.primitive.indices;
            const position = geometryData.primitive.attributes['POSITION'];
            let intersections = [];
            if (index !== null) {
                // indexed buffer geometry
                for (let i = 0, il = +index.count; i < il; i += 3) {
                    const a = index.array[(i) * index.itemSize];
                    const b = index.array[(i + 1) * index.itemSize];
                    const c = index.array[(i + 2) * index.itemSize];
                    let intersection = this.checkIntersection(node, material, ray, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            else if (position !== undefined) {
                // non-indexed buffer geometry
                for (let i = 0, il = +position.count; i < il; i += 3) {
                    const a = i;
                    const b = i + 1;
                    const c = i + 2;
                    let intersection = this.checkIntersection(node, material, ray, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));
                    if (intersection)
                        intersections.push(intersection);
                }
            }
            intersections.sort((a, b) => a.distance - b.distance);
            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));
            return intersections;
        }
    }
};
IntersectionEngine = __decorate([
    (0, tsyringe_1.singleton)()
], IntersectionEngine);
exports.IntersectionEngine = IntersectionEngine;
//# sourceMappingURL=IntersectionEngine.js.map