"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraEngine = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const ICameraEngine_1 = require("../interfaces/ICameraEngine");
const AbstractCamera_1 = require("./camera/AbstractCamera");
const PerspectiveCamera_1 = require("./camera/PerspectiveCamera");
const OrthographicCamera_1 = require("./camera/OrthographicCamera");
const IOrthographicCamera_1 = require("../interfaces/camera/IOrthographicCamera");
class CameraEngine {
    // #endregion Properties (10)
    // #region Constructors (1)
    constructor(_renderingEngine, _canvas) {
        this._renderingEngine = _renderingEngine;
        this._canvas = _canvas;
        // #region Properties (10)
        this._cameras = {};
        this._camerasDomEventListenerToken = {};
        this._cameraNode = new viewer_shared_node_tree_1.TreeNode('cameras');
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._settingsEngine = tsyringe_1.container.resolve(viewer_shared_services_1.SettingsEngine);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._camera = null;
        this._settingsApplied = false;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._tree.root.addChild(this._cameraNode);
        this._cameraNode.restrictViewports = [this._renderingEngine.id];
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                const cameras = this.cameras;
                for (let c in cameras)
                    cameras[c].boundingBox = this._boundingBox.clone();
            }
        });
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this.searchForNewCameras();
            }
        });
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get camera() {
        return this._camera;
    }
    get cameras() {
        return this._cameras;
    }
    get update() {
        return this._update;
    }
    set update(value) {
        this._update = value;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (7)
    activateCameraEvents() {
        const cameras = this.cameras;
        for (let c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.activateCameraEvents();
    }
    applySettings(settingsEngine) {
        const cameras = this.cameras;
        for (let c in cameras)
            this.removeCamera(c);
        for (let id in settingsEngine.settings.camera.cameras) {
            const cameraSetting = settingsEngine.settings.camera.cameras[id];
            if (cameraSetting.type === 'perspective') {
                this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, id);
            }
            else {
                const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, id);
                camera.direction = cameraSetting.type;
            }
        }
        if (!this._settingsApplied)
            for (let c in cameras)
                cameras[c].applySettings(settingsEngine);
        const cameraKeys = Object.keys(settingsEngine.settings.camera.cameras);
        if (cameraKeys.length > 0) {
            if (!settingsEngine.settings.camera.cameraId) {
                this.assignCamera(cameraKeys[0]);
            }
            else {
                this.assignCamera(settingsEngine.settings.camera.cameraId);
            }
        }
        else {
            this.createDefaultCameras();
            this.camera.applySettings(settingsEngine);
        }
        this._settingsApplied = true;
        if (this._update)
            this._update();
    }
    assignCamera(id) {
        const camera = this.cameras[id];
        if (!camera)
            return false;
        for (let c in this.cameras)
            this.cameras[c].active = false;
        this._camera = camera;
        this._camera.active = true;
        return true;
    }
    createCamera(type, id) {
        const cameras = this.cameras;
        const cameraId = id || this._uuidGenerator.create();
        if (cameras[cameraId]) {
            const error = new viewer_shared_services_1.ShapeDiverViewerCameraError(`CameraEngine.createCamera: Camera (${type}) with this id (${cameraId}) already exists.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.CAMERA, `CameraEngine.createCamera`, error, false);
        }
        const camera = ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE === type ? new PerspectiveCamera_1.PerspectiveCamera(cameraId) : new OrthographicCamera_1.OrthographicCamera(cameraId);
        camera.assignViewer(this._renderingEngine.id);
        cameras[cameraId] = camera;
        if (this._settingsApplied && this._renderingEngine.settingsEngine) {
            camera.applySettings(this._renderingEngine.settingsEngine);
        }
        else {
            camera.zoomTo(undefined, { duration: 0 });
        }
        this._cameraNode.addData(camera);
        if (this._update)
            this._update();
        return camera;
    }
    createDefaultCameras() {
        const topCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'top');
        topCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP;
        const bottomCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'bottom');
        bottomCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM;
        const leftCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'left');
        leftCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT;
        const rightCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'right');
        rightCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT;
        const frontCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'front');
        frontCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT;
        const backCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'back');
        backCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK;
        const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, 'perspective');
        this.assignCamera(camera.id);
    }
    deactivateCameraEvents() {
        const cameras = this.cameras;
        for (let c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.deactivateCameraEvents();
    }
    removeCamera(id) {
        const cameras = this.cameras;
        const camera = cameras[id];
        if (!camera)
            return false;
        this._renderingEngine.domEventEngine.removeDomEventListener(this._camerasDomEventListenerToken[id]);
        if (this._camera && this._camera.id === id)
            this._camera = null;
        delete cameras[id];
        delete this._camerasDomEventListenerToken[id];
        this._cameraNode.removeData(camera);
        if (this._update)
            this._update();
        return true;
    }
    saveSettings(settingsEngine) {
        settingsEngine.settings.camera.cameraId = this._camera ? this._camera.id : 'perspective';
        settingsEngine.settings.camera.cameras = {};
        for (let c in this.cameras) {
            const camera = this.cameras[c];
            if (camera.type === ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE) {
                const controls = camera.controls;
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.type,
                    fov: camera.fov,
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: { x: controls.cubePositionRestriction.min[0], y: controls.cubePositionRestriction.min[1], z: controls.cubePositionRestriction.min[2] },
                                    max: { x: controls.cubePositionRestriction.max[0], y: controls.cubePositionRestriction.max[1], z: controls.cubePositionRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.spherePositionRestriction.center[0], y: controls.spherePositionRestriction.center[1], z: controls.spherePositionRestriction.center[2] },
                                    radius: controls.spherePositionRestriction.radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: { x: controls.cubeTargetRestriction.min[0], y: controls.cubeTargetRestriction.min[1], z: controls.cubeTargetRestriction.min[2] },
                                    max: { x: controls.cubeTargetRestriction.max[0], y: controls.cubeTargetRestriction.max[1], z: controls.cubeTargetRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.sphereTargetRestriction.center[0], y: controls.sphereTargetRestriction.center[1], z: controls.sphereTargetRestriction.center[2] },
                                    radius: controls.sphereTargetRestriction.radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        }
                    }
                };
            }
            else {
                if (settingsEngine.camera.cameras[camera.id]) {
                    const previousDirection = settingsEngine.camera.cameras[camera.id].type;
                    // if the direction changed, but the default position & target did not, there is an issue
                    if (previousDirection !== camera.type && (settingsEngine.camera.cameras[camera.id].position.x === camera.defaultPosition[0] &&
                        settingsEngine.camera.cameras[camera.id].position.y === camera.defaultPosition[1] &&
                        settingsEngine.camera.cameras[camera.id].position.z === camera.defaultPosition[2] &&
                        settingsEngine.camera.cameras[camera.id].target.x === camera.defaultTarget[0] &&
                        settingsEngine.camera.cameras[camera.id].target.y === camera.defaultTarget[1] &&
                        settingsEngine.camera.cameras[camera.id].target.z === camera.defaultTarget[2])) {
                        camera.defaultPosition = gl_matrix_1.vec3.clone(camera.position);
                        camera.defaultTarget = gl_matrix_1.vec3.clone(camera.target);
                    }
                }
                const controls = camera.controls;
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.direction,
                    controls: {
                        damping: controls.damping,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                    }
                };
            }
        }
    }
    // #endregion Public Methods (7)
    // #region Private Methods (1)
    searchForNewCameras() {
        const getCameraData = (node) => {
            for (let i = 0; i < node.data.length; i++)
                if ((node.data[i] instanceof AbstractCamera_1.AbstractCamera) && !this._cameras[node.data[i].id]) {
                    const camera = node.data[i];
                    if (camera.viewportId === this._renderingEngine.id)
                        this._cameras[camera.id] = camera;
                }
            for (let i = 0; i < node.children.length; i++)
                getCameraData(node.children[i]);
        };
        getCameraData(this._tree.root);
        if (this._update)
            this._update();
    }
}
exports.CameraEngine = CameraEngine;
//# sourceMappingURL=CameraEngine.js.map