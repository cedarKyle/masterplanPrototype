"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _PerspectiveCamera_converter, _PerspectiveCamera_logger, _PerspectiveCamera_tree, _PerspectiveCamera_domEventListenerToken, _PerspectiveCamera_domEventEngine, _PerspectiveCamera_aspect, _PerspectiveCamera_fov, _PerspectiveCamera_threeJsObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerspectiveCamera = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const ICameraEngine_1 = require("../../interfaces/ICameraEngine");
const AbstractCamera_1 = require("./AbstractCamera");
const PerspectiveCameraControls_1 = require("../controls/PerspectiveCameraControls");
class PerspectiveCamera extends AbstractCamera_1.AbstractCamera {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(id) {
        super(id, ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE);
        // #region Properties (3)
        _PerspectiveCamera_converter.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.Converter));
        _PerspectiveCamera_logger.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.Logger));
        _PerspectiveCamera_tree.set(this, tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree));
        _PerspectiveCamera_domEventListenerToken.set(this, void 0);
        _PerspectiveCamera_domEventEngine.set(this, void 0);
        _PerspectiveCamera_aspect.set(this, void 0);
        _PerspectiveCamera_fov.set(this, 60);
        _PerspectiveCamera_threeJsObject.set(this, {});
        this._controls = new PerspectiveCameraControls_1.PerspectiveCameraControls(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get aspect() {
        return __classPrivateFieldGet(this, _PerspectiveCamera_aspect, "f");
    }
    set aspect(value) {
        __classPrivateFieldSet(this, _PerspectiveCamera_aspect, value, "f");
    }
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
    }
    get fov() {
        return __classPrivateFieldGet(this, _PerspectiveCamera_fov, "f");
    }
    set fov(value) {
        __classPrivateFieldSet(this, _PerspectiveCamera_fov, value, "f");
    }
    get threeJsObject() {
        return __classPrivateFieldGet(this, _PerspectiveCamera_threeJsObject, "f");
    }
    // #endregion Public Accessors (4)
    // #region Public Methods (6)
    applySettings(settingsEngine) {
        const cameraSetting = settingsEngine.camera.cameras[this.id];
        if (cameraSetting) {
            this.name = cameraSetting.name;
            this.autoAdjust = cameraSetting.autoAdjust;
            this.cameraMovementDuration = cameraSetting.cameraMovementDuration;
            this.enableCameraControls = cameraSetting.enableCameraControls;
            this.revertAtMouseUp = cameraSetting.revertAtMouseUp;
            this.revertAtMouseUpDuration = cameraSetting.revertAtMouseUpDuration;
            this.zoomExtentsFactor = cameraSetting.zoomExtentsFactor;
            let position = __classPrivateFieldGet(this, _PerspectiveCamera_converter, "f").toVec3(cameraSetting.position);
            let target = __classPrivateFieldGet(this, _PerspectiveCamera_converter, "f").toVec3(cameraSetting.target);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = position;
            this.target = target;
            this.fov = cameraSetting.fov;
        }
        if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2]) {
            if (this._viewportId) {
                this._stateEngine.renderingEngines[this._viewportId].boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.zoomTo(undefined, { duration: 0 });
                    this.defaultPosition = gl_matrix_1.vec3.clone(this._controls.position);
                    this.defaultTarget = gl_matrix_1.vec3.clone(this._controls.target);
                }));
            }
        }
        this._controls.applySettings(settingsEngine);
    }
    assignViewer(viewportId) {
        const renderingEngines = tsyringe_1.container.resolveAll('renderingEngine');
        let renderingEngine = renderingEngines.find(r => r.id === viewportId && r.closed === false);
        if (!renderingEngine) {
            const error = new viewer_shared_services_1.ShapeDiverViewerCameraError(`OrthographicCamera(${this.id}).assignViewer: Viewer with id ${viewportId} not found.`);
            throw __classPrivateFieldGet(this, _PerspectiveCamera_logger, "f").handleError(viewer_shared_services_1.LOGGING_TOPIC.CAMERA, `OrthographicCamera(${this.id}).assignViewer`, error);
        }
        this.assignViewerInternal(viewportId, renderingEngine.canvas);
        this._controls.assignViewer(viewportId, renderingEngine.canvas);
        if (__classPrivateFieldGet(this, _PerspectiveCamera_domEventListenerToken, "f") && __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f"))
            __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f").removeDomEventListener(__classPrivateFieldGet(this, _PerspectiveCamera_domEventListenerToken, "f"));
        __classPrivateFieldSet(this, _PerspectiveCamera_domEventEngine, renderingEngine.domEventEngine, "f");
        __classPrivateFieldSet(this, _PerspectiveCamera_domEventListenerToken, __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f").addDomEventListener(this._controls.cameraControlsEventDistribution), "f");
        this.boundingBox = __classPrivateFieldGet(this, _PerspectiveCamera_tree, "f").root.boundingBox.clone();
        this._stateEngine.renderingEngines[viewportId].boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
            if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2])
                yield this.zoomTo(undefined, { duration: 0 });
        }));
    }
    clone() {
        return new PerspectiveCamera(this.id);
    }
    calculateZoomTo(zoomTarget, startingPosition = this.position, startingTarget = this.target) {
        let box;
        // Part 1 - calculate the bounding box that we should zoom to
        if (!zoomTarget) {
            // complete scene
            box = this._boundingBox.clone();
        }
        else {
            // specified Box
            box = zoomTarget.clone();
        }
        if (box.isEmpty())
            return { position: gl_matrix_1.vec3.create(), target: gl_matrix_1.vec3.create() };
        const samePosition = startingPosition[0] === startingTarget[0] && startingPosition[1] === startingTarget[1] && startingPosition[2] === startingTarget[2];
        let target = gl_matrix_1.vec3.fromValues((box.max[0] + box.min[0]) / 2, (box.max[1] + box.min[1]) / 2, (box.max[2] + box.min[2]) / 2);
        // if the camera position and the target are the same, we set a corner position
        if (startingPosition[0] === startingTarget[0] && startingPosition[1] === startingTarget[1] && startingPosition[2] === startingTarget[2])
            startingPosition = gl_matrix_1.vec3.fromValues(target[0], target[1] - 7.5, target[2] + 5);
        // extend box by the factor
        const boxDir = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), box.max, target);
        gl_matrix_1.vec3.multiply(boxDir, boxDir, samePosition ? gl_matrix_1.vec3.fromValues(2, 2, 2) : gl_matrix_1.vec3.fromValues(this.zoomExtentsFactor, this.zoomExtentsFactor, this.zoomExtentsFactor));
        box = new viewer_shared_math_1.Box(gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), target, boxDir), gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, boxDir));
        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), target, startingPosition));
        let cross = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(0, 0, 1), direction));
        let up = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cross, direction));
        let position = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(-0.00000001, -0.00000001, -0.00000001)));
        let points = [];
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.min[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.min[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.max[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.max[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.min[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.min[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.max[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.max[1], box.max[2]));
        let fovDown = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), cross, (this.fov / 2) * (Math.PI / 180))));
        let fovUp = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), cross, -(this.fov / 2) * (Math.PI / 180))));
        const aspect = samePosition ? 1.5 : this.aspect || 1.5;
        let hFoV = 2 * Math.atan(Math.tan(this.fov * Math.PI / 180 / 2) * aspect);
        let fovRight = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), up, hFoV / 2)));
        let fovLeft = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), up, -hFoV / 2)));
        let planeCross = new viewer_shared_math_1.Plane(gl_matrix_1.vec3.clone(cross), 0);
        planeCross.setFromNormalAndCoplanarPoint(gl_matrix_1.vec3.clone(cross), gl_matrix_1.vec3.clone(target));
        let planeUp = new viewer_shared_math_1.Plane(gl_matrix_1.vec3.fromValues(0, 0, 1), 0);
        planeUp.setFromNormalAndCoplanarPoint(gl_matrix_1.vec3.clone(up), gl_matrix_1.vec3.clone(target));
        let distanceCamera = 0.0;
        for (let i = 0; i < points.length; i++) {
            let projected = planeCross.clampPoint(points[i]);
            let toP = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), projected, position));
            if (gl_matrix_1.vec3.dot(direction, fovDown) > gl_matrix_1.vec3.dot(direction, toP)) {
                const currentDir = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.dot(fovDown, toP) > gl_matrix_1.vec3.dot(fovUp, toP) ? fovDown : fovUp, gl_matrix_1.vec3.fromValues(-1, -1, -1));
                const distance = planeUp.intersect(projected, currentDir);
                if (distance) {
                    const cameraPoint = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), currentDir, gl_matrix_1.vec3.fromValues(distance, distance, distance)), projected);
                    distanceCamera = Math.max(distanceCamera, gl_matrix_1.vec3.distance(target, cameraPoint));
                }
            }
            projected = planeUp.clampPoint(points[i]);
            toP = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), projected, position));
            if (gl_matrix_1.vec3.dot(direction, fovRight) > gl_matrix_1.vec3.dot(direction, toP)) {
                const currentDir = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.dot(fovRight, toP) > gl_matrix_1.vec3.dot(fovLeft, toP) ? fovRight : fovLeft, gl_matrix_1.vec3.fromValues(-1, -1, -1));
                const distance = planeCross.intersect(projected, currentDir);
                if (distance) {
                    const cameraPoint = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), currentDir, gl_matrix_1.vec3.fromValues(distance, distance, distance)), projected);
                    distanceCamera = Math.max(distanceCamera, gl_matrix_1.vec3.distance(target, cameraPoint));
                }
            }
        }
        position = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(-distanceCamera, -distanceCamera, -distanceCamera)));
        return {
            position, target
        };
    }
    project(pos, position = this.position, target = this.target) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), position, target, gl_matrix_1.vec3.fromValues(0, 0, 1));
        const aspect = this.aspect || 1.5;
        const p = gl_matrix_1.mat4.perspective(gl_matrix_1.mat4.create(), this.fov / (180 / Math.PI), aspect, this.near, this.far);
        gl_matrix_1.vec3.transformMat4(pos, pos, gl_matrix_1.mat4.invert(m, m));
        gl_matrix_1.vec3.transformMat4(pos, pos, p);
        return gl_matrix_1.vec2.fromValues(pos[0], pos[1]);
    }
    unproject(pos, position = this.position, target = this.target) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), position, target, gl_matrix_1.vec3.fromValues(0, 0, 1));
        const aspect = this.aspect || 1.5;
        const p = gl_matrix_1.mat4.perspective(gl_matrix_1.mat4.create(), this.fov / (180 / Math.PI), aspect, this.near, this.far);
        gl_matrix_1.vec3.transformMat4(pos, pos, gl_matrix_1.mat4.invert(p, p));
        gl_matrix_1.vec3.transformMat4(pos, pos, m);
        return gl_matrix_1.vec3.clone(pos);
    }
}
exports.PerspectiveCamera = PerspectiveCamera;
_PerspectiveCamera_converter = new WeakMap(), _PerspectiveCamera_logger = new WeakMap(), _PerspectiveCamera_tree = new WeakMap(), _PerspectiveCamera_domEventListenerToken = new WeakMap(), _PerspectiveCamera_domEventEngine = new WeakMap(), _PerspectiveCamera_aspect = new WeakMap(), _PerspectiveCamera_fov = new WeakMap(), _PerspectiveCamera_threeJsObject = new WeakMap();
//# sourceMappingURL=PerspectiveCamera.js.map