"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLTFLoader = exports.GLTF_EXTENSIONS = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const BufferLoader_1 = require("./loaders/BufferLoader");
const BufferViewLoader_1 = require("./loaders/BufferViewLoader");
const AccessorLoader_1 = require("./loaders/AccessorLoader");
const TextureLoader_1 = require("./loaders/TextureLoader");
const MaterialLoader_1 = require("./loaders/MaterialLoader");
const GeometryLoader_1 = require("./loaders/GeometryLoader");
const viewer_shared_node_tree_utils_1 = require("@shapediver/viewer.shared.node-tree-utils");
var GLTF_EXTENSIONS;
(function (GLTF_EXTENSIONS) {
    GLTF_EXTENSIONS["KHR_BINARY_GLTF"] = "KHR_binary_glTF";
    GLTF_EXTENSIONS["KHR_DRACO_MESH_COMPRESSION"] = "KHR_draco_mesh_compression";
    GLTF_EXTENSIONS["KHR_LIGHTS_PUNCTUAL"] = "KHR_lights_punctual";
    GLTF_EXTENSIONS["KHR_MATERIALS_CLEARCOAT"] = "KHR_materials_clearcoat";
    GLTF_EXTENSIONS["KHR_MATERIALS_IOR"] = "KHR_materials_ior";
    GLTF_EXTENSIONS["KHR_MATERIALS_PBRSPECULARGLOSSINESS"] = "KHR_materials_pbrSpecularGlossiness";
    GLTF_EXTENSIONS["KHR_MATERIALS_SHEEN"] = "KHR_materials_sheen";
    GLTF_EXTENSIONS["KHR_MATERIALS_SPECULAR"] = "KHR_materials_specular";
    GLTF_EXTENSIONS["KHR_MATERIALS_TRANSMISSION"] = "KHR_materials_transmission";
    GLTF_EXTENSIONS["KHR_MATERIALS_UNLIT"] = "KHR_materials_unlit";
    GLTF_EXTENSIONS["KHR_MATERIALS_VARIANTS"] = "KHR_materials_variants";
    GLTF_EXTENSIONS["KHR_MATERIALS_VOLUME"] = "KHR_materials_volume";
    GLTF_EXTENSIONS["KHR_MESH_QUANTIZATION"] = "KHR_mesh_quantization";
    GLTF_EXTENSIONS["KHR_TEXTURE_TRANSFORM"] = "KHR_texture_transform";
    GLTF_EXTENSIONS["SHAPEDIVER_MATERIALS_PRESET"] = "SHAPEDIVER_materials_preset";
})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));
const DRACO = require('./draco/draco_decoder.js');
class GLTFLoader {
    constructor() {
        // #region Properties (17)
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._nodes = {};
        // #endregion Private Methods (7)
    }
    // #endregion Properties (17)
    // #region Public Methods (2)
    load(content, gltfBinary, gltfHeader, baseUri) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this._baseUri = baseUri;
            if (gltfBinary && gltfHeader)
                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength + 8, gltfHeader.length);
            this._content = content;
            try {
                this.validateVersionAndExtensions();
                const dracoModule = yield new DRACO();
                this._bufferLoader = new BufferLoader_1.BufferLoader(this._content, this._body, this._baseUri);
                yield this._bufferLoader.load();
                this._bufferViewLoader = new BufferViewLoader_1.BufferViewLoader(this._content, this._bufferLoader);
                this._bufferViewLoader.load();
                this._accessorLoader = new AccessorLoader_1.AccessorLoader(this._content, this._bufferViewLoader);
                this._accessorLoader.load();
                this._textureLoader = new TextureLoader_1.TextureLoader(this._content, this._bufferViewLoader, this._baseUri);
                yield this._textureLoader.load();
                this._materialLoader = new MaterialLoader_1.MaterialLoader(this._content, this._textureLoader);
                yield this._materialLoader.load();
                this._geometryLoader = new GeometryLoader_1.GeometryLoader(this._content, this._accessorLoader, this._bufferViewLoader, this._materialLoader, dracoModule);
                const node = this.loadScene();
                if (this._content.extensions && this._content.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {
                    const variants = this._content.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS].variants;
                    for (let i = 0; i < variants.length; i++)
                        this._geometryLoader.materialVariantsData.variants.push(variants[i].name);
                    this._geometryLoader.materialVariantsData.variantIndex = 0;
                    node.data.push(this._geometryLoader.materialVariantsData);
                }
                if (this._content.skins !== undefined && this._content.nodes !== undefined) {
                    for (let i = 0; i < ((_a = this._content.nodes) === null || _a === void 0 ? void 0 : _a.length); i++) {
                        if (this._content.nodes[i].skin !== undefined) {
                            const skinDef = this.loadSkin(this._content.nodes[i].skin);
                            const skinNode = this._nodes[i];
                            const bones = [];
                            const boneInverses = [];
                            for (let j = 0; j < skinDef.joints.length; j++) {
                                this._nodes[skinDef.joints[j]].data.push(new viewer_shared_types_1.BoneData());
                                bones.push(this._nodes[skinDef.joints[j]]);
                                let mat = gl_matrix_1.mat4.create();
                                if (skinDef.inverseBindMatrices !== undefined) {
                                    const matricesArray = skinDef.inverseBindMatrices.array;
                                    mat = gl_matrix_1.mat4.fromValues(matricesArray[j * 16 + 0], matricesArray[j * 16 + 1], matricesArray[j * 16 + 2], matricesArray[j * 16 + 3], matricesArray[j * 16 + 4], matricesArray[j * 16 + 5], matricesArray[j * 16 + 6], matricesArray[j * 16 + 7], matricesArray[j * 16 + 8], matricesArray[j * 16 + 9], matricesArray[j * 16 + 10], matricesArray[j * 16 + 11], matricesArray[j * 16 + 12], matricesArray[j * 16 + 13], matricesArray[j * 16 + 14], matricesArray[j * 16 + 15]);
                                }
                                boneInverses.push(mat);
                            }
                            skinNode.skinNode = true;
                            skinNode.bones = bones;
                            skinNode.boneInverses = boneInverses;
                            viewer_shared_node_tree_utils_1.NodeTreeUtils.addBones(skinNode, skinNode);
                        }
                    }
                }
                if (this._content.animations)
                    for (let i = 0; i < ((_b = this._content.animations) === null || _b === void 0 ? void 0 : _b.length); i++)
                        node.data.push(this.loadAnimation(i));
                return node;
            }
            catch (e) {
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GLTFLoader.load`, e);
            }
        });
    }
    loadWithUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('gltfProcessing.' + url);
            let axiosResponse;
            try {
                this._performanceEvaluator.startSection('loadGltf.' + url);
                axiosResponse = yield this._httpClient.get(url, {
                    responseType: 'arraybuffer'
                });
                this._performanceEvaluator.endSection('loadGltf.' + url);
            }
            catch (e) {
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GLTFLoader.load`, e);
            }
            let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;
            const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));
            const isBinary = magic === 'glTF' || (axiosResponse.headers['content-type'] &&
                (axiosResponse.headers['content-type'] === 'model/gltf-binary' ||
                    axiosResponse.headers['content-type'] === 'application/octet-stream' ||
                    axiosResponse.headers['content-type'] === 'model/gltf.binary'));
            if (isBinary) {
                gltfBinary = axiosResponse.data;
                // create header data
                const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
                gltfHeader = {
                    magic: magic,
                    version: headerDataView.getUint32(4, true),
                    length: headerDataView.getUint32(8, true),
                    contentLength: headerDataView.getUint32(12, true),
                    contentFormat: headerDataView.getUint32(16, true)
                };
                if (gltfHeader.magic != 'glTF') {
                    const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GLTFLoader.load: Invalid data: sdgTF magic wrong.');
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GLTFLoader.load`, error);
                }
                // create content
                const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);
                const contentDecoded = new TextDecoder().decode(contentDataView);
                gltfContent = JSON.parse(contentDecoded);
                // create body
                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength + 8, gltfHeader.length);
            }
            else {
                gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));
                const removeLastDirectoryPartOf = (the_url) => {
                    const dir_char = the_url.includes("/") ? "/" : "\\";
                    const the_arr = the_url.split(dir_char);
                    the_arr.pop();
                    return the_arr.join(dir_char);
                };
                gltfBaseUrl = removeLastDirectoryPartOf(url);
                if (!gltfBaseUrl && window && window.location && window.location.href)
                    gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);
            }
            return yield this.load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl);
        });
    }
    // #endregion Public Methods (2)
    // #region Private Methods (7)
    /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
         * @param {number} animationIndex
         * @return {Promise<AnimationClip>}
         */
    loadAnimation(animationId) {
        if (!this._content.animations)
            throw new Error('Animations not available.');
        if (!this._content.animations[animationId])
            throw new Error('Animations not available.');
        const animationDef = this._content.animations[animationId];
        const animationTracks = [];
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < animationDef.channels.length; i++) {
            const channel = animationDef.channels[i];
            const sampler = animationDef.samplers[channel.sampler];
            const target = channel.target;
            const path = target.path;
            const node = this._nodes[target.node];
            if (node === undefined)
                throw new Error('Animation node not available.');
            const input = this._accessorLoader.getAccessor(sampler.input);
            min = Math.min(min, input.min[0]);
            max = Math.max(max, input.max[0]);
            const output = this._accessorLoader.getAccessor(sampler.output);
            let interpolation = sampler.interpolation;
            if (interpolation === 'CUBICSPLINE') {
                this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'Animation with CUBICSPLINE interpolation is currently not supported. Assigning linear interpolation instead.');
                interpolation = 'linear';
            }
            animationTracks.push({
                node,
                times: input.array,
                values: output.array,
                path: path,
                interpolation: interpolation === null || interpolation === void 0 ? void 0 : interpolation.toLowerCase()
            });
        }
        return new viewer_shared_types_1.AnimationData(animationDef.name || 'gltf_animation_' + animationId, animationTracks, min, max - min);
    }
    loadCamera(cameraId) {
        if (!this._content.cameras)
            throw new Error('Cameras not available.');
        if (!this._content.cameras[cameraId])
            throw new Error('Cameras not available.');
        const cameraDef = this._content.cameras[cameraId];
        const cameraNode = new viewer_shared_node_tree_1.TreeNode(cameraDef.name || 'camera_' + cameraId);
        let cameraData;
        if (cameraDef.type === 'perspective') {
            const perspectiveCameraDef = cameraDef.perspective;
            cameraData = new viewer_rendering_engine_camera_engine_1.PerspectiveCamera(cameraNode.id);
            cameraNode.data.push(cameraData);
            cameraData.fov = perspectiveCameraDef.yfov * (180 / Math.PI);
            cameraData.aspect = perspectiveCameraDef.aspectRatio || 1;
            cameraData.near = perspectiveCameraDef.znear || 1;
            cameraData.far = perspectiveCameraDef.zfar || 2e6;
        }
        else {
            const orthographicCameraDef = cameraDef.orthographic;
            cameraData = new viewer_rendering_engine_camera_engine_1.OrthographicCamera(cameraNode.id);
            cameraNode.data.push(cameraData);
            cameraData.left = -orthographicCameraDef.xmag;
            cameraData.right = orthographicCameraDef.xmag;
            cameraData.top = -orthographicCameraDef.ymag;
            cameraData.bottom = orthographicCameraDef.ymag;
            cameraData.near = orthographicCameraDef.znear || 1;
            cameraData.far = orthographicCameraDef.zfar || 2e6;
        }
        cameraData.useNodeData = true;
        cameraData.node = cameraNode;
        return cameraNode;
    }
    loadLights(lightId) {
        if (!this._content.extensions || !this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || !this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights)
            throw new Error(`Extension ${GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL} not available.`);
        if (!this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights[lightId])
            throw new Error('Light not available.');
        const lightDef = this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights[lightId];
        const lightNode = new viewer_shared_node_tree_1.TreeNode(lightDef.name || 'light_' + lightId);
        let color = '#ffffffff';
        if (lightDef.color !== undefined)
            color = this._converter.toColor([lightDef.color[0] * 255, lightDef.color[1] * 255, lightDef.color[2] * 255]);
        const range = lightDef.range !== undefined ? lightDef.range : 0;
        let lightData;
        if (lightDef.type === 'directional') {
            lightData = new viewer_rendering_engine_light_engine_1.DirectionalLight({ color });
            lightNode.data.push(lightData);
            const directionalLightData = lightData;
            if (lightDef.intensity !== undefined)
                directionalLightData.intensity = lightDef.intensity;
        }
        else if (lightDef.type === 'point') {
            lightData = new viewer_rendering_engine_light_engine_1.PointLight({ color });
            lightNode.data.push(lightData);
            const pointLightData = lightData;
            pointLightData.distance = range;
            pointLightData.decay = 2;
            if (lightDef.intensity !== undefined)
                lightData.intensity = lightDef.intensity;
            pointLightData.position = [0, 0, 0];
        }
        else if (lightDef.type === 'spot') {
            lightData = new viewer_rendering_engine_light_engine_1.SpotLight({ color });
            lightNode.data.push(lightData);
            lightDef.spot = lightDef.spot || {};
            lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
            lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
            const spotLightData = lightData;
            spotLightData.distance = range;
            spotLightData.angle = lightDef.spot.outerConeAngle;
            spotLightData.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
            spotLightData.decay = 2;
            if (lightDef.intensity !== undefined)
                lightData.intensity = lightDef.intensity;
            spotLightData.position = [0, 0, 0];
            spotLightData.target = [0, 0, -1];
        }
        else {
            throw new Error('Unexpected light type: ' + lightDef.type);
        }
        lightData.useNodeData = true;
        return lightNode;
    }
    loadNode(nodeId) {
        if (!this._content.nodes)
            throw new Error('Nodes not available.');
        if (!this._content.nodes[nodeId])
            throw new Error('Node not available.');
        const node = this._content.nodes[nodeId];
        const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);
        this._nodes[nodeId] = nodeDef;
        if (node.matrix) {
            nodeDef.addTransformation({
                id: 'gltf_matrix',
                matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])
            });
            nodeDef.addTransformation({
                id: 'gltf_matrix_translation',
                matrix: gl_matrix_1.mat4.create()
            });
            nodeDef.addTransformation({
                id: 'gltf_matrix_rotation',
                matrix: gl_matrix_1.mat4.create()
            });
            nodeDef.addTransformation({
                id: 'gltf_matrix_scale',
                matrix: gl_matrix_1.mat4.create()
            });
        }
        else if (node.translation || node.scale || node.rotation) {
            const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();
            const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();
            const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();
            nodeDef.addTransformation({
                id: 'gltf_matrix_translation',
                matrix: matT
            });
            nodeDef.addTransformation({
                id: 'gltf_matrix_rotation',
                matrix: matR
            });
            nodeDef.addTransformation({
                id: 'gltf_matrix_scale',
                matrix: matS
            });
        }
        if (node.mesh !== undefined)
            nodeDef.addChild(this._geometryLoader.loadMesh(node.mesh, node.weights));
        if (node.camera !== undefined)
            nodeDef.addChild(this.loadCamera(node.camera));
        if (node.extensions && node.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL])
            nodeDef.addChild(this.loadLights(node.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
        if (node.children) {
            for (let i = 0, len = node.children.length; i < len; i++) {
                // got through all children
                nodeDef.addChild(this.loadNode(node.children[i]));
            }
        }
        return nodeDef;
    }
    loadScene() {
        if (!this._content.scenes)
            throw new Error('Scenes not available.');
        const sceneId = this._content.scene || 0;
        if (!this._content.scenes[sceneId])
            throw new Error('Scene not available.');
        const scene = this._content.scenes[sceneId];
        const sceneDef = new viewer_shared_node_tree_1.TreeNode(scene.name || 'scene_' + sceneId + '');
        sceneDef.addTransformation({
            id: this._uuidGenerator.create(),
            matrix: this._globalTransformation
        });
        if (scene.nodes)
            for (let i = 0, len = scene.nodes.length; i < len; i++)
                sceneDef.addChild(this.loadNode(scene.nodes[i]));
        return sceneDef;
    }
    loadSkin(skinId) {
        if (!this._content.skins)
            throw new Error('Skins not available.');
        if (!this._content.skins[skinId])
            throw new Error('Skin not available.');
        const skinDef = this._content.skins[skinId];
        const skinEntry = {
            joints: skinDef.joints,
            inverseBindMatrices: null
        };
        if (skinDef.inverseBindMatrices === undefined) {
            return skinEntry;
        }
        skinEntry.inverseBindMatrices = this._accessorLoader.getAccessor(skinDef.inverseBindMatrices);
        return skinEntry;
    }
    validateVersionAndExtensions() {
        if (!this._content.asset)
            throw new Error('Asset not available.');
        const asset = this._content.asset;
        if (!asset.version)
            throw new Error('Asset does not have a version.');
        const version = asset.minVersion ? asset.minVersion : asset.version;
        if (!version.startsWith('2'))
            throw new Error('Version of the glTF not supported.');
        if (this._content.extensionsUsed) {
            const notSupported = [];
            for (let i = 0; i < this._content.extensionsUsed.length; i++) {
                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsUsed[i]))
                    notSupported.push(this._content.extensionsUsed[i]);
            }
            if (notSupported.length > 0) {
                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');
                notSupported.forEach((element, index) => {
                    message += '"' + element + '"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');
                });
                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';
                this._logger.info(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'GLTFLoader.validateVersionAndExtensions: ' + message);
            }
        }
        if (this._content.extensionsRequired) {
            const notSupported = [];
            for (let i = 0; i < this._content.extensionsRequired.length; i++) {
                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsRequired[i]))
                    notSupported.push(this._content.extensionsRequired[i]);
            }
            if (notSupported.length > 0) {
                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');
                notSupported.forEach((element, index) => {
                    message += '"' + element + '"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');
                });
                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but required. Aborting glTF loading.';
                throw new Error(message);
            }
        }
    }
}
exports.GLTFLoader = GLTFLoader;
//# sourceMappingURL=GLTFLoader.js.map