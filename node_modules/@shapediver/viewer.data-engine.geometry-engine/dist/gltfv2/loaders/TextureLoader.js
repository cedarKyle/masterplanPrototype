"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureLoader = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
class TextureLoader {
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(_content, _bufferViewLoader, _baseUri) {
        this._content = _content;
        this._bufferViewLoader = _bufferViewLoader;
        this._baseUri = _baseUri;
        // #region Properties (4)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._loaded = {};
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    getTexture(textureId) {
        if (!this._content.textures)
            throw new Error('TextureLoader.getTexture: Textures not available.');
        if (!this._content.textures[textureId])
            throw new Error('TextureLoader.getTexture: Texture not available.');
        if (!this._loaded[textureId])
            throw new Error('TextureLoader.getTexture: Texture not loaded.');
        return this._loaded[textureId];
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.textures)
                return;
            let promises = [];
            for (let i = 0; i < this._content.textures.length; i++) {
                const textureId = i;
                const texture = this._content.textures[textureId];
                if (!this._content.images)
                    throw new Error('TextureLoader.load: Images not available.');
                const image = this._content.images[texture.source];
                const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;
                const HTTPS_URI_REGEX = /^https:\/\//;
                if (image.bufferView !== undefined) {
                    const bufferView = this._bufferViewLoader.getBufferView(image.bufferView);
                    const dataView = new DataView(bufferView);
                    const array = [];
                    for (let i = 0; i < dataView.byteLength; i += 1)
                        array[i] = dataView.getUint8(i);
                    const blob = new Blob([new Uint8Array(array)], { type: image.mimeType });
                    const dataUri = window.URL.createObjectURL(blob);
                    promises.push(new Promise(resolve => {
                        this._httpClient.loadTexture(dataUri)
                            .then(response => {
                            this._converter.responseToImage(response).then(img => {
                                this._loaded[textureId] = img;
                                resolve();
                            });
                        });
                    }));
                }
                else {
                    const url = DATA_URI_REGEX.test(image.uri) || HTTPS_URI_REGEX.test(image.uri) ? image.uri : `${this._baseUri}/${image.uri}`;
                    promises.push(new Promise(resolve => {
                        this._httpClient.loadTexture(url)
                            .then(response => {
                            this._converter.responseToImage(response).then(img => {
                                this._loaded[textureId] = img;
                                resolve();
                            });
                        });
                    }));
                }
            }
            yield Promise.all(promises);
        });
    }
}
exports.TextureLoader = TextureLoader;
//# sourceMappingURL=TextureLoader.js.map