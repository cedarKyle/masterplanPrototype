"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryEngine = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const GLTFLoader_1 = require("./gltfv1/GLTFLoader");
const GLTFLoader_2 = require("./gltfv2/GLTFLoader");
let GeometryEngine = class GeometryEngine {
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor() {
        // #region Properties (4)
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    /**
     * Load the geometry content into a scene graph node.
     *
     * @param content the geometry content
     * @returns the scene graph node
     */
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!content || (content && !content.href)) {
                const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine cannot load content.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GeometryEngine.loadContent`, error);
            }
            const url = content.href;
            let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;
            let version = '2.0';
            if (content.format === 'glb' || content.format === 'gltf') {
                this._performanceEvaluator.startSection('gltfProcessing.' + url);
                let axiosResponse;
                try {
                    this._performanceEvaluator.startSection('loadGltf.' + url);
                    axiosResponse = yield this._httpClient.get(url, {
                        responseType: 'arraybuffer'
                    });
                    this._performanceEvaluator.endSection('loadGltf.' + url);
                }
                catch (e) {
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GeometryEngine.loadContent`, e);
                }
                const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));
                const isBinary = magic === 'glTF';
                if (isBinary) {
                    gltfBinary = axiosResponse.data;
                    // create header data
                    const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
                    gltfHeader = {
                        magic: magic,
                        version: headerDataView.getUint32(4, true),
                        length: headerDataView.getUint32(8, true),
                        contentLength: headerDataView.getUint32(12, true),
                        contentFormat: headerDataView.getUint32(16, true)
                    };
                    if (gltfHeader.magic != 'glTF') {
                        const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('Invalid data: glTF magic wrong.');
                        throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GeometryEngine.loadContent`, error);
                    }
                    // create content
                    const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);
                    const contentDecoded = new TextDecoder().decode(contentDataView);
                    gltfContent = JSON.parse(contentDecoded);
                    if (gltfContent && gltfContent.asset && gltfContent.asset.version) {
                        const assetVersion = (gltfContent.asset.version + '').endsWith('.0') ? gltfContent.asset.version : gltfContent.asset.version + '.0';
                        if (gltfHeader.version + '.0' === assetVersion) {
                            version = gltfHeader.version + '.0';
                        }
                        else {
                            const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: glTF header version (' + gltfHeader.version + ') is not the same as asset version (' + assetVersion + ').');
                            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GeometryEngine.loadContent`, error);
                        }
                    }
                    else {
                        version = gltfHeader.version + '.0';
                    }
                }
                else {
                    gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));
                    if (gltfContent && gltfContent.asset && gltfContent.asset.version) {
                        if (gltfContent.asset.version !== '2.0') {
                            const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: Only gltf v2 is supported in a non-binary format.');
                            throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `GeometryEngine.loadContent`, error);
                        }
                    }
                    else {
                        this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'GeometryEngine.loadContent: No version specified in asset, trying to load as v2.');
                        version = '2.0';
                    }
                    const removeLastDirectoryPartOf = (the_url) => {
                        const dir_char = the_url.includes("/") ? "/" : "\\";
                        const the_arr = the_url.split(dir_char);
                        the_arr.pop();
                        return the_arr.join(dir_char);
                    };
                    gltfBaseUrl = removeLastDirectoryPartOf(url);
                    if (!gltfBaseUrl && window && window.location && window.location.href)
                        gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);
                }
            }
            let node;
            if (version === '1.0') {
                node = yield new GLTFLoader_1.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl);
            }
            else {
                node = yield new GLTFLoader_2.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl);
            }
            this._performanceEvaluator.endSection('gltfProcessing.' + url);
            return node;
        });
    }
};
GeometryEngine = __decorate([
    (0, tsyringe_1.singleton)(),
    __metadata("design:paramtypes", [])
], GeometryEngine);
exports.GeometryEngine = GeometryEngine;
//# sourceMappingURL=GeometryEngine.js.map