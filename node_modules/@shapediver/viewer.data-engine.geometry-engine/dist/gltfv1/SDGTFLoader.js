"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDGTFLoader = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_data_engine_shared_types_1 = require("@shapediver/viewer.data-engine.shared-types");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
class SDGTFLoader {
    constructor() {
        // #region Properties (5)
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        // #endregion Private Methods (6)
    }
    // #endregion Properties (5)
    // #region Public Methods (1)
    load(binaryGeometry, gltfLength) {
        return __awaiter(this, void 0, void 0, function* () {
            if (gltfLength < binaryGeometry.byteLength) {
                const headerDataView = new DataView(binaryGeometry, gltfLength, this.BINARY_EXTENSION_HEADER_LENGTH + 1);
                const header = {
                    magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)) + String.fromCharCode(headerDataView.getUint8(4)),
                    version: headerDataView.getUint32(5, true),
                    length: headerDataView.getUint32(9, true),
                    contentLength: headerDataView.getUint32(13, true),
                    contentFormat: headerDataView.getUint32(17, true)
                };
                if (header.magic != 'sdgTF') {
                    const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDGTFLoader.load: Invalid data: sdgTF magic wrong.');
                    throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `SDGTFLoader.load`, error);
                }
                // create content
                const contentDataView = new DataView(binaryGeometry, gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1, header.contentLength);
                const contentDecoded = new TextDecoder().decode(contentDataView);
                this._content = JSON.parse(contentDecoded);
                this._body = binaryGeometry.slice(gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1 + header.contentLength, gltfLength + header.length);
            }
            else {
                return new viewer_shared_node_tree_1.TreeNode();
            }
            try {
                return yield this.loadScene();
            }
            catch (e) {
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `SDGTFLoader.load`, e);
            }
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (6)
    convertToIndicesArray(indices) {
        const max = Math.max(0, ...indices);
        if (max < (1 << 8) - 1) {
            return new Uint8Array(indices);
        }
        else if (max < (1 << 16) - 1) {
            return new Uint16Array(indices);
        }
        else {
            return new Uint32Array(indices);
        }
    }
    loadAccessor(accessorName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.accessors[accessorName])
                throw new Error('Accessor not available.');
            const accessor = this._content.accessors[accessorName];
            const bufferView = this._body;
            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];
            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];
            const elementBytes = ArrayType.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessor.byteOffset || 0;
            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView, byteOffset, itemSize * accessor.count), itemSize, itemBytes, byteOffset, elementBytes, false, accessor.count);
        });
    }
    loadArcs() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.arcs)
                throw new Error('Arcs not available.');
            const arc = this._content.arcs;
            const arcNode = new viewer_shared_node_tree_1.TreeNode('arcs');
            const data = yield this.loadAccessor(arc.attributes['ARCS']);
            // data with an absolute classic array of Vec12s ...
            // like you usually have it in any good program
            // not 4 Vec3s, no, that would be to logic, but a Vec12 instead
            const count = data.array.length / data.itemSize;
            for (let i = 0; i < count; ++i) {
                const singleArcNode = new viewer_shared_node_tree_1.TreeNode('arc_' + i);
                const index = i * 12;
                const arcCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);
                const arcXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);
                const arcYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);
                const arcRadius = data.array[index + 9];
                const arcMinAngle = data.array[index + 10];
                const arcMaxAngle = data.array[index + 11];
                const arcZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), arcXAxis, arcYAxis);
                if (arcRadius <= 0) {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'SDGTFLoader.loadArcs: Arc radius is <= 0.');
                    continue;
                }
                const points = [];
                const getPointOnArc = (t) => {
                    const twoPi = Math.PI * 2;
                    let deltaAngle = arcMaxAngle - arcMinAngle;
                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                    // ensures that deltaAngle is 0 .. 2 PI
                    while (deltaAngle < 0)
                        deltaAngle += twoPi;
                    while (deltaAngle > twoPi)
                        deltaAngle -= twoPi;
                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;
                    const angle = arcMinAngle + t * deltaAngle;
                    let x = arcRadius * Math.cos(angle);
                    let y = arcRadius * Math.sin(angle);
                    points.push(x, y, 0);
                };
                const numberOfPoints = Math.max(3, Math.round(50 * ((arcMaxAngle - arcMinAngle) / 2 * Math.PI)));
                for (let d = 0; d <= numberOfPoints; d++)
                    getPointOnArc(d / numberOfPoints);
                const array = new Float32Array(points);
                const attributes = {};
                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);
                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP, null));
                singleArcNode.data.push(geometry);
                singleArcNode.addTransformation({
                    id: 'arc_' + i + '_translation',
                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(arcCenter[0], arcCenter[1], arcCenter[2]))
                });
                const arcRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(arcXAxis[0], arcYAxis[0], arcZAxis[0], 0, arcXAxis[1], arcYAxis[1], arcZAxis[1], 0, arcXAxis[2], arcYAxis[2], arcZAxis[2], 0, 0, 0, 0, 1));
                singleArcNode.addTransformation({
                    id: 'arc_' + i + '_rotation',
                    matrix: arcRotationMatrix
                });
                arcNode.addChild(singleArcNode);
            }
            return arcNode;
        });
    }
    loadBeziercurve(beziercurveName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.beziercurves[beziercurveName])
                throw new Error('Beziercurve not available.');
            const beziercurve = this._content.beziercurves[beziercurveName];
            const beziercurveNode = new viewer_shared_node_tree_1.TreeNode(beziercurveName);
            const controlPointsData = yield this.loadAccessor(beziercurve.attributes['CONTROLPOINTS']); // vec3
            const controlPoints = [];
            for (let i = 0; i < controlPointsData.array.length; i += 3)
                controlPoints.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[i], controlPointsData.array[i + 1], controlPointsData.array[i + 2], 1));
            const knotsData = yield this.loadAccessor(beziercurve.attributes['KNOTS']); // scalar
            const knots = [knotsData.array[0]];
            for (let i = 0; i < knotsData.array.length; i++)
                knots.push(knotsData.array[i]);
            knots.push(knotsData.array[knotsData.array.length - 1]);
            const degree = beziercurve.degree;
            const findSpan = (u) => {
                const n = knots.length - degree - 1;
                if (u >= knots[n])
                    return n - 1;
                if (u <= knots[degree])
                    return degree;
                let low = degree;
                let high = n;
                let mid = Math.floor((low + high) / 2);
                while (u < knots[mid] || u >= knots[mid + 1]) {
                    if (u < knots[mid]) {
                        high = mid;
                    }
                    else {
                        low = mid;
                    }
                    mid = Math.floor((low + high) / 2);
                }
                return mid;
            };
            const calcBasisFunctions = (span, u) => {
                const N = [];
                const left = [];
                const right = [];
                N[0] = 1.0;
                for (let j = 1; j <= degree; ++j) {
                    left[j] = u - knots[span + 1 - j];
                    right[j] = knots[span + j] - u;
                    let saved = 0.0;
                    for (let r = 0; r < j; ++r) {
                        const rv = right[r + 1];
                        const lv = left[j - r];
                        const temp = N[r] / (rv + lv);
                        N[r] = saved + rv * temp;
                        saved = lv * temp;
                    }
                    N[j] = saved;
                }
                return N;
            };
            const calcBSplinePoint = (u) => {
                const span = findSpan(u);
                const N = calcBasisFunctions(span, u);
                const C = gl_matrix_1.vec4.create();
                for (let j = 0; j <= degree; ++j) {
                    const point = controlPoints[span - degree + j];
                    const Nj = N[j];
                    const wNj = point[3] * Nj;
                    gl_matrix_1.vec4.add(C, C, gl_matrix_1.vec4.fromValues(point[0] * wNj, point[1] * wNj, point[2] * wNj, point[3] * Nj));
                }
                return C;
            };
            const points = [];
            const getPointOnBezierCurve = (t) => {
                const u = knots[0] + t * (knots[knots.length - 1] - knots[0]); // linear mapping t->u
                // following results in (wx, wy, wz, w) homogeneous point
                let hpoint = calcBSplinePoint(u);
                if (hpoint[3] !== 1.0) {
                    // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
                    hpoint = gl_matrix_1.vec4.divide(gl_matrix_1.vec4.create(), hpoint, gl_matrix_1.vec4.fromValues(hpoint[3], hpoint[3], hpoint[3], hpoint[3]));
                }
                points.push(hpoint[0], hpoint[1], hpoint[2]);
            };
            // Number of points calculation
            // We go through the control points, measure the distance
            let distance = 0;
            for (let i = 1; i < controlPoints.length; i++)
                distance += gl_matrix_1.vec3.distance(gl_matrix_1.vec3.fromValues(controlPoints[i - 1][0], controlPoints[i - 1][1], controlPoints[i - 1][2]), gl_matrix_1.vec3.fromValues(controlPoints[i][0], controlPoints[i][1], controlPoints[i][2]));
            const numberOfPoints = Math.min(100, Math.max(25, Math.floor(distance / 0.1)));
            for (let d = 0; d <= numberOfPoints; d++)
                getPointOnBezierCurve(d / numberOfPoints);
            const array = new Float32Array(points);
            const attributes = {};
            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);
            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP, null));
            beziercurveNode.data.push(geometry);
            return beziercurveNode;
        });
    }
    loadCircles() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.circles)
                throw new Error('Circles not available.');
            const circle = this._content.circles;
            const circleNode = new viewer_shared_node_tree_1.TreeNode('circles');
            const data = yield this.loadAccessor(circle.attributes['CIRCLES']);
            const count = data.array.length / data.itemSize;
            for (let i = 0; i < count; i++) {
                const singleCircleNode = new viewer_shared_node_tree_1.TreeNode('circle_' + i);
                const index = i * 10;
                const circleCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);
                const circleXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);
                const circleYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);
                const circleRadius = data.array[index + 9];
                const circleZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), circleXAxis, circleYAxis);
                if (circleRadius <= 0) {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'SDGTFLoader.loadCircles: Circle radius is <= 0.');
                    continue;
                }
                const points = [];
                const getPointOnArc = (t) => {
                    const twoPi = Math.PI * 2;
                    let deltaAngle = 2.0 * Math.PI - 0;
                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                    // ensures that deltaAngle is 0 .. 2 PI
                    while (deltaAngle < 0)
                        deltaAngle += twoPi;
                    while (deltaAngle > twoPi)
                        deltaAngle -= twoPi;
                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;
                    const angle = 0 + t * deltaAngle;
                    let x = circleRadius * Math.cos(angle);
                    let y = circleRadius * Math.sin(angle);
                    points.push(x, y, 0);
                };
                const numberOfPoints = 50;
                for (let d = 0; d <= numberOfPoints; d++)
                    getPointOnArc(d / numberOfPoints);
                const array = new Float32Array(points);
                const attributes = {};
                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);
                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP, null));
                singleCircleNode.data.push(geometry);
                singleCircleNode.addTransformation({
                    id: 'circle_' + i + '_translation',
                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(circleCenter[0], circleCenter[1], circleCenter[2]))
                });
                const circleRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(circleXAxis[0], circleYAxis[0], circleZAxis[0], 0, circleXAxis[1], circleYAxis[1], circleZAxis[1], 0, circleXAxis[2], circleYAxis[2], circleZAxis[2], 0, 0, 0, 0, 1));
                singleCircleNode.addTransformation({
                    id: 'circle_' + i + '_rotation',
                    matrix: circleRotationMatrix
                });
                circleNode.addChild(singleCircleNode);
            }
            return circleNode;
        });
    }
    loadCylinders() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.cylinders)
                throw new Error('Cylinders not available.');
            const cylinder = this._content.cylinders;
            const cylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinders');
            const data = yield this.loadAccessor(cylinder.attributes['CYLINDERS']);
            const count = data.array.length / data.itemSize;
            for (let i = 0; i < count; i++) {
                const singleCylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinder_' + i);
                const index = i * 7;
                const cylinderTop = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);
                const cylinderBottom = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);
                const cylinderRadius = data.array[index + 6];
                const cylinderAxis = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), cylinderTop, cylinderBottom);
                const dotX = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0)));
                const dotY = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0)));
                let cylinderXAxis;
                if (dotX < dotY) {
                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0));
                }
                else {
                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0));
                }
                const cylinderYAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, cylinderXAxis);
                gl_matrix_1.vec3.normalize(cylinderAxis, cylinderAxis);
                gl_matrix_1.vec3.normalize(cylinderXAxis, cylinderXAxis);
                gl_matrix_1.vec3.normalize(cylinderYAxis, cylinderYAxis);
                if (cylinderRadius <= 0) {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'SDGTFLoader.loadCylinders: Cylinder radius is <= 0.');
                    continue;
                }
                const indices = [];
                const vertices = [];
                const normals = [];
                const uvs = [];
                const height = gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom);
                const halfHeight = height / 2;
                const thetaStart = 0, thetaLength = Math.PI * 2;
                let indexCounter = 0;
                const indexArray = [];
                const heightSegments = 1, radialSegments = 50;
                const normal = gl_matrix_1.vec3.create();
                const vertex = gl_matrix_1.vec3.create();
                let groupCount = 0;
                // this will be used to calculate the normal
                const slope = 0;
                // generate vertices, normals and uvs
                for (let y = 0; y <= heightSegments; y++) {
                    const indexRow = [];
                    const v = y / heightSegments;
                    // calculate the radius of the current row
                    const radius = cylinderRadius;
                    for (let x = 0; x <= radialSegments; x++) {
                        const u = x / radialSegments;
                        const theta = u * thetaLength + thetaStart;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        // vertex
                        vertex[0] = radius * sinTheta;
                        vertex[1] = -v * height + halfHeight;
                        vertex[2] = radius * cosTheta;
                        vertices.push(vertex[0], vertex[1], vertex[2]);
                        // normal
                        gl_matrix_1.vec3.normalize(normal, gl_matrix_1.vec3.fromValues(sinTheta, slope, cosTheta));
                        normals.push(normal[0], normal[1], normal[2]);
                        // uv
                        uvs.push(u, 1 - v);
                        // save index of vertex in respective row
                        indexRow.push(indexCounter++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (let x = 0; x < radialSegments; x++) {
                    for (let y = 0; y < heightSegments; y++) {
                        // we use the index array to access the correct indices
                        const a = indexArray[y][x];
                        const b = indexArray[y + 1][x];
                        const c = indexArray[y + 1][x + 1];
                        const d = indexArray[y][x + 1];
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                const attributes = {};
                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);
                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);
                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);
                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)));
                singleCylinderNode.data.push(geometry);
                singleCylinderNode.addTransformation({
                    id: 'cylinder_' + i + '_translation',
                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), cylinderBottom)
                });
                const cylinderRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(cylinderXAxis[0], cylinderYAxis[0], cylinderAxis[0], 0, cylinderXAxis[1], cylinderYAxis[1], cylinderAxis[1], 0, cylinderXAxis[2], cylinderYAxis[2], cylinderAxis[2], 0, 0, 0, 0, 1));
                singleCylinderNode.addTransformation({
                    id: 'cylinder_' + i + '_rotation',
                    matrix: cylinderRotationMatrix
                });
                singleCylinderNode.addTransformation({
                    id: 'cylinder_' + i + '_rotation2',
                    matrix: gl_matrix_1.mat4.rotateX(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), 0.5 * Math.PI)
                });
                singleCylinderNode.addTransformation({
                    id: 'cylinder_' + i + '_translation2',
                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(0, 0, 0.5 * gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom)))
                });
                cylinderNode.addChild(singleCylinderNode);
            }
            return cylinderNode;
        });
    }
    loadSpheres() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.spheres)
                throw new Error('Spheres not available.');
            const sphere = this._content.spheres;
            const sphereNode = new viewer_shared_node_tree_1.TreeNode('spheres');
            const data = yield this.loadAccessor(sphere.attributes['SPHERES']);
            const count = data.array.length / data.itemSize;
            for (let i = 0; i < count; i++) {
                const singleSphereNode = new viewer_shared_node_tree_1.TreeNode('sphere_' + i);
                const index = i * 4;
                const sphereTranslation = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);
                const sphereRadius = data.array[index + 3];
                if (sphereRadius <= 0) {
                    this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'SDGTFLoader.loadSpheres: Sphere radius is <= 0.');
                    continue;
                }
                const indices = [];
                const vertices = [];
                const normals = [];
                const uvs = [];
                const grid = [];
                // for some reason, this doesn't work with values > 15
                // let's not look into it, it's legacy stuff
                const heightSegments = 15, widthSegments = 15;
                const phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI;
                const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
                let indexCounter = 0;
                // generate vertices, normals and uvs
                for (let iy = 0; iy <= heightSegments; iy++) {
                    const verticesRow = [];
                    const v = iy / heightSegments;
                    // special case for the poles
                    let uOffset = 0;
                    if (iy == 0 && thetaStart == 0) {
                        uOffset = 0.5 / widthSegments;
                    }
                    else if (iy == heightSegments && thetaEnd == Math.PI) {
                        uOffset = -0.5 / widthSegments;
                    }
                    for (let ix = 0; ix <= widthSegments; ix++) {
                        const u = ix / widthSegments;
                        // vertex
                        const vertex = gl_matrix_1.vec3.fromValues(-sphereRadius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), sphereRadius * Math.cos(thetaStart + v * thetaLength), sphereRadius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength));
                        vertices.push(vertex[0], vertex[1], vertex[2]);
                        // normal
                        const normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), vertex);
                        normals.push(normal[0], normal[1], normal[2]);
                        // uv
                        uvs.push(u + uOffset, 1 - v);
                        verticesRow.push(indexCounter++);
                    }
                    grid.push(verticesRow);
                }
                // indices
                for (let iy = 0; iy < heightSegments; iy++) {
                    for (let ix = 0; ix < widthSegments; ix++) {
                        const a = grid[iy][ix + 1];
                        const b = grid[iy][ix];
                        const c = grid[iy + 1][ix];
                        const d = grid[iy + 1][ix + 1];
                        if (iy !== 0 || thetaStart > 0)
                            indices.push(a, b, d);
                        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                            indices.push(b, c, d);
                    }
                }
                const attributes = {};
                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);
                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);
                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);
                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)));
                singleSphereNode.data.push(geometry);
                singleSphereNode.addTransformation({
                    id: 'sphere_' + i + '_translation',
                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), sphereTranslation)
                });
                sphereNode.addChild(singleSphereNode);
            }
            return sphereNode;
        });
    }
    loadPoint(pointName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.points[pointName])
                throw new Error('Point not available.');
            const point = this._content.points[pointName];
            const pointNode = new viewer_shared_node_tree_1.TreeNode(pointName);
            const attributes = {};
            const data = yield this.loadAccessor(point.attributes['POINTS']);
            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);
            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.POINTS, null));
            pointNode.data.push(geometry);
            return pointNode;
        });
    }
    loadPolyline(polylineName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.polylines[polylineName])
                throw new Error('Polyline not available.');
            const polyLine = this._content.polylines[polylineName];
            const polyLineNode = new viewer_shared_node_tree_1.TreeNode(polylineName);
            const attributes = {};
            const data = yield this.loadAccessor(polyLine.attributes['VERTICES']);
            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);
            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP, null));
            polyLineNode.data.push(geometry);
            return polyLineNode;
        });
    }
    loadSurfacepatch(surfacepatchName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.surfacepatches[surfacepatchName])
                throw new Error('Surfacepatch not available.');
            const surfacepatch = this._content.surfacepatches[surfacepatchName];
            const surfacepatchNode = new viewer_shared_node_tree_1.TreeNode(surfacepatchName);
            const controlPointCountU = surfacepatch.controlPointCountU;
            const controlPointCountV = surfacepatch.controlPointCountV;
            const controlPointsData = yield this.loadAccessor(surfacepatch.attributes['CONTROLPOINTS']); // vec3
            const controlPoints = [];
            let pointCount = 0;
            for (let u = 0; u < controlPointCountU; u++) {
                let innerArray = [];
                for (let v = 0; v < controlPointCountV; v++) {
                    innerArray.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[pointCount * 3], controlPointsData.array[pointCount * 3 + 1], controlPointsData.array[pointCount * 3 + 2], 1));
                    pointCount++;
                }
                controlPoints.push(innerArray);
            }
            const knotsUData = yield this.loadAccessor(surfacepatch.attributes['KNOTSU']); // scalar
            const knotsU = [knotsUData.array[0]];
            for (let i = 0; i < knotsUData.array.length; i++)
                knotsU.push(knotsUData.array[i]);
            knotsU.push(knotsUData.array[knotsUData.array.length - 1]);
            const knotsVData = yield this.loadAccessor(surfacepatch.attributes['KNOTSV']); // scalar
            const knotsV = [knotsVData.array[0]];
            for (let i = 0; i < knotsVData.array.length; i++)
                knotsV.push(knotsVData.array[i]);
            knotsV.push(knotsVData.array[knotsVData.array.length - 1]);
            const degreeU = surfacepatch.degreeU;
            const degreeV = surfacepatch.degreeV;
            const findSpan = (knots, degree, u) => {
                const n = knots.length - degree - 1;
                if (u >= knots[n])
                    return n - 1;
                if (u <= knots[degree])
                    return degree;
                let low = degree;
                let high = n;
                let mid = Math.floor((low + high) / 2);
                while (u < knots[mid] || u >= knots[mid + 1]) {
                    if (u < knots[mid]) {
                        high = mid;
                    }
                    else {
                        low = mid;
                    }
                    mid = Math.floor((low + high) / 2);
                }
                return mid;
            };
            const calcBasisFunctions = (knots, degree, span, u) => {
                const N = [];
                const left = [];
                const right = [];
                N[0] = 1.0;
                for (let j = 1; j <= degree; ++j) {
                    left[j] = u - knots[span + 1 - j];
                    right[j] = knots[span + j] - u;
                    let saved = 0.0;
                    for (let r = 0; r < j; ++r) {
                        const rv = right[r + 1];
                        const lv = left[j - r];
                        const temp = N[r] / (rv + lv);
                        N[r] = saved + rv * temp;
                        saved = lv * temp;
                    }
                    N[j] = saved;
                }
                return N;
            };
            const calcSurfacePoint = (u, v) => {
                const uspan = findSpan(knotsU, degreeU, u);
                const vspan = findSpan(knotsV, degreeV, v);
                const Nu = calcBasisFunctions(knotsU, degreeU, uspan, u);
                const Nv = calcBasisFunctions(knotsV, degreeV, vspan, v);
                const temp = [];
                for (let l = 0; l <= degreeV; ++l) {
                    temp[l] = gl_matrix_1.vec4.create();
                    for (let k = 0; k <= degreeU; ++k) {
                        const point = gl_matrix_1.vec4.clone(controlPoints[uspan - degreeU + k][vspan - degreeV + l]);
                        const w = point[3];
                        point[0] *= w;
                        point[1] *= w;
                        point[2] *= w;
                        gl_matrix_1.vec4.add(temp[l], temp[l], gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), point, gl_matrix_1.vec4.fromValues(Nu[k], Nu[k], Nu[k], Nu[k])));
                    }
                }
                const Sw = gl_matrix_1.vec4.create();
                for (let l = 0; l <= degreeV; ++l) {
                    gl_matrix_1.vec4.add(Sw, Sw, gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), temp[l], gl_matrix_1.vec4.fromValues(Nv[l], Nv[l], Nv[l], Nv[l])));
                }
                gl_matrix_1.vec4.divide(Sw, Sw, gl_matrix_1.vec4.fromValues(Sw[3], Sw[3], Sw[3], Sw[3]));
                return gl_matrix_1.vec3.fromValues(Sw[0], Sw[1], Sw[2]);
            };
            const getPointOnSurfacepatch = (t1, t2) => {
                const u = knotsU[0] + t1 * (knotsU[knotsU.length - 1] - knotsU[0]); // linear mapping t1->u
                const v = knotsV[0] + t2 * (knotsV[knotsV.length - 1] - knotsV[0]); // linear mapping t2->u
                return calcSurfacePoint(u, v);
            };
            const numberOfPoints = 15;
            const indices = [];
            const vertices = [];
            for (let d = 0; d <= numberOfPoints; d++) {
                const v = d / numberOfPoints;
                for (let f = 0; f <= numberOfPoints; f++) {
                    const u = f / numberOfPoints;
                    const vertex = getPointOnSurfacepatch(u, v);
                    vertices.push(vertex[0], vertex[1], vertex[2]);
                }
            }
            for (let d = 0; d < numberOfPoints; d++) {
                for (let f = 0; f < numberOfPoints; f++) {
                    const i1 = d * (numberOfPoints + 1) + f;
                    const i2 = d * (numberOfPoints + 1) + f + 1;
                    const i3 = (d + 1) * (numberOfPoints + 1) + f;
                    const i4 = (d + 1) * (numberOfPoints + 1) + f + 1;
                    // faces one and two
                    indices.push(i3, i2, i1);
                    indices.push(i2, i3, i4);
                }
            }
            const attributes = {};
            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);
            // to not compute normals ourselves, we just let three.js do it
            // in our geometry loader, this array will cause the computation of vertex normals
            attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 3, 0, 0, 0, false, vertices.length / 3);
            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)));
            surfacepatchNode.data.push(geometry);
            return surfacepatchNode;
        });
    }
    loadScene() {
        return __awaiter(this, void 0, void 0, function* () {
            const sceneNode = new viewer_shared_node_tree_1.TreeNode('sdgtf_content');
            // arcs
            if (this._content.arcs)
                sceneNode.addChild(yield this.loadArcs());
            // beziercurves
            if (this._content.beziercurves) {
                for (let beziercurve in this._content.beziercurves)
                    sceneNode.addChild(yield this.loadBeziercurve(beziercurve));
            }
            // circles
            if (this._content.circles)
                sceneNode.addChild(yield this.loadCircles());
            // cylinders
            if (this._content.cylinders)
                sceneNode.addChild(yield this.loadCylinders());
            //points
            if (this._content.points) {
                for (let point in this._content.points)
                    sceneNode.addChild(yield this.loadPoint(point));
            }
            // polylines
            if (this._content.polylines) {
                for (let line in this._content.polylines)
                    sceneNode.addChild(yield this.loadPolyline(line));
            }
            // spheres
            if (this._content.spheres)
                sceneNode.addChild(yield this.loadSpheres());
            // surfacepatches
            if (this._content.surfacepatches) {
                for (let surfacepatch in this._content.surfacepatches)
                    sceneNode.addChild(yield this.loadSurfacepatch(surfacepatch));
            }
            return sceneNode;
        });
    }
}
exports.SDGTFLoader = SDGTFLoader;
//# sourceMappingURL=SDGTFLoader.js.map