"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createViewport = exports.createSession = exports.generalOptions = exports.sessions = exports.viewports = exports.sceneTree = exports.removeListener = exports.addListener = void 0;
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const tsyringe_1 = require("tsyringe");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_2 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_3 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_4 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_5 = require("@shapediver/viewer.shared.services");
const viewer_main_creation_control_center_1 = require("@shapediver/viewer.main.creation-control-center");
const ViewportApi_1 = require("./implementation/viewport/ViewportApi");
const SessionApi_1 = require("./implementation/session/SessionApi");
const viewer_shared_build_data_1 = require("@shapediver/viewer.shared.build-data");
const creationControlCenter = tsyringe_1.container.resolve(viewer_main_creation_control_center_1.CreationControlCenter);
const inputValidator = tsyringe_1.container.resolve(viewer_shared_services_5.InputValidator);
const logger = tsyringe_1.container.resolve(viewer_shared_services_2.Logger);
const eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
console.log(`Powered by:
   _____  __                         ____   _                   
  / ___/ / /_   ____ _ ____   ___   / __ \\ (_)_   __ ___   _____
  \\__ \\ / __ \\ / __ '// __ \\ / _ \\ / / / // /| | / // _ \\ / ___/
 ___/ // / / // /_/ // /_/ //  __// /_/ // / | |/ //  __// /    
/____//_/ /_/ \\__,_// .___/ \\___//_____//_/  |___/ \\___//_/     
                   /_/                                          
ShapeDiver Viewer 3, Version ${viewer_shared_build_data_1.build_data.build_version.replace('3.', '')}
Visit us at https://shapediver.com/ and find out more!
`);
class GeneralOptions {
    // #region Public Accessors (4)
    get loggingLevel() {
        return logger.loggingLevel;
    }
    set loggingLevel(value) {
        try {
            inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'loggingLevel', value, 'enum', true, Object.values(viewer_shared_services_1.LOGGING_LEVEL));
            logger.loggingLevel = value;
            logger.debug(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `loggingLevel: LoggingLevel was set to: ${value}`);
        }
        catch (e) {
            if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
                throw e;
            throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'loggingLevel', e);
        }
    }
    get showMessages() {
        return logger.showMessages;
    }
    set showMessages(value) {
        try {
            inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'showMessages', value, 'boolean');
            logger.showMessages = value;
            logger.debug(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `showMessages: ShowMessages was set to: ${value}`);
        }
        catch (e) {
            if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
                throw e;
            throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'showMessages', e);
        }
    }
}
/**
 * Adds an event listener.
 *
 * @param type The type of event.
 * @param cb The callback.
 * @returns
 */
const addListener = (type, cb) => {
    try {
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `addListener`, type, 'string');
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `addListener`, cb, 'function');
        logger.debug(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `addListener: Event Listener was registered for ${type}.`);
        return eventEngine.addListener(type, cb);
    }
    catch (e) {
        if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
            throw e;
        throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'addListener', e);
    }
};
exports.addListener = addListener;
/**
 * Removes an event listener.
 *
 * @param id The id of the listener.
 * @returns
 */
const removeListener = (id) => {
    try {
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `removeListener`, id, 'string');
        logger.debug(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, `removeListener: Removing event listener with id ${id}.`);
        return eventEngine.removeListener(id);
    }
    catch (e) {
        if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
            throw e;
        throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'removeListener', e);
    }
};
exports.removeListener = removeListener;
/**
 * The scene tree that is used to store the scene.
 * The scene tree contains a unique node and child nodes for each session,
 * and can also be used to add your own nodes.
 */
exports.sceneTree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
/**
 * The viewports that are currently being used.
 */
exports.viewports = {};
/**
 * The sessions that are currently being used.
 */
exports.sessions = {};
// Whenever a session or viewport is added or removed, this update is called.
creationControlCenter.update = (sessionEngines, renderingEngines) => {
    for (let s in sessionEngines)
        if (!exports.sessions[s])
            exports.sessions[s] = new SessionApi_1.SessionApi(sessionEngines[s]);
    for (let s in exports.sessions)
        if (!sessionEngines[s])
            delete exports.sessions[s];
    for (let v in renderingEngines)
        if (!exports.viewports[v])
            exports.viewports[v] = new ViewportApi_1.ViewportApi(renderingEngines[v]);
    for (let v in exports.viewports) {
        if (!renderingEngines[v])
            delete exports.viewports[v];
    }
};
/**
 * General Viewer options that are used everywhere.
 * - loggingLevel: The logging level that is used.
 * - showMessages: Option to show/hide messages in the browser console.
 */
exports.generalOptions = new GeneralOptions();
/**
 * Create and initialize a session with a model hosted on a
 * {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend},
 * using the provided ticket and modelViewUrl.
 * Returns a session api object allowing to control the session.
 *
 * A JWT can be specified for authorizing the API calls to the Geometry Backend.
 * The model's settings on the Geometry Backend might require a JWT to be provided.
 *
 * By default the outputs of the model for its default parameter values will be loaded.
 *
 * An optional identifier for the session can be provided. This identifier can be used to retrieve the
 * api object from {@link sessions}. In case no identifier is provided, a unique one will be generated.
 *
 * @param properties.ticket The ticket for direct embedding of the model to create a session for. This identifies the model on the Geometry Backend.
 * @param properties.modelViewUrl The modelViewUrl of the {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend} hosting the model.
 * @param properties.jwtToken The JWT to use for authorizing the API calls to the Geometry Backend.
 * @param properties.id The unique identifier to use for the session.
 * @param properties.waitForOutputs Option to wait for the outputs to be loaded, or return immediately after creation of the session. (default: true)
 * @param properties.loadOutputs Option to load the outputs, or not load them until the first call of {@link ISessioncustomize}. (default: true)
 * @param properties.excludeViewports Option to exclude some viewports from the start. Can be accessed via {@link ISessionexcludeViewports}.
 * @param properties.initialParameterValues The initial set of parameter values to use. Map from parameter id to parameter value. The default value will be used for any parameter not specified.
 * @returns
 */
const createSession = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        logger.info(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession: Creating and initializing session with properties ${JSON.stringify(properties)}.`);
        // input validation
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties, 'object');
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.ticket, 'string');
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.modelViewUrl, 'string');
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.jwtToken, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.id, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.waitForOutputs, 'boolean', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.loadOutputs, 'boolean', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.excludeViewports, 'stringArray', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.initialParameterValues, 'object', false);
        if (properties.initialParameterValues)
            for (let p in properties.initialParameterValues)
                inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, properties.initialParameterValues[p], 'string');
        if (properties.waitForOutputs === undefined)
            properties.waitForOutputs = true;
        if (properties.loadOutputs === undefined)
            properties.loadOutputs = true;
        const sessionEngine = yield creationControlCenter.createSessionEngine(properties);
        exports.sessions[sessionEngine.id] = new SessionApi_1.SessionApi(sessionEngine);
        return exports.sessions[sessionEngine.id];
    }
    catch (e) {
        if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
            throw e;
        throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.SESSION, `createSession`, e);
    }
});
exports.createSession = createSession;
/**
 * Create and initialize a viewport with the provided type and canvas,
 * and return a viewport api object allowing to control it.
 *
 * An optional identifier for the viewport can be provided. This identifier can be used to retrieve the
 * viewport object from {@link viewports}. In case no identifier is provided, a unique one will be generated.
 *
 * By default a new viewport displays the complete scene tree. Viewports can be excluded from
 * displaying geometry for specific sessions by using the {@link excludeViewports} property of
 * {@link ISessionApi}.
 *
 * @param properties.visibility The visibility of the viewport.
 * @param properties.canvas The canvas that the viewport should use. A canvas element will be created if none is provided.
 * @param properties.id The unique identifier to use for the viewport.
 * @param properties.branding Optional branding options.
 * @param properties.sessionSettingsId Optional identifier of the session to be used for loading / persisting settings of the viewport when the {@link SESSION_SETTINGS_MODE} is set to MANUAL.
 * @param properties.sessionSettingsMode Allows to control which session to use for loading / persisting settings of the viewport. (default: {@link SESSION_SETTINGS_MODE.FIRST}).
 * @returns
 */
const createViewport = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, 'createViewport', properties, 'object', false);
        const prop = Object.assign({}, properties);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, prop.canvas, 'HTMLCanvasElement', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, prop.id, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, prop.sessionSettingsId, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, prop.sessionSettingsMode, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE));
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, prop.visibility, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE));
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, 'createViewport', prop.branding, 'object', false);
        const branding = Object.assign({}, prop.branding);
        if (branding.logo !== null)
            inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, branding.logo, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, branding.backgroundColor, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, branding.busyModeSpinner, 'string', false);
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, branding.busyModeDisplay, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY));
        inputValidator.validateAndError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, `createViewport`, branding.spinnerPositioning, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING));
        prop.sessionSettingsMode = prop.sessionSettingsMode !== undefined ? prop.sessionSettingsMode : viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE.FIRST;
        if (prop.sessionSettingsMode === viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE.MANUAL && !prop.sessionSettingsId) {
            const error = new viewer_shared_services_1.ShapeDiverViewerValidationError(`createViewport: Input could not be validated. sessionSettingsId has to point to a valid and created session when using SESSION_SETTINGS_MODE.MANUAL`, prop.sessionSettingsId, 'string');
            throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.VIEWPORT, 'createViewport', error, false);
        }
        const renderingEngine = yield creationControlCenter.createRenderingEngineThreeJs(prop);
        exports.viewports[renderingEngine.id] = new ViewportApi_1.ViewportApi(renderingEngine);
        return exports.viewports[renderingEngine.id];
    }
    catch (e) {
        if (e instanceof viewer_shared_services_3.ShapeDiverViewerError || e instanceof viewer_shared_services_4.ShapeDiverBackendError)
            throw e;
        throw logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.GENERAL, 'createViewport', e);
    }
});
exports.createViewport = createViewport;
//# sourceMappingURL=main.js.map