"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeDiverModelApi = void 0;
const sdk_geometry_api_sdk_core_1 = require("@shapediver/sdk.geometry-api-sdk-core");
const utils_1 = require("../utils/utils");
class ShapeDiverModelApi extends sdk_geometry_api_sdk_core_1.BaseResourceApi {
    constructor(api) {
        super(api);
    }
    /**
     * Get information about a ShapeDiver Model.
     *
     * @param modelId
     */
    get(modelId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.get(this.buildModelUri(modelId)))[1]; }));
        });
    }
    /**
     * Create a new ShapeDiver Model.
     *
     * @param body
     */
    create(body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.post(this.commonPath, body))[1]; }));
        });
    }
    /**
     * Update properties of a ShapeDiver Model.
     *
     * @param modelId
     * @param body
     */
    update(modelId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.put(this.buildModelUri(modelId), body))[1]; }));
        });
    }
    /**
     * Delete a ShapeDiver Model.
     *
     * @param modelId
     */
    delete(modelId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.delete(this.buildModelUri(modelId)))[1]; }));
        });
    }
    /**
     * Get configurations of the viewer.
     *
     * @param modelId
     */
    getConfig(modelId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.get(this.buildModelUri(modelId) + "/config"))[1]; }));
        });
    }
    /**
     * Create viewer configurations.
     *
     * @param modelId
     * @param body
     */
    createConfig(modelId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.post(this.buildModelUri(modelId) + "/config", body))[1]; }));
        });
    }
    /**
     * Update viewer configurations.
     *
     * @param modelId
     * @param body
     */
    updateConfig(modelId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.patch(this.buildModelUri(modelId) + "/config", body))[1]; }));
        });
    }
    /**
     * Download the Grasshopper file of the ShapeDiver Model.
     *
     * @param modelId
     */
    getFile(modelId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return (yield this.api.get(this.buildModelUri(modelId) + "/file/download", { contentType: "application/json", responseType: sdk_geometry_api_sdk_core_1.ShapeDiverSdkApiResponseType.DATA }))[1];
            }));
        });
    }
    /**
     * Set the default parameters for the ShapeDiver Model.
     *
     * @param modelId
     * @param body
     */
    setDefaultParams(modelId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.patch(this.buildModelUri(modelId) + "/parameter/defval", body))[1]; }));
        });
    }
    /**
     * Updates the definitions of the given parameters.
     *
     * @param modelId
     * @param body
     */
    updateParameterDefinitions(modelId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.patch(this.buildModelUri(modelId) + "/parameter", body))[1]; }));
        });
    }
    /**
     * Query model computation statistics.
     *
     * @param modelId
     * @param timestampFrom - Timestamp to query from
     * @param timestampTo - Timestamp to query to.
     * @param limit - How many items to return at most.
     * @param strictLimit - Whether the limit shall be attained (if there are enough items).
     * @param order - Order in which to query computation stats items.
     * @param status - Filter computations by the result status.
     * @param type - Filter computations by type.
     * @param offset - Continuation token for pagination.
     */
    queryComputations(modelId, timestampFrom, timestampTo, limit, strictLimit, order, status, type, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            // Build queries
            const queries = [];
            if (timestampFrom !== undefined)
                queries.push("timestamp_from=" + timestampFrom);
            if (timestampTo !== undefined)
                queries.push("timestamp_to=" + timestampTo);
            if (limit !== undefined)
                queries.push("limit=" + limit);
            if (strictLimit !== undefined)
                queries.push("strict_limit=" + strictLimit);
            if (order !== undefined)
                queries.push("order=" + order);
            if (status !== undefined)
                queries.push("status=" + status);
            if (type !== undefined)
                queries.push("type=" + type);
            if (offset !== undefined)
                queries.push("offset=" + offset);
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.get(this.buildModelUri(modelId) + "/computations?" + queries.join("&")))[1]; }));
        });
    }
    /**
     * Delete old export components.
     *
     * @param modelId
     * @param untilLastSeen - Delete all components that have been used last before this timestamp.
     */
    enqueueCleanupExports(modelId, untilLastSeen) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.post(this.buildModelUri(modelId) + "/cleanup/export?untilLastSeen=" + untilLastSeen))[1]; }));
        });
    }
    /**
     * Delete old output components.
     *
     * @param modelId
     * @param untilLastSeen - Delete all components that have been used last before this timestamp.
     */
    enqueueCleanupOutputs(modelId, untilLastSeen) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.post(this.buildModelUri(modelId) + "/cleanup/output?untilLastSeen=" + untilLastSeen))[1]; }));
        });
    }
    /**
     * Delete old texture components.
     *
     * @param modelId
     * @param untilLastSeen - Delete all components that have been used last before this timestamp.
     */
    enqueueCleanupTextures(modelId, untilLastSeen) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.post(this.buildModelUri(modelId) + "/cleanup/texture?untilLastSeen=" + untilLastSeen))[1]; }));
        });
    }
    /**
     * Get the status of all running model cleanup processes.
     *
     * @param modelId
     */
    getCleanupStatus(modelId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return (yield this.api.get(this.buildModelUri(modelId) + "/cleanup/status"))[1]; }));
        });
    }
}
exports.ShapeDiverModelApi = ShapeDiverModelApi;
//# sourceMappingURL=ShapeDiverModelApi.js.map