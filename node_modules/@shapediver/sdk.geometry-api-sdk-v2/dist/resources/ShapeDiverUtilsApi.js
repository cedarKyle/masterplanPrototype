"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeDiverUtilsApi = void 0;
const sdk_geometry_api_sdk_core_1 = require("@shapediver/sdk.geometry-api-sdk-core");
const utils_1 = require("../utils/utils");
class ShapeDiverUtilsApi extends sdk_geometry_api_sdk_core_1.BaseResourceApi {
    constructor(api) {
        super(api);
    }
    /**
     * Upload the given file to the specified URL.
     *
     * @param url - The target URL of the upload request.
     * @param data - The data that should be uploaded.
     * @param contentType - Indicate the original media type of the resource.
     */
    upload(url, data, contentType) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return this.api.put(url, data, {
                    contentType: contentType,
                    responseType: sdk_geometry_api_sdk_core_1.ShapeDiverSdkApiResponseType.JSON,
                    disableAuthorization: true,
                    disableCustomHeaders: true,
                });
            }));
        });
    }
    /**
     * Download from the given URL.
     *
     * @param url - The target URL of the download request.
     * @param responseType - Indicates the type of data that the server should respond with if possible.
     */
    download(url, responseType) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return this.api.get(url, {
                    contentType: "application/json",
                    responseType: responseType,
                    disableAuthorization: true,
                    disableCustomHeaders: true,
                });
            }));
        });
    }
    /**
     * Submit a customization request and wait for the result to be finished.
     *
     * @param sdk
     * @param sessionId
     * @param body
     * @param maxWaitMsec - Maximum duration to wait for result (in milliseconds), pass value < 0 to disable limit.
     * @throws {@link ShapeDiverError} in case a maximum duration has been specified and is exceeded.
     * @returns
     */
    submitAndWaitForCustomization(sdk, sessionId, body, maxWaitMsec = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const startMsec = Date.now();
            const dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.output.customize(sessionId, body); }));
            const waitMsec = Date.now() - startMsec;
            // Reduce the total max waiting time by the amount the customization-request took
            maxWaitMsec = (maxWaitMsec < 0) ? maxWaitMsec : Math.max(0, maxWaitMsec - waitMsec);
            return ShapeDiverUtilsApi.waitForCustomizationResult(sdk, sessionId, dto, maxWaitMsec);
        });
    }
    /**
     * Submit an export request and wait for the result to be finished.
     *
     * @param sdk
     * @param sessionId
     * @param body
     * @param maxWaitMsec - Maximum duration to wait for result (in milliseconds), pass value < 0 to disable limit.
     * @throws {@link ShapeDiverError} in case a maximum duration has been specified and is exceeded.
     * @returns
     */
    submitAndWaitForExport(sdk, sessionId, body, maxWaitMsec = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const startMsec = Date.now();
            const dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.export.compute(sessionId, body); }));
            const waitMsec = Date.now() - startMsec;
            // Reduce the total max waiting time by the amount the compute-request took
            maxWaitMsec = (maxWaitMsec < 0) ? maxWaitMsec : Math.max(0, maxWaitMsec - waitMsec);
            return ShapeDiverUtilsApi.waitForExportResult(sdk, sessionId, dto, body.exports.id, maxWaitMsec);
        });
    }
    /**
     * Given a DTO resulting from a customization request, wait for the results to be finished.
     *
     * @param sdk
     * @param sessionId
     * @param dto
     * @param maxWaitMsec - Maximum duration to wait for result (in milliseconds), pass value < 0 to disable limit.
     * @returns
     */
    static waitForCustomizationResult(sdk, sessionId, dto, maxWaitMsec = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!dto.outputs)
                return dto;
            // Build new cache request
            const outputVersions = {};
            Object
                .keys(dto.outputs)
                .forEach(id => outputVersions[id] = dto.outputs[id].version);
            let delay = ShapeDiverUtilsApi.getMaxOutputDelay(dto);
            const startMsec = Date.now();
            while (delay > 0) {
                // Check whether maxWaitMsec has been reached
                if (maxWaitMsec >= 0) {
                    const waitMsec = Date.now() - startMsec;
                    if (waitMsec >= maxWaitMsec) {
                        throw new sdk_geometry_api_sdk_core_1.ShapeDiverError(`Maximum wait time of ${maxWaitMsec} ms reached`);
                    }
                    if (waitMsec + delay > maxWaitMsec) {
                        delay = maxWaitMsec - waitMsec;
                    }
                }
                yield (0, utils_1.sleep)(delay);
                // Send cache request
                dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.output.getCache(sessionId, outputVersions); }));
                delay = ShapeDiverUtilsApi.getMaxOutputDelay(dto);
            }
            return dto;
        });
    }
    /**
     * Given a DTO resulting from an export request, wait for the result to be finished.
     *
     * @param sdk
     * @param sessionId
     * @param dto
     * @param exportId
     * @param maxWaitMsec - Maximum duration to wait for result (in milliseconds), pass value < 0 to disable limit.
     * @returns
     */
    static waitForExportResult(sdk, sessionId, dto, exportId, maxWaitMsec = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!dto.exports)
                throw new sdk_geometry_api_sdk_core_1.ShapeDiverError("The given DTO does not contain any exports");
            // Build new cache request
            const exportVersion = { [exportId]: dto.exports[exportId].version };
            if (!dto.exports)
                throw new sdk_geometry_api_sdk_core_1.ShapeDiverError(`Could not find any export with the id '${exportId}'`);
            let delay = ShapeDiverUtilsApi.getExportDelay(dto, exportId);
            const startMsec = Date.now();
            while (delay > 0) {
                // Check whether maxWaitMsec has been reached
                if (maxWaitMsec >= 0) {
                    const waitMsec = Date.now() - startMsec;
                    if (waitMsec >= maxWaitMsec) {
                        throw new sdk_geometry_api_sdk_core_1.ShapeDiverError(`Maximum wait time of ${maxWaitMsec} ms reached`);
                    }
                    if (waitMsec + delay > maxWaitMsec) {
                        delay = maxWaitMsec - waitMsec;
                    }
                }
                yield (0, utils_1.sleep)(delay);
                // Send cache request
                dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.export.getCache(sessionId, exportVersion); }));
                delay = ShapeDiverUtilsApi.getExportDelay(dto, exportId);
            }
            return dto;
        });
    }
    /**
     * Get the maximum delay which was reported for output versions.
     *
     * @param dto
     * @returns maximum delay, -1 in case no delay was reported
     */
    static getMaxOutputDelay(dto) {
        return Math.max(...Object.values(dto.outputs)
            .map(output => output)
            .map(output => { var _a; return (_a = output.delay) !== null && _a !== void 0 ? _a : -1; }));
    }
    /**
     * Get the delay which was reported for the export.
     *
     * @param dto
     * @param exportId
     * @returns delay, -1 in case no delay was reported
     */
    static getExportDelay(dto, exportId) {
        var _a;
        return (_a = dto.exports[exportId].delay) !== null && _a !== void 0 ? _a : -1;
    }
}
exports.ShapeDiverUtilsApi = ShapeDiverUtilsApi;
//# sourceMappingURL=ShapeDiverUtilsApi.js.map