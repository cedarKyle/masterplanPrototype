"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfGeometryTypeReader = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const SdtfGeometryTypeValidator_1 = require("./SdtfGeometryTypeValidator");
class SdtfGeometryTypeReader {
    constructor() {
        this.validator = new SdtfGeometryTypeValidator_1.SdtfGeometryTypeValidator();
    }
    readComponent(component) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const typeHint = (_a = component.typeHint) === null || _a === void 0 ? void 0 : _a.name;
            // Make sure that the component consists of valid data
            if (!this.validator.validateComponent(typeHint, component.value, component.accessor)) {
                throw new sdk_sdtf_core_1.SdtfError(`Cannot read value of type '${typeHint}': Invalid component.`);
            }
            // All values of a geometry type are stored inside the JSON content.
            switch (typeHint) {
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_ARC:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_BOUNDING_BOX:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_BOX:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_CIRCLE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_COMPLEX:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_CONE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_CYLINDER:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_ELLIPSE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_INTERVAL:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_INTERVAL2:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_LINE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_MATRIX:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_PLANE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_POINT:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_POLYLINE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_RAY:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_RECTANGLE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_SPHERE:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_TORUS:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_TRANSFORM:
                case sdk_sdtf_core_1.SdtfGeometryTypeHintName.GEOMETRY_VECTOR:
                    return component.value;
                default:
                    (0, sdk_sdtf_core_1.sdAssertUnreachable)(typeHint);
            }
        });
    }
}
exports.SdtfGeometryTypeReader = SdtfGeometryTypeReader;
//# sourceMappingURL=SdtfGeometryTypeReader.js.map