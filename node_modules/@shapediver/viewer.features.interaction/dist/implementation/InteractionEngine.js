"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InteractionEngine_canvasEventListenerToken, _InteractionEngine_intersectionEngine, _InteractionEngine_logger, _InteractionEngine_managers, _InteractionEngine_uuidGenerator, _InteractionEngine_viewport, _InteractionEngine_intersectionOpacity, _InteractionEngine_closed;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionEngine = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const IInteractionEngine_1 = require("../interfaces/IInteractionEngine");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_intersection_engine_1 = require("@shapediver/viewer.rendering-engine.intersection-engine");
const viewer_1 = require("@shapediver/viewer");
class InteractionEngine {
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(viewport) {
        // #region Properties (6)
        _InteractionEngine_canvasEventListenerToken.set(this, void 0);
        _InteractionEngine_intersectionEngine.set(this, tsyringe_1.container.resolve(viewer_rendering_engine_intersection_engine_1.IntersectionEngine));
        _InteractionEngine_logger.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.Logger));
        _InteractionEngine_managers.set(this, {});
        _InteractionEngine_uuidGenerator.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator));
        _InteractionEngine_viewport.set(this, void 0);
        _InteractionEngine_intersectionOpacity.set(this, 0);
        _InteractionEngine_closed.set(this, false);
        __classPrivateFieldSet(this, _InteractionEngine_viewport, viewport, "f");
        __classPrivateFieldSet(this, _InteractionEngine_canvasEventListenerToken, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").addCanvasEventListener(this), "f");
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get intersectionOpacity() {
        return __classPrivateFieldGet(this, _InteractionEngine_intersectionOpacity, "f");
    }
    set intersectionOpacity(value) {
        __classPrivateFieldSet(this, _InteractionEngine_intersectionOpacity, value, "f");
    }
    get managers() {
        return __classPrivateFieldGet(this, _InteractionEngine_managers, "f");
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (14)
    close() {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The InteractionEngine has already been closed.');
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            this.removeInteractionManager(m);
        __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").removeCanvasEventListener(__classPrivateFieldGet(this, _InteractionEngine_canvasEventListenerToken, "f"));
        __classPrivateFieldSet(this, _InteractionEngine_closed, true, "f");
    }
    addInteractionManager(manager) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The InteractionEngine has already been closed.');
        const token = __classPrivateFieldGet(this, _InteractionEngine_uuidGenerator, "f").create();
        __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token] = manager;
        manager.add(__classPrivateFieldGet(this, _InteractionEngine_viewport, "f"));
        return token;
    }
    onKeyDown(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onMouseDown(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").mouseEventToRay(event);
        this.onDown(event, ray);
    }
    onMouseEnd(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onMouseMove(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").mouseEventToRay(event);
        this.onMove(event, ray);
    }
    onMouseOut(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").mouseEventToRay(event);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.OUT);
    }
    onMouseUp(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").mouseEventToRay(event);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.UP);
    }
    onMouseWheel(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onTouchCancel(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        if (event.touches.length > 1)
            return;
        const touch = event.changedTouches[0];
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").touchToRay(touch);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.OUT);
    }
    onTouchEnd(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onTouchMove(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        if (event.touches.length > 1)
            return;
        const touch = event.changedTouches[0];
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").touchToRay(touch);
        this.onMove(event, ray);
    }
    onTouchStart(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        if (event.touches.length > 1)
            return;
        const touch = event.changedTouches[0];
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").touchToRay(touch);
        this.onDown(event, ray);
    }
    onTouchUp(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        if (event.touches.length > 1)
            return;
        const touch = event.changedTouches[0];
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").touchToRay(touch);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.UP);
    }
    removeInteractionManager(token) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The InteractionEngine has already been closed.');
        if (!__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token])
            return false;
        __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token].remove();
        delete __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token];
        return true;
    }
    // #endregion Public Methods (14)
    // #region Private Methods (5)
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onDown(event, ray) {
        const filters = [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.DOWN));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionEngine, "f").intersect(ray, filters, { opacity: __classPrivateFieldGet(this, _InteractionEngine_intersectionOpacity, "f"), rendererType: viewer_1.RENDERER_TYPE.ATTRIBUTES }, viewer_1.sceneTree.root, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id) || [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onDown(event, ray, intersections);
    }
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onEnd(event, ray, endState) {
        const filters = [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(endState));
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.END));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionEngine, "f").intersect(ray, filters, { opacity: __classPrivateFieldGet(this, _InteractionEngine_intersectionOpacity, "f"), rendererType: viewer_1.RENDERER_TYPE.ATTRIBUTES }, viewer_1.sceneTree.root, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id) || [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onEnd(event, ray, intersections, endState);
    }
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onMove(event, ray) {
        const filters = [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.MOVE));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionEngine, "f").intersect(ray, filters, { opacity: __classPrivateFieldGet(this, _InteractionEngine_intersectionOpacity, "f"), rendererType: viewer_1.RENDERER_TYPE.ATTRIBUTES }, viewer_1.sceneTree.root, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id) || [];
        for (let m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onMove(event, ray, intersections);
    }
}
exports.InteractionEngine = InteractionEngine;
_InteractionEngine_canvasEventListenerToken = new WeakMap(), _InteractionEngine_intersectionEngine = new WeakMap(), _InteractionEngine_logger = new WeakMap(), _InteractionEngine_managers = new WeakMap(), _InteractionEngine_uuidGenerator = new WeakMap(), _InteractionEngine_viewport = new WeakMap(), _InteractionEngine_intersectionOpacity = new WeakMap(), _InteractionEngine_closed = new WeakMap();
//# sourceMappingURL=InteractionEngine.js.map