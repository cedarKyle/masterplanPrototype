"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DragManager_eventEngine, _DragManager_uuidGenerator, _DragManager_dragConstraints, _DragManager_effectMaterialToken, _DragManager_filter, _DragManager_intersection, _DragManager_node, _DragManager_setupOptions, _DragManager_tokenCameraFreeze, _DragManager_tokenContinuousRendering, _DragManager_tokenContinuousShadowMapUpdate, _DragManager_nodeWorldMatrix, _DragManager_nodeWorldMatrixInverse, _DragManager_previousDragMatrix;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragManager = void 0;
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_1 = require("@shapediver/viewer");
const IInteractionEngine_1 = require("../../interfaces/IInteractionEngine");
const AbstractInteractionManager_1 = require("../AbstractInteractionManager");
const InteractionData_1 = require("../InteractionData");
class DragManager extends AbstractInteractionManager_1.AbstractInteractionManager {
    constructor() {
        // #region Properties (11)
        super(...arguments);
        _DragManager_eventEngine.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine));
        _DragManager_uuidGenerator.set(this, tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator));
        _DragManager_dragConstraints.set(this, {});
        _DragManager_effectMaterialToken.set(this, void 0);
        _DragManager_filter.set(this, (interactionState) => {
            if (interactionState === IInteractionEngine_1.INTERACTION_STATE.DOWN) {
                return (node) => {
                    for (let i = 0; i < node.data.length; i++) {
                        if (node.data[i] instanceof InteractionData_1.InteractionData) {
                            if (node.data[i].interactionTypes.drag)
                                return true;
                        }
                    }
                    return false;
                };
            }
            return (node) => false;
        });
        _DragManager_intersection.set(this, null);
        _DragManager_node.set(this, null);
        _DragManager_setupOptions.set(this, null);
        _DragManager_tokenCameraFreeze.set(this, void 0);
        _DragManager_tokenContinuousRendering.set(this, void 0);
        _DragManager_tokenContinuousShadowMapUpdate.set(this, void 0);
        _DragManager_nodeWorldMatrix.set(this, gl_matrix_1.mat4.create());
        _DragManager_nodeWorldMatrixInverse.set(this, gl_matrix_1.mat4.create());
        _DragManager_previousDragMatrix.set(this, gl_matrix_1.mat4.create());
        // #endregion Private Methods (4)
    }
    // #endregion Properties (11)
    // #region Public Accessors (1)
    get filter() {
        return __classPrivateFieldGet(this, _DragManager_filter, "f");
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (7)
    add(viewport) {
        this.viewport = viewport;
    }
    remove() {
        this.removeNode();
        this.viewport = undefined;
    }
    /**
     * Add a new drag constraint.
     * Returns a token that is used for removing the drag constraint via {@link removeDragConstraint}.
     *
     * @param constraint
     * @returns
     */
    addDragConstraint(constraint) {
        const token = __classPrivateFieldGet(this, _DragManager_uuidGenerator, "f").create();
        __classPrivateFieldGet(this, _DragManager_dragConstraints, "f")[token] = constraint;
        if (__classPrivateFieldGet(this, _DragManager_setupOptions, "f"))
            constraint.setup(__classPrivateFieldGet(this, _DragManager_setupOptions, "f").viewport, __classPrivateFieldGet(this, _DragManager_setupOptions, "f").node, __classPrivateFieldGet(this, _DragManager_setupOptions, "f").ray, __classPrivateFieldGet(this, _DragManager_setupOptions, "f").intersection, __classPrivateFieldGet(this, _DragManager_previousDragMatrix, "f"));
        return token;
    }
    onDown(event, ray, intersection) {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        const intersections = intersection.filter(i => this.filter(IInteractionEngine_1.INTERACTION_STATE.DOWN)(i.node));
        if (intersections.length > 0)
            this.setNode(intersections[0].node, intersections[0].distance, intersections[0].point, event, ray);
    }
    onEnd(event, ray, intersection, endState) {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        this.removeNode(event);
    }
    onMove(event, ray, intersection) {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        if (!__classPrivateFieldGet(this, _DragManager_node, "f"))
            return;
        let transformation = this.dragConstraintUtils.intersect(__classPrivateFieldGet(this, _DragManager_dragConstraints, "f"), this.viewport, __classPrivateFieldGet(this, _DragManager_node, "f"), ray);
        let transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_nodeWorldMatrixInverse, "f"), transformation.matrix), __classPrivateFieldGet(this, _DragManager_nodeWorldMatrix, "f"));
        this.applyTransformation(__classPrivateFieldGet(this, _DragManager_node, "f"), transformationMatrix);
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_node, "f"));
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_MOVE, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_node, "f"),
            matrix: transformationMatrix,
            ray,
            event,
            dragConstraint: transformation.dragConstraint,
            manager: this
        });
    }
    /**
     * Remove the drag constraint that was added via {@link removeDragConstraint}.
     *
     * @param token
     * @returns
     */
    removeDragConstraint(token) {
        if (!__classPrivateFieldGet(this, _DragManager_dragConstraints, "f")[token])
            return false;
        delete __classPrivateFieldGet(this, _DragManager_dragConstraints, "f")[token];
        return true;
    }
    /**
     * Remove the node as the currently used drag node.
     *
     * @returns
     */
    removeNode(event) {
        var _a;
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        if (!__classPrivateFieldGet(this, _DragManager_node, "f"))
            return;
        const transformationMatrix = (_a = __classPrivateFieldGet(this, _DragManager_node, "f").transformations.find((t) => t.id === 'SD_drag_matrix')) === null || _a === void 0 ? void 0 : _a.matrix;
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_END, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_node, "f"),
            matrix: transformationMatrix,
            event,
            manager: this
        });
        __classPrivateFieldSet(this, _DragManager_setupOptions, null, "f");
        // optional removal
        // this.removeTransformation(this.#node!);
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_node, "f"));
        this.deactivateNode();
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenCameraFreeze, "f"));
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenContinuousRendering, "f"));
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenContinuousShadowMapUpdate, "f"));
    }
    /**
     * Set the current dragged node.
     * This will serve as the start of the drag event.
     * This function is also called internally at onDown events.
     *
     * @param node
     * @param distance
     * @param intersectionPoint
     * @param ray
     */
    setNode(node, distance = 0, intersectionPoint = gl_matrix_1.vec3.create(), event, ray = { origin: gl_matrix_1.vec3.create(), direction: gl_matrix_1.vec3.create() }) {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        this.activateNode({ node, distance, point: intersectionPoint });
        __classPrivateFieldSet(this, _DragManager_setupOptions, { viewport: this.viewport, node: __classPrivateFieldGet(this, _DragManager_node, "f"), ray, intersection: __classPrivateFieldGet(this, _DragManager_intersection, "f") }, "f");
        let transformation = this.dragConstraintUtils.setup(__classPrivateFieldGet(this, _DragManager_dragConstraints, "f"), this.viewport, __classPrivateFieldGet(this, _DragManager_node, "f"), ray, __classPrivateFieldGet(this, _DragManager_intersection, "f"), __classPrivateFieldGet(this, _DragManager_previousDragMatrix, "f"));
        let transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_nodeWorldMatrixInverse, "f"), transformation.matrix), __classPrivateFieldGet(this, _DragManager_nodeWorldMatrix, "f"));
        this.applyTransformation(__classPrivateFieldGet(this, _DragManager_node, "f"), transformationMatrix);
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_node, "f"));
        __classPrivateFieldSet(this, _DragManager_tokenCameraFreeze, this.viewport.addFlag(viewer_1.FLAG_TYPE.CAMERA_FREEZE), "f");
        __classPrivateFieldSet(this, _DragManager_tokenContinuousRendering, this.viewport.addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_RENDERING), "f");
        __classPrivateFieldSet(this, _DragManager_tokenContinuousShadowMapUpdate, this.viewport.addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE), "f");
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_START, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_node, "f"),
            matrix: transformationMatrix,
            intersectionPoint,
            ray,
            event,
            dragConstraint: transformation.dragConstraint,
            manager: this
        });
    }
    // #endregion Public Methods (7)
    // #region Private Methods (4)
    /**
     * Utility function to make the node the current active node.
     * Set the according values, apply the effect and emit the event.
     *
     * @param intersection
     */
    activateNode(intersection) {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        __classPrivateFieldSet(this, _DragManager_intersection, intersection, "f");
        __classPrivateFieldSet(this, _DragManager_node, __classPrivateFieldGet(this, _DragManager_intersection, "f").node, "f");
        __classPrivateFieldSet(this, _DragManager_previousDragMatrix, this.removeTransformation(__classPrivateFieldGet(this, _DragManager_node, "f")), "f");
        __classPrivateFieldSet(this, _DragManager_nodeWorldMatrix, __classPrivateFieldGet(this, _DragManager_node, "f").worldMatrix, "f");
        __classPrivateFieldSet(this, _DragManager_nodeWorldMatrixInverse, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_nodeWorldMatrix, "f")), "f");
        const data = __classPrivateFieldGet(this, _DragManager_node, "f").data.find((d) => d instanceof InteractionData_1.InteractionData);
        if (data)
            data.interactionStates.drag = true;
        if (this.effectMaterial) {
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, this.interactionEffectUtils.applyEffectMaterial(__classPrivateFieldGet(this, _DragManager_node, "f"), this.effectMaterial), "f");
        }
        else {
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, undefined, "f");
        }
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_node, "f"));
        this.viewport.render();
    }
    /**
     * Utility function to apply the transformation to the current node.
     *
     * @param node
     * @param matrix
     */
    applyTransformation(node, matrix) {
        const index = node.transformations.findIndex((t) => t.id === 'SD_drag_matrix');
        if (index !== -1) {
            node.transformations[index].matrix = matrix;
        }
        else {
            node.addTransformation({ id: 'SD_drag_matrix', matrix });
        }
    }
    /**
     * Utility function to make the node inactive.
     * Set the according values, remove the effect and emit the event.
     *
     * @param intersection
     */
    deactivateNode() {
        if (!this.viewport)
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError('The interaction manager does not belong to an interaction engine. Please add it to one first.');
        if (__classPrivateFieldGet(this, _DragManager_effectMaterialToken, "f")) {
            this.interactionEffectUtils.removeEffectMaterial(__classPrivateFieldGet(this, _DragManager_node, "f"), __classPrivateFieldGet(this, _DragManager_effectMaterialToken, "f"));
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, undefined, "f");
        }
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_node, "f"));
        this.viewport.render();
        const data = __classPrivateFieldGet(this, _DragManager_node, "f").data.find((d) => d instanceof InteractionData_1.InteractionData);
        if (data)
            data.interactionStates.drag = false;
        __classPrivateFieldSet(this, _DragManager_intersection, null, "f");
        __classPrivateFieldSet(this, _DragManager_node, null, "f");
    }
    removeTransformation(node) {
        const index = node.transformations.findIndex((t) => t.id === 'SD_drag_matrix');
        if (index !== -1) {
            const matrix = gl_matrix_1.mat4.clone(node.transformations[index].matrix);
            node.removeTransformation(node.transformations[index]);
            return matrix;
        }
        return gl_matrix_1.mat4.create();
    }
}
exports.DragManager = DragManager;
_DragManager_eventEngine = new WeakMap(), _DragManager_uuidGenerator = new WeakMap(), _DragManager_dragConstraints = new WeakMap(), _DragManager_effectMaterialToken = new WeakMap(), _DragManager_filter = new WeakMap(), _DragManager_intersection = new WeakMap(), _DragManager_node = new WeakMap(), _DragManager_setupOptions = new WeakMap(), _DragManager_tokenCameraFreeze = new WeakMap(), _DragManager_tokenContinuousRendering = new WeakMap(), _DragManager_tokenContinuousShadowMapUpdate = new WeakMap(), _DragManager_nodeWorldMatrix = new WeakMap(), _DragManager_nodeWorldMatrixInverse = new WeakMap(), _DragManager_previousDragMatrix = new WeakMap();
//# sourceMappingURL=DragManager.js.map