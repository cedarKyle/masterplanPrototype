"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateDragMatrix = void 0;
const gl_matrix_1 = require("gl-matrix");
const InteractionData_1 = require("../InteractionData");
const calculateDragMatrix = (node, snapPoint, snapRotation, dragOrigin, closestPoint) => {
    const data = node.data.find(d => d instanceof InteractionData_1.InteractionData);
    if (data && data.dragAnchors.length > 0) {
        const results = [];
        for (let i = 0; i < data.dragAnchors.length; i++) {
            const matrix = calculateMatrix(data.dragAnchors[i].position, data.dragAnchors[i].rotation || { axis: gl_matrix_1.vec3.fromValues(0, 0, 1), angle: 0 }, snapPoint, snapRotation);
            const transformedPoint = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), dragOrigin, matrix);
            results.push({ matrix, transformedPoint });
        }
        results.sort((a, b) => gl_matrix_1.vec3.distance(a.transformedPoint, closestPoint) - gl_matrix_1.vec3.distance(b.transformedPoint, closestPoint));
        return results[0].matrix;
    }
    else {
        return calculateMatrix(dragOrigin, { axis: gl_matrix_1.vec3.fromValues(0, 0, 1), angle: 0 }, snapPoint, snapRotation);
    }
};
exports.calculateDragMatrix = calculateDragMatrix;
const calculateMatrix = (dragPoint, dragRotation, snapPoint, snapRotation) => {
    const rotationMatrix = gl_matrix_1.mat4.create();
    // apply inverted anchor matrix
    const dragMatrix = gl_matrix_1.mat4.fromRotation(gl_matrix_1.mat4.create(), dragRotation.angle, dragRotation.axis);
    gl_matrix_1.mat4.multiply(rotationMatrix, rotationMatrix, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), dragMatrix));
    // apply snap matrix
    const snapMatrix = gl_matrix_1.mat4.fromRotation(gl_matrix_1.mat4.create(), snapRotation.angle, snapRotation.axis);
    gl_matrix_1.mat4.multiply(rotationMatrix, rotationMatrix, snapMatrix);
    // the dragAnchor in the rotated space
    const dragPointTransformed = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), dragPoint, rotationMatrix);
    // distance between snap point and transformed anchor
    const dragTranslation = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), snapPoint, dragPointTransformed);
    // transformation of the difference
    gl_matrix_1.vec3.transformMat4(dragTranslation, dragTranslation, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), rotationMatrix));
    const translationMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), dragTranslation);
    return gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), rotationMatrix, translationMatrix);
};
//# sourceMappingURL=DragConstraintsHelper.js.map