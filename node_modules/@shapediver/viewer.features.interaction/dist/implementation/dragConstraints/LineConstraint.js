"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineConstraint_dragLineLength, _LineConstraint_dragOrigin, _LineConstraint_dragRay, _LineConstraint_point1, _LineConstraint_point2, _LineConstraint_radius, _LineConstraint_rotation;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineConstraint = void 0;
const gl_matrix_1 = require("gl-matrix");
const InteractionData_1 = require("../InteractionData");
const DragConstraintsHelper_1 = require("./DragConstraintsHelper");
/**
 * The line constraint is used for dragging and allows the specification of a line along which objects can be dragged.
 * The radius defines in which distance this constraint is being considered to be chosen from the constraints defined.
 * The transformation and optional rotation of this constraint get applied to the node if it is the constraint with the closest distance to the ray that was used for the drag event.
 * As this is a difficult topic, please visit our [help desk section on interactions](https://help.shapediver.com/doc/interactions-part-1) where we go through the process of setting everything up with examples.
 */
class LineConstraint {
    // #endregion Properties (7)
    // #region Constructors (1)
    /**
     * @param _point1 the start point of the line
     * @param _point2 the end point of the line
     * @param _radius the radius in which the line is considered
     * @param _rotation the rotation in [axis-angle representation](https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation) that is applied to the node if the drag contraint becomes active
     */
    constructor(_point1, _point2, _radius = 0, _rotation) {
        // #region Properties (7)
        _LineConstraint_dragLineLength.set(this, void 0);
        _LineConstraint_dragOrigin.set(this, void 0);
        _LineConstraint_dragRay.set(this, void 0);
        _LineConstraint_point1.set(this, void 0);
        _LineConstraint_point2.set(this, void 0);
        _LineConstraint_radius.set(this, 0);
        _LineConstraint_rotation.set(this, void 0);
        __classPrivateFieldSet(this, _LineConstraint_point1, _point1, "f");
        __classPrivateFieldSet(this, _LineConstraint_point2, _point2, "f");
        __classPrivateFieldSet(this, _LineConstraint_radius, _radius, "f");
        __classPrivateFieldSet(this, _LineConstraint_rotation, _rotation || { axis: gl_matrix_1.vec3.fromValues(0, 0, 1), angle: 0 }, "f");
        const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineConstraint_point2, "f"), __classPrivateFieldGet(this, _LineConstraint_point1, "f"));
        __classPrivateFieldSet(this, _LineConstraint_dragLineLength, gl_matrix_1.vec3.length(direction), "f");
        __classPrivateFieldSet(this, _LineConstraint_dragRay, {
            origin: __classPrivateFieldGet(this, _LineConstraint_point1, "f"),
            direction: gl_matrix_1.vec3.divide(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(__classPrivateFieldGet(this, _LineConstraint_dragLineLength, "f"), __classPrivateFieldGet(this, _LineConstraint_dragLineLength, "f"), __classPrivateFieldGet(this, _LineConstraint_dragLineLength, "f")))
        }, "f");
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    intersect(viewport, node, rayA) {
        const planeNormal = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), rayA.direction, __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").direction);
        const Na = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), rayA.direction, planeNormal));
        const Nb = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").direction, planeNormal));
        const da = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").origin, rayA.origin), Nb) / gl_matrix_1.vec3.dot(rayA.direction, Nb);
        const db = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), rayA.origin, __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").origin), Na) / gl_matrix_1.vec3.dot(__classPrivateFieldGet(this, _LineConstraint_dragRay, "f").direction, Na);
        let pointA = gl_matrix_1.vec3.create();
        if (da < 0) {
            gl_matrix_1.vec3.copy(pointA, rayA.origin);
        }
        else {
            pointA = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), rayA.origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), rayA.direction, gl_matrix_1.vec3.fromValues(da, da, da)));
        }
        let pointB = gl_matrix_1.vec3.create();
        if (db < 0) {
            gl_matrix_1.vec3.copy(pointB, __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").origin);
        }
        else if (db < __classPrivateFieldGet(this, _LineConstraint_dragLineLength, "f")) {
            pointB = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineConstraint_dragRay, "f").direction, gl_matrix_1.vec3.fromValues(db, db, db)));
        }
        else {
            gl_matrix_1.vec3.copy(pointB, __classPrivateFieldGet(this, _LineConstraint_point2, "f"));
        }
        const distance = gl_matrix_1.vec3.distance(pointA, pointB);
        if (distance < __classPrivateFieldGet(this, _LineConstraint_radius, "f"))
            return { distance, transformation: (0, DragConstraintsHelper_1.calculateDragMatrix)(node, pointB, __classPrivateFieldGet(this, _LineConstraint_rotation, "f"), __classPrivateFieldGet(this, _LineConstraint_dragOrigin, "f"), pointA) };
        return;
    }
    setup(viewport, node, ray, intersection, previousDragMatrix) {
        const data = node.data.find(d => d instanceof InteractionData_1.InteractionData);
        __classPrivateFieldSet(this, _LineConstraint_dragOrigin, data && data.dragOrigin ? gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), data.dragOrigin, node.worldMatrix) : gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), intersection.point, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), previousDragMatrix)), "f");
        return this.intersect(viewport, node, ray);
    }
}
exports.LineConstraint = LineConstraint;
_LineConstraint_dragLineLength = new WeakMap(), _LineConstraint_dragOrigin = new WeakMap(), _LineConstraint_dragRay = new WeakMap(), _LineConstraint_point1 = new WeakMap(), _LineConstraint_point2 = new WeakMap(), _LineConstraint_radius = new WeakMap(), _LineConstraint_rotation = new WeakMap();
//# sourceMappingURL=LineConstraint.js.map