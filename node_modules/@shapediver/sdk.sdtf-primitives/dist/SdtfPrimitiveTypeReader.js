"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfPrimitiveTypeReader = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const SdtfPrimitiveTypeValidator_1 = require("./SdtfPrimitiveTypeValidator");
class SdtfPrimitiveTypeReader {
    constructor() {
        this.validator = new SdtfPrimitiveTypeValidator_1.SdtfPrimitiveTypeValidator();
    }
    readComponent(component) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const typeHint = (_a = component.typeHint) === null || _a === void 0 ? void 0 : _a.name;
            // Make sure that the component consists of valid data
            if (!this.validator.validateComponent(typeHint, component.value, component.accessor)) {
                throw new sdk_sdtf_core_1.SdtfError(`Cannot read value of type '${typeHint}': Invalid component.`);
            }
            // Map the component data and return the result
            switch (typeHint) {
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.BOOLEAN:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.CHAR:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DECIMAL:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DOUBLE:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.GUID:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT8:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT16:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT32:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT64:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.SINGLE:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.STRING:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT8:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT16:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT32:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT64:
                    return component.value; // Nothing to map here
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.COLOR:
                    return this.mapColor(component.value);
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DATA:
                case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.IMAGE:
                    return this.mapGenericData(yield ((_b = component.accessor) === null || _b === void 0 ? void 0 : _b.getContent()));
                default:
                    (0, sdk_sdtf_core_1.sdAssertUnreachable)(typeHint);
            }
        });
    }
    /**
     * The internal representation of Color is either an array or a string (legacy).
     * Its external representation is a number-array.
     * @private
     */
    mapColor(content) {
        let parts;
        if (Array.isArray(content)) {
            // Handle regular color
            parts = content;
        }
        else {
            // Handle legacy color: Map sdTF color string to array
            parts = content.split(",").map(p => Number(p));
        }
        let res = [...parts];
        // Default alpha content is `1`
        if (res.length === 3)
            res = [...parts, 1];
        return res;
    }
    /**
     * Data content is stored in a binary buffer.
     * Its external representation is its data.
     * @private
     * @throws {@link SdtfError} when content is not a {@link ISdtfBufferValue}.
     */
    mapGenericData(content) {
        return content === null || content === void 0 ? void 0 : content.data;
    }
}
exports.SdtfPrimitiveTypeReader = SdtfPrimitiveTypeReader;
//# sourceMappingURL=SdtfPrimitiveTypeReader.js.map