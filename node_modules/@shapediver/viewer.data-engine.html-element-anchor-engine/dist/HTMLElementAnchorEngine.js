"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorEngine = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
let HTMLElementAnchorEngine = class HTMLElementAnchorEngine {
    constructor() {
        // #region Properties (2)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._inputValidator = tsyringe_1.container.resolve(viewer_shared_services_1.InputValidator);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        // #endregion Public Methods (1)
    }
    // #endregion Properties (2)
    // #region Public Methods (1)
    /**
     * Load the material content into a scene graph node.
     *
     * @param content the material content
     * @returns the scene graph node
     */
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const node = new viewer_shared_node_tree_1.TreeNode('htmlElementAnchors');
                if (content.format === 'tag2d') {
                    const data = content.data;
                    data.forEach((element) => {
                        // we need a location and a text, otherwise this doesn't make sense
                        if (!element.location || !element.text) {
                            this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.');
                            return;
                        }
                        const cleanedText = this._inputValidator.sanitize(element.text);
                        node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({
                            location: this._converter.toVec3(element.location),
                            data: { color: this._converter.toColor(element.color, '#000000'), text: cleanedText }
                        }));
                    });
                }
                else if (content.format === 'anchor') {
                    const data = content.data;
                    data.forEach((element) => {
                        if (!element.location || !element.data) {
                            this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');
                            return;
                        }
                        let position;
                        if (element.data.position)
                            position = {
                                vertical: element.data.position.vertical,
                                horizontal: element.data.position.horizontal
                            };
                        let intersectionTarget;
                        if (element.intersectionTarget) {
                            if (typeof element.intersectionTarget === 'string' || Array.isArray(element.intersectionTarget)) {
                                intersectionTarget = element.intersectionTarget;
                            }
                            else if (element.intersectionTarget.min && element.intersectionTarget.max) {
                                intersectionTarget = new viewer_shared_math_1.Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max));
                            }
                        }
                        if (!element.format || (element.format === 'text')) {
                            if (!element.data.text) {
                                this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.');
                                return;
                            }
                            const textData = element.data;
                            const cleanedText = this._inputValidator.sanitize(textData.text);
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({
                                location: this._converter.toVec3(element.location),
                                data: {
                                    color: this._converter.toColor(textData.color, '#000000'),
                                    text: cleanedText,
                                    hidden: textData.hidden,
                                    textAlign: textData.textAlign,
                                    position
                                },
                                hideable: element.hideable,
                                viewports: element.viewports,
                                intersectionTarget
                            }));
                        }
                        else if (element.format === 'image') {
                            if (!element.data.src || !element.data.width || !element.data.height || !element.data.alt) {
                                this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');
                                return;
                            }
                            const imageData = element.data;
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorImageData({
                                location: this._converter.toVec3(element.location),
                                data: {
                                    alt: imageData.alt,
                                    height: typeof imageData.height === 'string' ? +imageData.height : imageData.height,
                                    width: typeof imageData.width === 'string' ? +imageData.width : imageData.width,
                                    src: imageData.src,
                                    hidden: imageData.hidden,
                                    position
                                },
                                hideable: element.hideable,
                                viewports: element.viewports,
                                intersectionTarget
                            }));
                        }
                        this._logger.warn(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);
                    });
                }
                return node;
            }
            catch (e) {
                const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('HTMLElementAnchorEngine.load: Loading of anchors failed.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGING_TOPIC.DATA_PROCESSING, `HTMLElementAnchorEngine.load`, error);
            }
        });
    }
};
HTMLElementAnchorEngine = __decorate([
    (0, tsyringe_1.singleton)()
], HTMLElementAnchorEngine);
exports.HTMLElementAnchorEngine = HTMLElementAnchorEngine;
//# sourceMappingURL=HTMLElementAnchorEngine.js.map